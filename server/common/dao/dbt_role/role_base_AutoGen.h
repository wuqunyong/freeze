// ---------------------------------------------------------------------
// THIS FILE IS AUTO-GENERATED BY SCRIPT, SO PLEASE DON'T MODIFY IT BY YOURSELF!
// Source: apie.role_base
// ---------------------------------------------------------------------

#pragma once

#include <algorithm>
#include <cstdlib>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <tuple>
#include <vector>

#include "apie.h"

namespace apie {
namespace dbt_role {

class role_base_AutoGen
    : public DeclarativeBase,
      public std::enable_shared_from_this<role_base_AutoGen> {

  using InsertCB =
      std::function<void(apie::status::Status, bool, uint64_t, uint64_t)>;
  using UpdateCB = std::function<void(apie::status::Status, bool, uint64_t)>;
  using DeleteCB = std::function<void(apie::status::Status, bool, uint64_t)>;

private:
  struct db_fields {
    uint64_t user_id;
    uint64_t game_id = 0;
    uint32_t level = 0;
    int64_t register_time = 0;
    int64_t login_time;
    int64_t offline_time;
    std::string name = "";
  };

  virtual std::string getFieldName(uint32_t iIndex) override {

    static std::map<uint32_t, std::string> kFieldNameMap = {
        {role_base_AutoGen::user_id, "user_id"},
        {role_base_AutoGen::game_id, "game_id"},
        {role_base_AutoGen::level, "level"},
        {role_base_AutoGen::register_time, "register_time"},
        {role_base_AutoGen::login_time, "login_time"},
        {role_base_AutoGen::offline_time, "offline_time"},
        {role_base_AutoGen::name, "name"}};

    return kFieldNameMap[iIndex];
  }

public:
  enum Fields {
    user_id = 0,
    game_id = 1,
    level = 2,
    register_time = 3,
    login_time = 4,
    offline_time = 5,
    name = 6,
  };

  static std::shared_ptr<role_base_AutoGen> Create(uint64_t user_id) {
    return std::shared_ptr<role_base_AutoGen>(new role_base_AutoGen(user_id));
  }

  role_base_AutoGen(uint64_t user_id) {
    this->fields.user_id = user_id;

    this->bindTable(DeclarativeBase::DBType::DBT_Role, getFactoryName());
  }

  virtual ~role_base_AutoGen() {}

  void set_user_id(uint64_t user_id) {
    this->fields.user_id = user_id;
    this->markDirty({role_base_AutoGen::user_id});
  }

  uint64_t get_user_id() const { return this->fields.user_id; }

  void set_game_id(uint64_t game_id) {
    this->fields.game_id = game_id;
    this->markDirty({role_base_AutoGen::game_id});
  }

  uint64_t get_game_id() const { return this->fields.game_id; }

  void set_level(uint32_t level) {
    this->fields.level = level;
    this->markDirty({role_base_AutoGen::level});
  }

  uint32_t get_level() const { return this->fields.level; }

  void set_register_time(int64_t register_time) {
    this->fields.register_time = register_time;
    this->markDirty({role_base_AutoGen::register_time});
  }

  int64_t get_register_time() const { return this->fields.register_time; }

  void set_login_time(int64_t login_time) {
    this->fields.login_time = login_time;
    this->markDirty({role_base_AutoGen::login_time});
  }

  int64_t get_login_time() const { return this->fields.login_time; }

  void set_offline_time(int64_t offline_time) {
    this->fields.offline_time = offline_time;
    this->markDirty({role_base_AutoGen::offline_time});
  }

  int64_t get_offline_time() const { return this->fields.offline_time; }

  void set_name(std::string name) {
    this->fields.name = name;
    this->markDirty({role_base_AutoGen::name});
  }

  std::string get_name() const { return this->fields.name; }

public:
  void SetDbProxyServer(::rpc_msg::CHANNEL server) { m_optServer = server; }

  void Insert(InsertCB cb = nullptr) {
    if (!m_optServer.has_value()) {
      ASYNC_PIE_LOG(
          PIE_ERROR,
          "DBOpreateError | Insert | isBind:{} | dbName:{} | tableName:{}",
          isBind(), getgDbName(), getTableName());
      return;
    }

    auto channel = m_optServer.value();
    InsertToDb(channel, *this, cb);
  }

  void Update(UpdateCB cb = nullptr) {
    if (!m_optServer.has_value()) {
      ASYNC_PIE_LOG(
          PIE_ERROR,
          "DBOpreateError | Update | isBind:{} | dbName:{} | tableName:{}",
          isBind(), getgDbName(), getTableName());
      return;
    }

    auto channel = m_optServer.value();
    UpdateToDb(channel, *this, cb);
  }

  void Delete(DeleteCB cb = nullptr) {
    if (!m_optServer.has_value()) {
      ASYNC_PIE_LOG(
          PIE_ERROR,
          "DBOpreateError | Delete | isBind:{} | dbName:{} | tableName:{}",
          isBind(), getgDbName(), getTableName());
      return;
    }

    auto channel = m_optServer.value();
    DeleteFromDb(channel, *this, cb);
  }

  DAO_DEFINE_TYPE_INTRUSIVE_MACRO(role_base_AutoGen, db_fields, role_base);
};

} // namespace dbt_role

APIE_REGISTER_TABLE(DeclarativeBase::DBType::DBT_Role,
                    apie::dbt_role::role_base_AutoGen, role_base)

} // namespace apie
