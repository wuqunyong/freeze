// ---------------------------------------------------------------------
// THIS FILE IS AUTO-GENERATED BY SCRIPT, SO PLEASE DON'T MODIFY IT BY YOURSELF!
// Source: apie_account.account_name
// ---------------------------------------------------------------------

#pragma once

#include <algorithm>
#include <cstdlib>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <tuple>
#include <vector>

#include "apie.h"

namespace apie {
namespace dbt_account {

class account_name_AutoGen
    : public DeclarativeBase,
      public std::enable_shared_from_this<account_name_AutoGen> {
private:
  struct db_fields {
    uint64_t account_id;
    std::string name;
  };

  virtual std::string getFieldName(uint32_t iIndex) override {

    static std::map<uint32_t, std::string> kFieldNameMap = {
        {account_name_AutoGen::account_id, "account_id"},
        {account_name_AutoGen::name, "name"}};

    return kFieldNameMap[iIndex];
  }

public:
	using InsertCB = std::function<void(apie::status::Status, bool result, uint64_t affectedRows, uint64_t insertId)>;
	using UpdateCB = std::function<void(apie::status::Status, bool result, uint64_t affectedRows)>;
	using DeleteCB = std::function<void(apie::status::Status, bool result, uint64_t affectedRows)>;


  enum Fields {
    account_id = 0,
    name = 1,
  };

  static std::shared_ptr<account_name_AutoGen> Create(uint64_t account_id) {
    return std::shared_ptr<account_name_AutoGen>(
        new account_name_AutoGen(account_id));
  }

  account_name_AutoGen(uint64_t account_id) {
    this->fields.account_id = account_id;

    this->bindTable(DeclarativeBase::DBType::DBT_Account, getFactoryName());
  }

  virtual ~account_name_AutoGen() {}

  void set_account_id(uint64_t account_id) {
    this->fields.account_id = account_id;
    this->markDirty({account_name_AutoGen::account_id});
  }

  uint64_t get_account_id() const { return this->fields.account_id; }

  void set_name(std::string name) {
    this->fields.name = name;
    this->markDirty({account_name_AutoGen::name});
  }

  std::string get_name() const { return this->fields.name; }

public:
    void SetDbProxyServer(::rpc_msg::CHANNEL server) {
        m_optServer = server;
    }

	void Insert(InsertCB cb = nullptr) {
		if (!m_optServer.has_value())
		{
			return;
		}

		auto channel = m_optServer.value();
		InsertToDb(channel, *this, cb);
	}

    void Update(UpdateCB cb = nullptr) {
        if (!m_optServer.has_value())
        {
            return;
        }

        auto channel = m_optServer.value();
        UpdateToDb(channel, *this, cb);
    }

	void Delete(DeleteCB cb = nullptr) {
		if (!m_optServer.has_value())
		{
			return;
		}

		auto channel = m_optServer.value();
        DeleteFromDb(channel, *this, cb);
	}


  DAO_DEFINE_TYPE_INTRUSIVE_MACRO(account_name_AutoGen, db_fields,
                                  account_name);
};

} // namespace dbt_account

APIE_REGISTER_TABLE(DeclarativeBase::DBType::DBT_Account,
                    apie::dbt_account::account_name_AutoGen, account_name)

} // namespace apie
