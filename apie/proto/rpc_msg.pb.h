// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc_msg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rpc_5fmsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rpc_5fmsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rpc_5fmsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rpc_5fmsg_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_rpc_5fmsg_2eproto;
namespace rpc_msg {
class CHANNEL;
struct CHANNELDefaultTypeInternal;
extern CHANNELDefaultTypeInternal _CHANNEL_default_instance_;
class CLIENT_IDENTIFIER;
struct CLIENT_IDENTIFIERDefaultTypeInternal;
extern CLIENT_IDENTIFIERDefaultTypeInternal _CLIENT_IDENTIFIER_default_instance_;
class CONTROLLER;
struct CONTROLLERDefaultTypeInternal;
extern CONTROLLERDefaultTypeInternal _CONTROLLER_default_instance_;
class ClientMessageInfo;
struct ClientMessageInfoDefaultTypeInternal;
extern ClientMessageInfoDefaultTypeInternal _ClientMessageInfo_default_instance_;
class PRC_DeMultiplexer_Forward;
struct PRC_DeMultiplexer_ForwardDefaultTypeInternal;
extern PRC_DeMultiplexer_ForwardDefaultTypeInternal _PRC_DeMultiplexer_Forward_default_instance_;
class RPC_Multiplexer_Forward;
struct RPC_Multiplexer_ForwardDefaultTypeInternal;
extern RPC_Multiplexer_ForwardDefaultTypeInternal _RPC_Multiplexer_Forward_default_instance_;
class RPC_REQUEST;
struct RPC_REQUESTDefaultTypeInternal;
extern RPC_REQUESTDefaultTypeInternal _RPC_REQUEST_default_instance_;
class RPC_RESPONSE;
struct RPC_RESPONSEDefaultTypeInternal;
extern RPC_RESPONSEDefaultTypeInternal _RPC_RESPONSE_default_instance_;
class RoleIdentifier;
struct RoleIdentifierDefaultTypeInternal;
extern RoleIdentifierDefaultTypeInternal _RoleIdentifier_default_instance_;
class SERVER_IDENTIFIER;
struct SERVER_IDENTIFIERDefaultTypeInternal;
extern SERVER_IDENTIFIERDefaultTypeInternal _SERVER_IDENTIFIER_default_instance_;
class STATUS;
struct STATUSDefaultTypeInternal;
extern STATUSDefaultTypeInternal _STATUS_default_instance_;
}  // namespace rpc_msg
PROTOBUF_NAMESPACE_OPEN
template<> ::rpc_msg::CHANNEL* Arena::CreateMaybeMessage<::rpc_msg::CHANNEL>(Arena*);
template<> ::rpc_msg::CLIENT_IDENTIFIER* Arena::CreateMaybeMessage<::rpc_msg::CLIENT_IDENTIFIER>(Arena*);
template<> ::rpc_msg::CONTROLLER* Arena::CreateMaybeMessage<::rpc_msg::CONTROLLER>(Arena*);
template<> ::rpc_msg::ClientMessageInfo* Arena::CreateMaybeMessage<::rpc_msg::ClientMessageInfo>(Arena*);
template<> ::rpc_msg::PRC_DeMultiplexer_Forward* Arena::CreateMaybeMessage<::rpc_msg::PRC_DeMultiplexer_Forward>(Arena*);
template<> ::rpc_msg::RPC_Multiplexer_Forward* Arena::CreateMaybeMessage<::rpc_msg::RPC_Multiplexer_Forward>(Arena*);
template<> ::rpc_msg::RPC_REQUEST* Arena::CreateMaybeMessage<::rpc_msg::RPC_REQUEST>(Arena*);
template<> ::rpc_msg::RPC_RESPONSE* Arena::CreateMaybeMessage<::rpc_msg::RPC_RESPONSE>(Arena*);
template<> ::rpc_msg::RoleIdentifier* Arena::CreateMaybeMessage<::rpc_msg::RoleIdentifier>(Arena*);
template<> ::rpc_msg::SERVER_IDENTIFIER* Arena::CreateMaybeMessage<::rpc_msg::SERVER_IDENTIFIER>(Arena*);
template<> ::rpc_msg::STATUS* Arena::CreateMaybeMessage<::rpc_msg::STATUS>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rpc_msg {

enum RPC_OPCODES : int {
  RPC_None = 0,
  RPC_MysqlDescTable = 401,
  RPC_MysqlQuery = 402,
  RPC_MysqlInsert = 403,
  RPC_MysqlUpdate = 404,
  RPC_MysqlDelete = 405,
  RPC_MysqlQueryByFilter = 406,
  RPC_MysqlMultiQuery = 407,
  RPC_MysqlQueryAll = 408,
  RPC_MysqlStatement = 409,
  RPC_OPCODES_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RPC_OPCODES_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RPC_OPCODES_IsValid(int value);
constexpr RPC_OPCODES RPC_OPCODES_MIN = RPC_None;
constexpr RPC_OPCODES RPC_OPCODES_MAX = RPC_MysqlStatement;
constexpr int RPC_OPCODES_ARRAYSIZE = RPC_OPCODES_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RPC_OPCODES_descriptor();
template<typename T>
inline const std::string& RPC_OPCODES_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RPC_OPCODES>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RPC_OPCODES_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RPC_OPCODES_descriptor(), enum_t_value);
}
inline bool RPC_OPCODES_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RPC_OPCODES* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RPC_OPCODES>(
    RPC_OPCODES_descriptor(), name, value);
}
enum RPC_CODE : int {
  CODE_Ok = 0,
  CODE_Ok_Async = 1,
  CODE_Timeout = 100,
  CODE_Unregister = 101,
  CODE_ParseError = 102,
  CODE_ErrorServerPost = 103,
  CODE_RouteNotLinkToServer = 104,
  CODE_RouteSendToServerError = 105,
  CODE_OpcodeUnregister = 106,
  CODE_CreateMsgError = 107,
  CODE_LogicThreadNull = 108,
  CODE_NotReceivedReply = 109,
  CODE_NotSend = 110,
  CODE_LoadFromDbError = 111,
  CODE_DirtyFlagZero = 112,
  CODE_QueryError = 113,
  CODE_TableNameNotExistError = 114,
  CODE_GenerateQuerySQLError = 115,
  CODE_NotMatchedResultError = 116,
  RPC_CODE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RPC_CODE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RPC_CODE_IsValid(int value);
constexpr RPC_CODE RPC_CODE_MIN = CODE_Ok;
constexpr RPC_CODE RPC_CODE_MAX = CODE_NotMatchedResultError;
constexpr int RPC_CODE_ARRAYSIZE = RPC_CODE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RPC_CODE_descriptor();
template<typename T>
inline const std::string& RPC_CODE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RPC_CODE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RPC_CODE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RPC_CODE_descriptor(), enum_t_value);
}
inline bool RPC_CODE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RPC_CODE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RPC_CODE>(
    RPC_CODE_descriptor(), name, value);
}
// ===================================================================

class CHANNEL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc_msg.CHANNEL) */ {
 public:
  inline CHANNEL() : CHANNEL(nullptr) {}
  ~CHANNEL() override;
  explicit PROTOBUF_CONSTEXPR CHANNEL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CHANNEL(const CHANNEL& from);
  CHANNEL(CHANNEL&& from) noexcept
    : CHANNEL() {
    *this = ::std::move(from);
  }

  inline CHANNEL& operator=(const CHANNEL& from) {
    CopyFrom(from);
    return *this;
  }
  inline CHANNEL& operator=(CHANNEL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CHANNEL& default_instance() {
    return *internal_default_instance();
  }
  static inline const CHANNEL* internal_default_instance() {
    return reinterpret_cast<const CHANNEL*>(
               &_CHANNEL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CHANNEL& a, CHANNEL& b) {
    a.Swap(&b);
  }
  inline void Swap(CHANNEL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CHANNEL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CHANNEL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CHANNEL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CHANNEL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CHANNEL& from) {
    CHANNEL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CHANNEL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc_msg.CHANNEL";
  }
  protected:
  explicit CHANNEL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorIdFieldNumber = 4,
    kRealmFieldNumber = 1,
    kTypeFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // string actor_id = 4;
  void clear_actor_id();
  const std::string& actor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor_id();
  PROTOBUF_NODISCARD std::string* release_actor_id();
  void set_allocated_actor_id(std::string* actor_id);
  private:
  const std::string& _internal_actor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor_id(const std::string& value);
  std::string* _internal_mutable_actor_id();
  public:

  // uint32 realm = 1;
  void clear_realm();
  uint32_t realm() const;
  void set_realm(uint32_t value);
  private:
  uint32_t _internal_realm() const;
  void _internal_set_realm(uint32_t value);
  public:

  // uint32 type = 2;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 id = 3;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rpc_msg.CHANNEL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_id_;
    uint32_t realm_;
    uint32_t type_;
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class CONTROLLER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc_msg.CONTROLLER) */ {
 public:
  inline CONTROLLER() : CONTROLLER(nullptr) {}
  ~CONTROLLER() override;
  explicit PROTOBUF_CONSTEXPR CONTROLLER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CONTROLLER(const CONTROLLER& from);
  CONTROLLER(CONTROLLER&& from) noexcept
    : CONTROLLER() {
    *this = ::std::move(from);
  }

  inline CONTROLLER& operator=(const CONTROLLER& from) {
    CopyFrom(from);
    return *this;
  }
  inline CONTROLLER& operator=(CONTROLLER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CONTROLLER& default_instance() {
    return *internal_default_instance();
  }
  static inline const CONTROLLER* internal_default_instance() {
    return reinterpret_cast<const CONTROLLER*>(
               &_CONTROLLER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CONTROLLER& a, CONTROLLER& b) {
    a.Swap(&b);
  }
  inline void Swap(CONTROLLER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CONTROLLER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CONTROLLER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CONTROLLER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CONTROLLER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CONTROLLER& from) {
    CONTROLLER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CONTROLLER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc_msg.CONTROLLER";
  }
  protected:
  explicit CONTROLLER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqIdFieldNumber = 1,
    kTimeoutMsFieldNumber = 2,
    kServerStreamFieldNumber = 3,
  };
  // uint64 seq_id = 1;
  void clear_seq_id();
  uint64_t seq_id() const;
  void set_seq_id(uint64_t value);
  private:
  uint64_t _internal_seq_id() const;
  void _internal_set_seq_id(uint64_t value);
  public:

  // uint64 timeout_ms = 2;
  void clear_timeout_ms();
  uint64_t timeout_ms() const;
  void set_timeout_ms(uint64_t value);
  private:
  uint64_t _internal_timeout_ms() const;
  void _internal_set_timeout_ms(uint64_t value);
  public:

  // bool server_stream = 3;
  void clear_server_stream();
  bool server_stream() const;
  void set_server_stream(bool value);
  private:
  bool _internal_server_stream() const;
  void _internal_set_server_stream(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rpc_msg.CONTROLLER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t seq_id_;
    uint64_t timeout_ms_;
    bool server_stream_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class ClientMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc_msg.ClientMessageInfo) */ {
 public:
  inline ClientMessageInfo() : ClientMessageInfo(nullptr) {}
  ~ClientMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR ClientMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientMessageInfo(const ClientMessageInfo& from);
  ClientMessageInfo(ClientMessageInfo&& from) noexcept
    : ClientMessageInfo() {
    *this = ::std::move(from);
  }

  inline ClientMessageInfo& operator=(const ClientMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMessageInfo& operator=(ClientMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientMessageInfo* internal_default_instance() {
    return reinterpret_cast<const ClientMessageInfo*>(
               &_ClientMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientMessageInfo& a, ClientMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientMessageInfo& from) {
    ClientMessageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc_msg.ClientMessageInfo";
  }
  protected:
  explicit ClientMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kSeqNumFieldNumber = 2,
    kOpcodeFieldNumber = 3,
    kResponseOpcodeFieldNumber = 4,
    kConnetionTypeFieldNumber = 5,
  };
  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // uint32 seq_num = 2;
  void clear_seq_num();
  uint32_t seq_num() const;
  void set_seq_num(uint32_t value);
  private:
  uint32_t _internal_seq_num() const;
  void _internal_set_seq_num(uint32_t value);
  public:

  // uint32 opcode = 3;
  void clear_opcode();
  uint32_t opcode() const;
  void set_opcode(uint32_t value);
  private:
  uint32_t _internal_opcode() const;
  void _internal_set_opcode(uint32_t value);
  public:

  // uint32 response_opcode = 4;
  void clear_response_opcode();
  uint32_t response_opcode() const;
  void set_response_opcode(uint32_t value);
  private:
  uint32_t _internal_response_opcode() const;
  void _internal_set_response_opcode(uint32_t value);
  public:

  // uint32 connetion_type = 5;
  void clear_connetion_type();
  uint32_t connetion_type() const;
  void set_connetion_type(uint32_t value);
  private:
  uint32_t _internal_connetion_type() const;
  void _internal_set_connetion_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rpc_msg.ClientMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t session_id_;
    uint32_t seq_num_;
    uint32_t opcode_;
    uint32_t response_opcode_;
    uint32_t connetion_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class RoleIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc_msg.RoleIdentifier) */ {
 public:
  inline RoleIdentifier() : RoleIdentifier(nullptr) {}
  ~RoleIdentifier() override;
  explicit PROTOBUF_CONSTEXPR RoleIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleIdentifier(const RoleIdentifier& from);
  RoleIdentifier(RoleIdentifier&& from) noexcept
    : RoleIdentifier() {
    *this = ::std::move(from);
  }

  inline RoleIdentifier& operator=(const RoleIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleIdentifier& operator=(RoleIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleIdentifier* internal_default_instance() {
    return reinterpret_cast<const RoleIdentifier*>(
               &_RoleIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoleIdentifier& a, RoleIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleIdentifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleIdentifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleIdentifier& from) {
    RoleIdentifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc_msg.RoleIdentifier";
  }
  protected:
  explicit RoleIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGwIdFieldNumber = 2,
    kInfoFieldNumber = 3,
    kUserIdFieldNumber = 1,
  };
  // .rpc_msg.CHANNEL gw_id = 2;
  bool has_gw_id() const;
  private:
  bool _internal_has_gw_id() const;
  public:
  void clear_gw_id();
  const ::rpc_msg::CHANNEL& gw_id() const;
  PROTOBUF_NODISCARD ::rpc_msg::CHANNEL* release_gw_id();
  ::rpc_msg::CHANNEL* mutable_gw_id();
  void set_allocated_gw_id(::rpc_msg::CHANNEL* gw_id);
  private:
  const ::rpc_msg::CHANNEL& _internal_gw_id() const;
  ::rpc_msg::CHANNEL* _internal_mutable_gw_id();
  public:
  void unsafe_arena_set_allocated_gw_id(
      ::rpc_msg::CHANNEL* gw_id);
  ::rpc_msg::CHANNEL* unsafe_arena_release_gw_id();

  // .rpc_msg.ClientMessageInfo info = 3;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::rpc_msg::ClientMessageInfo& info() const;
  PROTOBUF_NODISCARD ::rpc_msg::ClientMessageInfo* release_info();
  ::rpc_msg::ClientMessageInfo* mutable_info();
  void set_allocated_info(::rpc_msg::ClientMessageInfo* info);
  private:
  const ::rpc_msg::ClientMessageInfo& _internal_info() const;
  ::rpc_msg::ClientMessageInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::rpc_msg::ClientMessageInfo* info);
  ::rpc_msg::ClientMessageInfo* unsafe_arena_release_info();

  // uint64 user_id = 1;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rpc_msg.RoleIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::rpc_msg::CHANNEL* gw_id_;
    ::rpc_msg::ClientMessageInfo* info_;
    uint64_t user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class CLIENT_IDENTIFIER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc_msg.CLIENT_IDENTIFIER) */ {
 public:
  inline CLIENT_IDENTIFIER() : CLIENT_IDENTIFIER(nullptr) {}
  ~CLIENT_IDENTIFIER() override;
  explicit PROTOBUF_CONSTEXPR CLIENT_IDENTIFIER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CLIENT_IDENTIFIER(const CLIENT_IDENTIFIER& from);
  CLIENT_IDENTIFIER(CLIENT_IDENTIFIER&& from) noexcept
    : CLIENT_IDENTIFIER() {
    *this = ::std::move(from);
  }

  inline CLIENT_IDENTIFIER& operator=(const CLIENT_IDENTIFIER& from) {
    CopyFrom(from);
    return *this;
  }
  inline CLIENT_IDENTIFIER& operator=(CLIENT_IDENTIFIER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CLIENT_IDENTIFIER& default_instance() {
    return *internal_default_instance();
  }
  static inline const CLIENT_IDENTIFIER* internal_default_instance() {
    return reinterpret_cast<const CLIENT_IDENTIFIER*>(
               &_CLIENT_IDENTIFIER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CLIENT_IDENTIFIER& a, CLIENT_IDENTIFIER& b) {
    a.Swap(&b);
  }
  inline void Swap(CLIENT_IDENTIFIER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CLIENT_IDENTIFIER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CLIENT_IDENTIFIER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CLIENT_IDENTIFIER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CLIENT_IDENTIFIER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CLIENT_IDENTIFIER& from) {
    CLIENT_IDENTIFIER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLIENT_IDENTIFIER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc_msg.CLIENT_IDENTIFIER";
  }
  protected:
  explicit CLIENT_IDENTIFIER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyTopicFieldNumber = 4,
    kStubFieldNumber = 1,
    kSeqIdFieldNumber = 2,
    kRequiredReplyFieldNumber = 3,
  };
  // string reply_topic = 4;
  void clear_reply_topic();
  const std::string& reply_topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply_topic();
  PROTOBUF_NODISCARD std::string* release_reply_topic();
  void set_allocated_reply_topic(std::string* reply_topic);
  private:
  const std::string& _internal_reply_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply_topic(const std::string& value);
  std::string* _internal_mutable_reply_topic();
  public:

  // .rpc_msg.CHANNEL stub = 1;
  bool has_stub() const;
  private:
  bool _internal_has_stub() const;
  public:
  void clear_stub();
  const ::rpc_msg::CHANNEL& stub() const;
  PROTOBUF_NODISCARD ::rpc_msg::CHANNEL* release_stub();
  ::rpc_msg::CHANNEL* mutable_stub();
  void set_allocated_stub(::rpc_msg::CHANNEL* stub);
  private:
  const ::rpc_msg::CHANNEL& _internal_stub() const;
  ::rpc_msg::CHANNEL* _internal_mutable_stub();
  public:
  void unsafe_arena_set_allocated_stub(
      ::rpc_msg::CHANNEL* stub);
  ::rpc_msg::CHANNEL* unsafe_arena_release_stub();

  // uint64 seq_id = 2;
  void clear_seq_id();
  uint64_t seq_id() const;
  void set_seq_id(uint64_t value);
  private:
  uint64_t _internal_seq_id() const;
  void _internal_set_seq_id(uint64_t value);
  public:

  // bool required_reply = 3;
  void clear_required_reply();
  bool required_reply() const;
  void set_required_reply(bool value);
  private:
  bool _internal_required_reply() const;
  void _internal_set_required_reply(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rpc_msg.CLIENT_IDENTIFIER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_topic_;
    ::rpc_msg::CHANNEL* stub_;
    uint64_t seq_id_;
    bool required_reply_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class SERVER_IDENTIFIER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc_msg.SERVER_IDENTIFIER) */ {
 public:
  inline SERVER_IDENTIFIER() : SERVER_IDENTIFIER(nullptr) {}
  ~SERVER_IDENTIFIER() override;
  explicit PROTOBUF_CONSTEXPR SERVER_IDENTIFIER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SERVER_IDENTIFIER(const SERVER_IDENTIFIER& from);
  SERVER_IDENTIFIER(SERVER_IDENTIFIER&& from) noexcept
    : SERVER_IDENTIFIER() {
    *this = ::std::move(from);
  }

  inline SERVER_IDENTIFIER& operator=(const SERVER_IDENTIFIER& from) {
    CopyFrom(from);
    return *this;
  }
  inline SERVER_IDENTIFIER& operator=(SERVER_IDENTIFIER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SERVER_IDENTIFIER& default_instance() {
    return *internal_default_instance();
  }
  static inline const SERVER_IDENTIFIER* internal_default_instance() {
    return reinterpret_cast<const SERVER_IDENTIFIER*>(
               &_SERVER_IDENTIFIER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SERVER_IDENTIFIER& a, SERVER_IDENTIFIER& b) {
    a.Swap(&b);
  }
  inline void Swap(SERVER_IDENTIFIER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SERVER_IDENTIFIER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SERVER_IDENTIFIER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SERVER_IDENTIFIER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SERVER_IDENTIFIER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SERVER_IDENTIFIER& from) {
    SERVER_IDENTIFIER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SERVER_IDENTIFIER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc_msg.SERVER_IDENTIFIER";
  }
  protected:
  explicit SERVER_IDENTIFIER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStubFieldNumber = 1,
  };
  // .rpc_msg.CHANNEL stub = 1;
  bool has_stub() const;
  private:
  bool _internal_has_stub() const;
  public:
  void clear_stub();
  const ::rpc_msg::CHANNEL& stub() const;
  PROTOBUF_NODISCARD ::rpc_msg::CHANNEL* release_stub();
  ::rpc_msg::CHANNEL* mutable_stub();
  void set_allocated_stub(::rpc_msg::CHANNEL* stub);
  private:
  const ::rpc_msg::CHANNEL& _internal_stub() const;
  ::rpc_msg::CHANNEL* _internal_mutable_stub();
  public:
  void unsafe_arena_set_allocated_stub(
      ::rpc_msg::CHANNEL* stub);
  ::rpc_msg::CHANNEL* unsafe_arena_release_stub();

  // @@protoc_insertion_point(class_scope:rpc_msg.SERVER_IDENTIFIER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::rpc_msg::CHANNEL* stub_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class RPC_REQUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc_msg.RPC_REQUEST) */ {
 public:
  inline RPC_REQUEST() : RPC_REQUEST(nullptr) {}
  ~RPC_REQUEST() override;
  explicit PROTOBUF_CONSTEXPR RPC_REQUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RPC_REQUEST(const RPC_REQUEST& from);
  RPC_REQUEST(RPC_REQUEST&& from) noexcept
    : RPC_REQUEST() {
    *this = ::std::move(from);
  }

  inline RPC_REQUEST& operator=(const RPC_REQUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline RPC_REQUEST& operator=(RPC_REQUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RPC_REQUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const RPC_REQUEST* internal_default_instance() {
    return reinterpret_cast<const RPC_REQUEST*>(
               &_RPC_REQUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RPC_REQUEST& a, RPC_REQUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(RPC_REQUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RPC_REQUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RPC_REQUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RPC_REQUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RPC_REQUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RPC_REQUEST& from) {
    RPC_REQUEST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RPC_REQUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc_msg.RPC_REQUEST";
  }
  protected:
  explicit RPC_REQUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsDataFieldNumber = 5,
    kClientFieldNumber = 1,
    kServerFieldNumber = 2,
    kServerStreamFieldNumber = 3,
    kOpcodesFieldNumber = 4,
  };
  // bytes args_data = 5;
  void clear_args_data();
  const std::string& args_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args_data();
  PROTOBUF_NODISCARD std::string* release_args_data();
  void set_allocated_args_data(std::string* args_data);
  private:
  const std::string& _internal_args_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args_data(const std::string& value);
  std::string* _internal_mutable_args_data();
  public:

  // .rpc_msg.CLIENT_IDENTIFIER client = 1;
  bool has_client() const;
  private:
  bool _internal_has_client() const;
  public:
  void clear_client();
  const ::rpc_msg::CLIENT_IDENTIFIER& client() const;
  PROTOBUF_NODISCARD ::rpc_msg::CLIENT_IDENTIFIER* release_client();
  ::rpc_msg::CLIENT_IDENTIFIER* mutable_client();
  void set_allocated_client(::rpc_msg::CLIENT_IDENTIFIER* client);
  private:
  const ::rpc_msg::CLIENT_IDENTIFIER& _internal_client() const;
  ::rpc_msg::CLIENT_IDENTIFIER* _internal_mutable_client();
  public:
  void unsafe_arena_set_allocated_client(
      ::rpc_msg::CLIENT_IDENTIFIER* client);
  ::rpc_msg::CLIENT_IDENTIFIER* unsafe_arena_release_client();

  // .rpc_msg.SERVER_IDENTIFIER server = 2;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const ::rpc_msg::SERVER_IDENTIFIER& server() const;
  PROTOBUF_NODISCARD ::rpc_msg::SERVER_IDENTIFIER* release_server();
  ::rpc_msg::SERVER_IDENTIFIER* mutable_server();
  void set_allocated_server(::rpc_msg::SERVER_IDENTIFIER* server);
  private:
  const ::rpc_msg::SERVER_IDENTIFIER& _internal_server() const;
  ::rpc_msg::SERVER_IDENTIFIER* _internal_mutable_server();
  public:
  void unsafe_arena_set_allocated_server(
      ::rpc_msg::SERVER_IDENTIFIER* server);
  ::rpc_msg::SERVER_IDENTIFIER* unsafe_arena_release_server();

  // bool server_stream = 3;
  void clear_server_stream();
  bool server_stream() const;
  void set_server_stream(bool value);
  private:
  bool _internal_server_stream() const;
  void _internal_set_server_stream(bool value);
  public:

  // uint32 opcodes = 4;
  void clear_opcodes();
  uint32_t opcodes() const;
  void set_opcodes(uint32_t value);
  private:
  uint32_t _internal_opcodes() const;
  void _internal_set_opcodes(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rpc_msg.RPC_REQUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_data_;
    ::rpc_msg::CLIENT_IDENTIFIER* client_;
    ::rpc_msg::SERVER_IDENTIFIER* server_;
    bool server_stream_;
    uint32_t opcodes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc_msg.STATUS) */ {
 public:
  inline STATUS() : STATUS(nullptr) {}
  ~STATUS() override;
  explicit PROTOBUF_CONSTEXPR STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STATUS(const STATUS& from);
  STATUS(STATUS&& from) noexcept
    : STATUS() {
    *this = ::std::move(from);
  }

  inline STATUS& operator=(const STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline STATUS& operator=(STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const STATUS* internal_default_instance() {
    return reinterpret_cast<const STATUS*>(
               &_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(STATUS& a, STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const STATUS& from) {
    STATUS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc_msg.STATUS";
  }
  protected:
  explicit STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint32 code = 1;
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rpc_msg.STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class RPC_RESPONSE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc_msg.RPC_RESPONSE) */ {
 public:
  inline RPC_RESPONSE() : RPC_RESPONSE(nullptr) {}
  ~RPC_RESPONSE() override;
  explicit PROTOBUF_CONSTEXPR RPC_RESPONSE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RPC_RESPONSE(const RPC_RESPONSE& from);
  RPC_RESPONSE(RPC_RESPONSE&& from) noexcept
    : RPC_RESPONSE() {
    *this = ::std::move(from);
  }

  inline RPC_RESPONSE& operator=(const RPC_RESPONSE& from) {
    CopyFrom(from);
    return *this;
  }
  inline RPC_RESPONSE& operator=(RPC_RESPONSE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RPC_RESPONSE& default_instance() {
    return *internal_default_instance();
  }
  static inline const RPC_RESPONSE* internal_default_instance() {
    return reinterpret_cast<const RPC_RESPONSE*>(
               &_RPC_RESPONSE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RPC_RESPONSE& a, RPC_RESPONSE& b) {
    a.Swap(&b);
  }
  inline void Swap(RPC_RESPONSE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RPC_RESPONSE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RPC_RESPONSE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RPC_RESPONSE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RPC_RESPONSE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RPC_RESPONSE& from) {
    RPC_RESPONSE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RPC_RESPONSE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc_msg.RPC_RESPONSE";
  }
  protected:
  explicit RPC_RESPONSE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultDataFieldNumber = 6,
    kClientFieldNumber = 1,
    kServerFieldNumber = 2,
    kStatusFieldNumber = 3,
    kHasMoreFieldNumber = 4,
    kOffsetFieldNumber = 5,
  };
  // bytes result_data = 6;
  void clear_result_data();
  const std::string& result_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_data();
  PROTOBUF_NODISCARD std::string* release_result_data();
  void set_allocated_result_data(std::string* result_data);
  private:
  const std::string& _internal_result_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_data(const std::string& value);
  std::string* _internal_mutable_result_data();
  public:

  // .rpc_msg.CLIENT_IDENTIFIER client = 1;
  bool has_client() const;
  private:
  bool _internal_has_client() const;
  public:
  void clear_client();
  const ::rpc_msg::CLIENT_IDENTIFIER& client() const;
  PROTOBUF_NODISCARD ::rpc_msg::CLIENT_IDENTIFIER* release_client();
  ::rpc_msg::CLIENT_IDENTIFIER* mutable_client();
  void set_allocated_client(::rpc_msg::CLIENT_IDENTIFIER* client);
  private:
  const ::rpc_msg::CLIENT_IDENTIFIER& _internal_client() const;
  ::rpc_msg::CLIENT_IDENTIFIER* _internal_mutable_client();
  public:
  void unsafe_arena_set_allocated_client(
      ::rpc_msg::CLIENT_IDENTIFIER* client);
  ::rpc_msg::CLIENT_IDENTIFIER* unsafe_arena_release_client();

  // .rpc_msg.SERVER_IDENTIFIER server = 2;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const ::rpc_msg::SERVER_IDENTIFIER& server() const;
  PROTOBUF_NODISCARD ::rpc_msg::SERVER_IDENTIFIER* release_server();
  ::rpc_msg::SERVER_IDENTIFIER* mutable_server();
  void set_allocated_server(::rpc_msg::SERVER_IDENTIFIER* server);
  private:
  const ::rpc_msg::SERVER_IDENTIFIER& _internal_server() const;
  ::rpc_msg::SERVER_IDENTIFIER* _internal_mutable_server();
  public:
  void unsafe_arena_set_allocated_server(
      ::rpc_msg::SERVER_IDENTIFIER* server);
  ::rpc_msg::SERVER_IDENTIFIER* unsafe_arena_release_server();

  // .rpc_msg.STATUS status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::rpc_msg::STATUS& status() const;
  PROTOBUF_NODISCARD ::rpc_msg::STATUS* release_status();
  ::rpc_msg::STATUS* mutable_status();
  void set_allocated_status(::rpc_msg::STATUS* status);
  private:
  const ::rpc_msg::STATUS& _internal_status() const;
  ::rpc_msg::STATUS* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::rpc_msg::STATUS* status);
  ::rpc_msg::STATUS* unsafe_arena_release_status();

  // bool has_more = 4;
  void clear_has_more();
  bool has_more() const;
  void set_has_more(bool value);
  private:
  bool _internal_has_more() const;
  void _internal_set_has_more(bool value);
  public:

  // uint32 offset = 5;
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rpc_msg.RPC_RESPONSE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_data_;
    ::rpc_msg::CLIENT_IDENTIFIER* client_;
    ::rpc_msg::SERVER_IDENTIFIER* server_;
    ::rpc_msg::STATUS* status_;
    bool has_more_;
    uint32_t offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class RPC_Multiplexer_Forward final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc_msg.RPC_Multiplexer_Forward) */ {
 public:
  inline RPC_Multiplexer_Forward() : RPC_Multiplexer_Forward(nullptr) {}
  ~RPC_Multiplexer_Forward() override;
  explicit PROTOBUF_CONSTEXPR RPC_Multiplexer_Forward(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RPC_Multiplexer_Forward(const RPC_Multiplexer_Forward& from);
  RPC_Multiplexer_Forward(RPC_Multiplexer_Forward&& from) noexcept
    : RPC_Multiplexer_Forward() {
    *this = ::std::move(from);
  }

  inline RPC_Multiplexer_Forward& operator=(const RPC_Multiplexer_Forward& from) {
    CopyFrom(from);
    return *this;
  }
  inline RPC_Multiplexer_Forward& operator=(RPC_Multiplexer_Forward&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RPC_Multiplexer_Forward& default_instance() {
    return *internal_default_instance();
  }
  static inline const RPC_Multiplexer_Forward* internal_default_instance() {
    return reinterpret_cast<const RPC_Multiplexer_Forward*>(
               &_RPC_Multiplexer_Forward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RPC_Multiplexer_Forward& a, RPC_Multiplexer_Forward& b) {
    a.Swap(&b);
  }
  inline void Swap(RPC_Multiplexer_Forward* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RPC_Multiplexer_Forward* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RPC_Multiplexer_Forward* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RPC_Multiplexer_Forward>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RPC_Multiplexer_Forward& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RPC_Multiplexer_Forward& from) {
    RPC_Multiplexer_Forward::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RPC_Multiplexer_Forward* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc_msg.RPC_Multiplexer_Forward";
  }
  protected:
  explicit RPC_Multiplexer_Forward(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyMsgFieldNumber = 3,
    kRoleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // bytes body_msg = 3;
  void clear_body_msg();
  const std::string& body_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body_msg();
  PROTOBUF_NODISCARD std::string* release_body_msg();
  void set_allocated_body_msg(std::string* body_msg);
  private:
  const std::string& _internal_body_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body_msg(const std::string& value);
  std::string* _internal_mutable_body_msg();
  public:

  // .rpc_msg.RoleIdentifier role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::rpc_msg::RoleIdentifier& role() const;
  PROTOBUF_NODISCARD ::rpc_msg::RoleIdentifier* release_role();
  ::rpc_msg::RoleIdentifier* mutable_role();
  void set_allocated_role(::rpc_msg::RoleIdentifier* role);
  private:
  const ::rpc_msg::RoleIdentifier& _internal_role() const;
  ::rpc_msg::RoleIdentifier* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::rpc_msg::RoleIdentifier* role);
  ::rpc_msg::RoleIdentifier* unsafe_arena_release_role();

  // .rpc_msg.ClientMessageInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::rpc_msg::ClientMessageInfo& info() const;
  PROTOBUF_NODISCARD ::rpc_msg::ClientMessageInfo* release_info();
  ::rpc_msg::ClientMessageInfo* mutable_info();
  void set_allocated_info(::rpc_msg::ClientMessageInfo* info);
  private:
  const ::rpc_msg::ClientMessageInfo& _internal_info() const;
  ::rpc_msg::ClientMessageInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::rpc_msg::ClientMessageInfo* info);
  ::rpc_msg::ClientMessageInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:rpc_msg.RPC_Multiplexer_Forward)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_msg_;
    ::rpc_msg::RoleIdentifier* role_;
    ::rpc_msg::ClientMessageInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class PRC_DeMultiplexer_Forward final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc_msg.PRC_DeMultiplexer_Forward) */ {
 public:
  inline PRC_DeMultiplexer_Forward() : PRC_DeMultiplexer_Forward(nullptr) {}
  ~PRC_DeMultiplexer_Forward() override;
  explicit PROTOBUF_CONSTEXPR PRC_DeMultiplexer_Forward(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PRC_DeMultiplexer_Forward(const PRC_DeMultiplexer_Forward& from);
  PRC_DeMultiplexer_Forward(PRC_DeMultiplexer_Forward&& from) noexcept
    : PRC_DeMultiplexer_Forward() {
    *this = ::std::move(from);
  }

  inline PRC_DeMultiplexer_Forward& operator=(const PRC_DeMultiplexer_Forward& from) {
    CopyFrom(from);
    return *this;
  }
  inline PRC_DeMultiplexer_Forward& operator=(PRC_DeMultiplexer_Forward&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PRC_DeMultiplexer_Forward& default_instance() {
    return *internal_default_instance();
  }
  static inline const PRC_DeMultiplexer_Forward* internal_default_instance() {
    return reinterpret_cast<const PRC_DeMultiplexer_Forward*>(
               &_PRC_DeMultiplexer_Forward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PRC_DeMultiplexer_Forward& a, PRC_DeMultiplexer_Forward& b) {
    a.Swap(&b);
  }
  inline void Swap(PRC_DeMultiplexer_Forward* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PRC_DeMultiplexer_Forward* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PRC_DeMultiplexer_Forward* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PRC_DeMultiplexer_Forward>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PRC_DeMultiplexer_Forward& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PRC_DeMultiplexer_Forward& from) {
    PRC_DeMultiplexer_Forward::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PRC_DeMultiplexer_Forward* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc_msg.PRC_DeMultiplexer_Forward";
  }
  protected:
  explicit PRC_DeMultiplexer_Forward(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyMsgFieldNumber = 3,
    kRoleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // bytes body_msg = 3;
  void clear_body_msg();
  const std::string& body_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body_msg();
  PROTOBUF_NODISCARD std::string* release_body_msg();
  void set_allocated_body_msg(std::string* body_msg);
  private:
  const std::string& _internal_body_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body_msg(const std::string& value);
  std::string* _internal_mutable_body_msg();
  public:

  // .rpc_msg.RoleIdentifier role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::rpc_msg::RoleIdentifier& role() const;
  PROTOBUF_NODISCARD ::rpc_msg::RoleIdentifier* release_role();
  ::rpc_msg::RoleIdentifier* mutable_role();
  void set_allocated_role(::rpc_msg::RoleIdentifier* role);
  private:
  const ::rpc_msg::RoleIdentifier& _internal_role() const;
  ::rpc_msg::RoleIdentifier* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::rpc_msg::RoleIdentifier* role);
  ::rpc_msg::RoleIdentifier* unsafe_arena_release_role();

  // .rpc_msg.ClientMessageInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::rpc_msg::ClientMessageInfo& info() const;
  PROTOBUF_NODISCARD ::rpc_msg::ClientMessageInfo* release_info();
  ::rpc_msg::ClientMessageInfo* mutable_info();
  void set_allocated_info(::rpc_msg::ClientMessageInfo* info);
  private:
  const ::rpc_msg::ClientMessageInfo& _internal_info() const;
  ::rpc_msg::ClientMessageInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::rpc_msg::ClientMessageInfo* info);
  ::rpc_msg::ClientMessageInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:rpc_msg.PRC_DeMultiplexer_Forward)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_msg_;
    ::rpc_msg::RoleIdentifier* role_;
    ::rpc_msg::ClientMessageInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CHANNEL

// uint32 realm = 1;
inline void CHANNEL::clear_realm() {
  _impl_.realm_ = 0u;
}
inline uint32_t CHANNEL::_internal_realm() const {
  return _impl_.realm_;
}
inline uint32_t CHANNEL::realm() const {
  // @@protoc_insertion_point(field_get:rpc_msg.CHANNEL.realm)
  return _internal_realm();
}
inline void CHANNEL::_internal_set_realm(uint32_t value) {
  
  _impl_.realm_ = value;
}
inline void CHANNEL::set_realm(uint32_t value) {
  _internal_set_realm(value);
  // @@protoc_insertion_point(field_set:rpc_msg.CHANNEL.realm)
}

// uint32 type = 2;
inline void CHANNEL::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CHANNEL::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CHANNEL::type() const {
  // @@protoc_insertion_point(field_get:rpc_msg.CHANNEL.type)
  return _internal_type();
}
inline void CHANNEL::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CHANNEL::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:rpc_msg.CHANNEL.type)
}

// uint32 id = 3;
inline void CHANNEL::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t CHANNEL::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t CHANNEL::id() const {
  // @@protoc_insertion_point(field_get:rpc_msg.CHANNEL.id)
  return _internal_id();
}
inline void CHANNEL::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void CHANNEL::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:rpc_msg.CHANNEL.id)
}

// string actor_id = 4;
inline void CHANNEL::clear_actor_id() {
  _impl_.actor_id_.ClearToEmpty();
}
inline const std::string& CHANNEL::actor_id() const {
  // @@protoc_insertion_point(field_get:rpc_msg.CHANNEL.actor_id)
  return _internal_actor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CHANNEL::set_actor_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.actor_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc_msg.CHANNEL.actor_id)
}
inline std::string* CHANNEL::mutable_actor_id() {
  std::string* _s = _internal_mutable_actor_id();
  // @@protoc_insertion_point(field_mutable:rpc_msg.CHANNEL.actor_id)
  return _s;
}
inline const std::string& CHANNEL::_internal_actor_id() const {
  return _impl_.actor_id_.Get();
}
inline void CHANNEL::_internal_set_actor_id(const std::string& value) {
  
  _impl_.actor_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CHANNEL::_internal_mutable_actor_id() {
  
  return _impl_.actor_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CHANNEL::release_actor_id() {
  // @@protoc_insertion_point(field_release:rpc_msg.CHANNEL.actor_id)
  return _impl_.actor_id_.Release();
}
inline void CHANNEL::set_allocated_actor_id(std::string* actor_id) {
  if (actor_id != nullptr) {
    
  } else {
    
  }
  _impl_.actor_id_.SetAllocated(actor_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.actor_id_.IsDefault()) {
    _impl_.actor_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.CHANNEL.actor_id)
}

// -------------------------------------------------------------------

// CONTROLLER

// uint64 seq_id = 1;
inline void CONTROLLER::clear_seq_id() {
  _impl_.seq_id_ = uint64_t{0u};
}
inline uint64_t CONTROLLER::_internal_seq_id() const {
  return _impl_.seq_id_;
}
inline uint64_t CONTROLLER::seq_id() const {
  // @@protoc_insertion_point(field_get:rpc_msg.CONTROLLER.seq_id)
  return _internal_seq_id();
}
inline void CONTROLLER::_internal_set_seq_id(uint64_t value) {
  
  _impl_.seq_id_ = value;
}
inline void CONTROLLER::set_seq_id(uint64_t value) {
  _internal_set_seq_id(value);
  // @@protoc_insertion_point(field_set:rpc_msg.CONTROLLER.seq_id)
}

// uint64 timeout_ms = 2;
inline void CONTROLLER::clear_timeout_ms() {
  _impl_.timeout_ms_ = uint64_t{0u};
}
inline uint64_t CONTROLLER::_internal_timeout_ms() const {
  return _impl_.timeout_ms_;
}
inline uint64_t CONTROLLER::timeout_ms() const {
  // @@protoc_insertion_point(field_get:rpc_msg.CONTROLLER.timeout_ms)
  return _internal_timeout_ms();
}
inline void CONTROLLER::_internal_set_timeout_ms(uint64_t value) {
  
  _impl_.timeout_ms_ = value;
}
inline void CONTROLLER::set_timeout_ms(uint64_t value) {
  _internal_set_timeout_ms(value);
  // @@protoc_insertion_point(field_set:rpc_msg.CONTROLLER.timeout_ms)
}

// bool server_stream = 3;
inline void CONTROLLER::clear_server_stream() {
  _impl_.server_stream_ = false;
}
inline bool CONTROLLER::_internal_server_stream() const {
  return _impl_.server_stream_;
}
inline bool CONTROLLER::server_stream() const {
  // @@protoc_insertion_point(field_get:rpc_msg.CONTROLLER.server_stream)
  return _internal_server_stream();
}
inline void CONTROLLER::_internal_set_server_stream(bool value) {
  
  _impl_.server_stream_ = value;
}
inline void CONTROLLER::set_server_stream(bool value) {
  _internal_set_server_stream(value);
  // @@protoc_insertion_point(field_set:rpc_msg.CONTROLLER.server_stream)
}

// -------------------------------------------------------------------

// ClientMessageInfo

// uint64 session_id = 1;
inline void ClientMessageInfo::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t ClientMessageInfo::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t ClientMessageInfo::session_id() const {
  // @@protoc_insertion_point(field_get:rpc_msg.ClientMessageInfo.session_id)
  return _internal_session_id();
}
inline void ClientMessageInfo::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void ClientMessageInfo::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:rpc_msg.ClientMessageInfo.session_id)
}

// uint32 seq_num = 2;
inline void ClientMessageInfo::clear_seq_num() {
  _impl_.seq_num_ = 0u;
}
inline uint32_t ClientMessageInfo::_internal_seq_num() const {
  return _impl_.seq_num_;
}
inline uint32_t ClientMessageInfo::seq_num() const {
  // @@protoc_insertion_point(field_get:rpc_msg.ClientMessageInfo.seq_num)
  return _internal_seq_num();
}
inline void ClientMessageInfo::_internal_set_seq_num(uint32_t value) {
  
  _impl_.seq_num_ = value;
}
inline void ClientMessageInfo::set_seq_num(uint32_t value) {
  _internal_set_seq_num(value);
  // @@protoc_insertion_point(field_set:rpc_msg.ClientMessageInfo.seq_num)
}

// uint32 opcode = 3;
inline void ClientMessageInfo::clear_opcode() {
  _impl_.opcode_ = 0u;
}
inline uint32_t ClientMessageInfo::_internal_opcode() const {
  return _impl_.opcode_;
}
inline uint32_t ClientMessageInfo::opcode() const {
  // @@protoc_insertion_point(field_get:rpc_msg.ClientMessageInfo.opcode)
  return _internal_opcode();
}
inline void ClientMessageInfo::_internal_set_opcode(uint32_t value) {
  
  _impl_.opcode_ = value;
}
inline void ClientMessageInfo::set_opcode(uint32_t value) {
  _internal_set_opcode(value);
  // @@protoc_insertion_point(field_set:rpc_msg.ClientMessageInfo.opcode)
}

// uint32 response_opcode = 4;
inline void ClientMessageInfo::clear_response_opcode() {
  _impl_.response_opcode_ = 0u;
}
inline uint32_t ClientMessageInfo::_internal_response_opcode() const {
  return _impl_.response_opcode_;
}
inline uint32_t ClientMessageInfo::response_opcode() const {
  // @@protoc_insertion_point(field_get:rpc_msg.ClientMessageInfo.response_opcode)
  return _internal_response_opcode();
}
inline void ClientMessageInfo::_internal_set_response_opcode(uint32_t value) {
  
  _impl_.response_opcode_ = value;
}
inline void ClientMessageInfo::set_response_opcode(uint32_t value) {
  _internal_set_response_opcode(value);
  // @@protoc_insertion_point(field_set:rpc_msg.ClientMessageInfo.response_opcode)
}

// uint32 connetion_type = 5;
inline void ClientMessageInfo::clear_connetion_type() {
  _impl_.connetion_type_ = 0u;
}
inline uint32_t ClientMessageInfo::_internal_connetion_type() const {
  return _impl_.connetion_type_;
}
inline uint32_t ClientMessageInfo::connetion_type() const {
  // @@protoc_insertion_point(field_get:rpc_msg.ClientMessageInfo.connetion_type)
  return _internal_connetion_type();
}
inline void ClientMessageInfo::_internal_set_connetion_type(uint32_t value) {
  
  _impl_.connetion_type_ = value;
}
inline void ClientMessageInfo::set_connetion_type(uint32_t value) {
  _internal_set_connetion_type(value);
  // @@protoc_insertion_point(field_set:rpc_msg.ClientMessageInfo.connetion_type)
}

// -------------------------------------------------------------------

// RoleIdentifier

// uint64 user_id = 1;
inline void RoleIdentifier::clear_user_id() {
  _impl_.user_id_ = uint64_t{0u};
}
inline uint64_t RoleIdentifier::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint64_t RoleIdentifier::user_id() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RoleIdentifier.user_id)
  return _internal_user_id();
}
inline void RoleIdentifier::_internal_set_user_id(uint64_t value) {
  
  _impl_.user_id_ = value;
}
inline void RoleIdentifier::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:rpc_msg.RoleIdentifier.user_id)
}

// .rpc_msg.CHANNEL gw_id = 2;
inline bool RoleIdentifier::_internal_has_gw_id() const {
  return this != internal_default_instance() && _impl_.gw_id_ != nullptr;
}
inline bool RoleIdentifier::has_gw_id() const {
  return _internal_has_gw_id();
}
inline void RoleIdentifier::clear_gw_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.gw_id_ != nullptr) {
    delete _impl_.gw_id_;
  }
  _impl_.gw_id_ = nullptr;
}
inline const ::rpc_msg::CHANNEL& RoleIdentifier::_internal_gw_id() const {
  const ::rpc_msg::CHANNEL* p = _impl_.gw_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::CHANNEL&>(
      ::rpc_msg::_CHANNEL_default_instance_);
}
inline const ::rpc_msg::CHANNEL& RoleIdentifier::gw_id() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RoleIdentifier.gw_id)
  return _internal_gw_id();
}
inline void RoleIdentifier::unsafe_arena_set_allocated_gw_id(
    ::rpc_msg::CHANNEL* gw_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gw_id_);
  }
  _impl_.gw_id_ = gw_id;
  if (gw_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.RoleIdentifier.gw_id)
}
inline ::rpc_msg::CHANNEL* RoleIdentifier::release_gw_id() {
  
  ::rpc_msg::CHANNEL* temp = _impl_.gw_id_;
  _impl_.gw_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::CHANNEL* RoleIdentifier::unsafe_arena_release_gw_id() {
  // @@protoc_insertion_point(field_release:rpc_msg.RoleIdentifier.gw_id)
  
  ::rpc_msg::CHANNEL* temp = _impl_.gw_id_;
  _impl_.gw_id_ = nullptr;
  return temp;
}
inline ::rpc_msg::CHANNEL* RoleIdentifier::_internal_mutable_gw_id() {
  
  if (_impl_.gw_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::CHANNEL>(GetArenaForAllocation());
    _impl_.gw_id_ = p;
  }
  return _impl_.gw_id_;
}
inline ::rpc_msg::CHANNEL* RoleIdentifier::mutable_gw_id() {
  ::rpc_msg::CHANNEL* _msg = _internal_mutable_gw_id();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RoleIdentifier.gw_id)
  return _msg;
}
inline void RoleIdentifier::set_allocated_gw_id(::rpc_msg::CHANNEL* gw_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gw_id_;
  }
  if (gw_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gw_id);
    if (message_arena != submessage_arena) {
      gw_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gw_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gw_id_ = gw_id;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RoleIdentifier.gw_id)
}

// .rpc_msg.ClientMessageInfo info = 3;
inline bool RoleIdentifier::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool RoleIdentifier::has_info() const {
  return _internal_has_info();
}
inline void RoleIdentifier::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::rpc_msg::ClientMessageInfo& RoleIdentifier::_internal_info() const {
  const ::rpc_msg::ClientMessageInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::ClientMessageInfo&>(
      ::rpc_msg::_ClientMessageInfo_default_instance_);
}
inline const ::rpc_msg::ClientMessageInfo& RoleIdentifier::info() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RoleIdentifier.info)
  return _internal_info();
}
inline void RoleIdentifier::unsafe_arena_set_allocated_info(
    ::rpc_msg::ClientMessageInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.RoleIdentifier.info)
}
inline ::rpc_msg::ClientMessageInfo* RoleIdentifier::release_info() {
  
  ::rpc_msg::ClientMessageInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::ClientMessageInfo* RoleIdentifier::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:rpc_msg.RoleIdentifier.info)
  
  ::rpc_msg::ClientMessageInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::rpc_msg::ClientMessageInfo* RoleIdentifier::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::ClientMessageInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::rpc_msg::ClientMessageInfo* RoleIdentifier::mutable_info() {
  ::rpc_msg::ClientMessageInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RoleIdentifier.info)
  return _msg;
}
inline void RoleIdentifier::set_allocated_info(::rpc_msg::ClientMessageInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RoleIdentifier.info)
}

// -------------------------------------------------------------------

// CLIENT_IDENTIFIER

// .rpc_msg.CHANNEL stub = 1;
inline bool CLIENT_IDENTIFIER::_internal_has_stub() const {
  return this != internal_default_instance() && _impl_.stub_ != nullptr;
}
inline bool CLIENT_IDENTIFIER::has_stub() const {
  return _internal_has_stub();
}
inline void CLIENT_IDENTIFIER::clear_stub() {
  if (GetArenaForAllocation() == nullptr && _impl_.stub_ != nullptr) {
    delete _impl_.stub_;
  }
  _impl_.stub_ = nullptr;
}
inline const ::rpc_msg::CHANNEL& CLIENT_IDENTIFIER::_internal_stub() const {
  const ::rpc_msg::CHANNEL* p = _impl_.stub_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::CHANNEL&>(
      ::rpc_msg::_CHANNEL_default_instance_);
}
inline const ::rpc_msg::CHANNEL& CLIENT_IDENTIFIER::stub() const {
  // @@protoc_insertion_point(field_get:rpc_msg.CLIENT_IDENTIFIER.stub)
  return _internal_stub();
}
inline void CLIENT_IDENTIFIER::unsafe_arena_set_allocated_stub(
    ::rpc_msg::CHANNEL* stub) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stub_);
  }
  _impl_.stub_ = stub;
  if (stub) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.CLIENT_IDENTIFIER.stub)
}
inline ::rpc_msg::CHANNEL* CLIENT_IDENTIFIER::release_stub() {
  
  ::rpc_msg::CHANNEL* temp = _impl_.stub_;
  _impl_.stub_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::CHANNEL* CLIENT_IDENTIFIER::unsafe_arena_release_stub() {
  // @@protoc_insertion_point(field_release:rpc_msg.CLIENT_IDENTIFIER.stub)
  
  ::rpc_msg::CHANNEL* temp = _impl_.stub_;
  _impl_.stub_ = nullptr;
  return temp;
}
inline ::rpc_msg::CHANNEL* CLIENT_IDENTIFIER::_internal_mutable_stub() {
  
  if (_impl_.stub_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::CHANNEL>(GetArenaForAllocation());
    _impl_.stub_ = p;
  }
  return _impl_.stub_;
}
inline ::rpc_msg::CHANNEL* CLIENT_IDENTIFIER::mutable_stub() {
  ::rpc_msg::CHANNEL* _msg = _internal_mutable_stub();
  // @@protoc_insertion_point(field_mutable:rpc_msg.CLIENT_IDENTIFIER.stub)
  return _msg;
}
inline void CLIENT_IDENTIFIER::set_allocated_stub(::rpc_msg::CHANNEL* stub) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stub_;
  }
  if (stub) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stub);
    if (message_arena != submessage_arena) {
      stub = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stub, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stub_ = stub;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.CLIENT_IDENTIFIER.stub)
}

// uint64 seq_id = 2;
inline void CLIENT_IDENTIFIER::clear_seq_id() {
  _impl_.seq_id_ = uint64_t{0u};
}
inline uint64_t CLIENT_IDENTIFIER::_internal_seq_id() const {
  return _impl_.seq_id_;
}
inline uint64_t CLIENT_IDENTIFIER::seq_id() const {
  // @@protoc_insertion_point(field_get:rpc_msg.CLIENT_IDENTIFIER.seq_id)
  return _internal_seq_id();
}
inline void CLIENT_IDENTIFIER::_internal_set_seq_id(uint64_t value) {
  
  _impl_.seq_id_ = value;
}
inline void CLIENT_IDENTIFIER::set_seq_id(uint64_t value) {
  _internal_set_seq_id(value);
  // @@protoc_insertion_point(field_set:rpc_msg.CLIENT_IDENTIFIER.seq_id)
}

// bool required_reply = 3;
inline void CLIENT_IDENTIFIER::clear_required_reply() {
  _impl_.required_reply_ = false;
}
inline bool CLIENT_IDENTIFIER::_internal_required_reply() const {
  return _impl_.required_reply_;
}
inline bool CLIENT_IDENTIFIER::required_reply() const {
  // @@protoc_insertion_point(field_get:rpc_msg.CLIENT_IDENTIFIER.required_reply)
  return _internal_required_reply();
}
inline void CLIENT_IDENTIFIER::_internal_set_required_reply(bool value) {
  
  _impl_.required_reply_ = value;
}
inline void CLIENT_IDENTIFIER::set_required_reply(bool value) {
  _internal_set_required_reply(value);
  // @@protoc_insertion_point(field_set:rpc_msg.CLIENT_IDENTIFIER.required_reply)
}

// string reply_topic = 4;
inline void CLIENT_IDENTIFIER::clear_reply_topic() {
  _impl_.reply_topic_.ClearToEmpty();
}
inline const std::string& CLIENT_IDENTIFIER::reply_topic() const {
  // @@protoc_insertion_point(field_get:rpc_msg.CLIENT_IDENTIFIER.reply_topic)
  return _internal_reply_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CLIENT_IDENTIFIER::set_reply_topic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc_msg.CLIENT_IDENTIFIER.reply_topic)
}
inline std::string* CLIENT_IDENTIFIER::mutable_reply_topic() {
  std::string* _s = _internal_mutable_reply_topic();
  // @@protoc_insertion_point(field_mutable:rpc_msg.CLIENT_IDENTIFIER.reply_topic)
  return _s;
}
inline const std::string& CLIENT_IDENTIFIER::_internal_reply_topic() const {
  return _impl_.reply_topic_.Get();
}
inline void CLIENT_IDENTIFIER::_internal_set_reply_topic(const std::string& value) {
  
  _impl_.reply_topic_.Set(value, GetArenaForAllocation());
}
inline std::string* CLIENT_IDENTIFIER::_internal_mutable_reply_topic() {
  
  return _impl_.reply_topic_.Mutable(GetArenaForAllocation());
}
inline std::string* CLIENT_IDENTIFIER::release_reply_topic() {
  // @@protoc_insertion_point(field_release:rpc_msg.CLIENT_IDENTIFIER.reply_topic)
  return _impl_.reply_topic_.Release();
}
inline void CLIENT_IDENTIFIER::set_allocated_reply_topic(std::string* reply_topic) {
  if (reply_topic != nullptr) {
    
  } else {
    
  }
  _impl_.reply_topic_.SetAllocated(reply_topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_topic_.IsDefault()) {
    _impl_.reply_topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.CLIENT_IDENTIFIER.reply_topic)
}

// -------------------------------------------------------------------

// SERVER_IDENTIFIER

// .rpc_msg.CHANNEL stub = 1;
inline bool SERVER_IDENTIFIER::_internal_has_stub() const {
  return this != internal_default_instance() && _impl_.stub_ != nullptr;
}
inline bool SERVER_IDENTIFIER::has_stub() const {
  return _internal_has_stub();
}
inline void SERVER_IDENTIFIER::clear_stub() {
  if (GetArenaForAllocation() == nullptr && _impl_.stub_ != nullptr) {
    delete _impl_.stub_;
  }
  _impl_.stub_ = nullptr;
}
inline const ::rpc_msg::CHANNEL& SERVER_IDENTIFIER::_internal_stub() const {
  const ::rpc_msg::CHANNEL* p = _impl_.stub_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::CHANNEL&>(
      ::rpc_msg::_CHANNEL_default_instance_);
}
inline const ::rpc_msg::CHANNEL& SERVER_IDENTIFIER::stub() const {
  // @@protoc_insertion_point(field_get:rpc_msg.SERVER_IDENTIFIER.stub)
  return _internal_stub();
}
inline void SERVER_IDENTIFIER::unsafe_arena_set_allocated_stub(
    ::rpc_msg::CHANNEL* stub) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stub_);
  }
  _impl_.stub_ = stub;
  if (stub) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.SERVER_IDENTIFIER.stub)
}
inline ::rpc_msg::CHANNEL* SERVER_IDENTIFIER::release_stub() {
  
  ::rpc_msg::CHANNEL* temp = _impl_.stub_;
  _impl_.stub_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::CHANNEL* SERVER_IDENTIFIER::unsafe_arena_release_stub() {
  // @@protoc_insertion_point(field_release:rpc_msg.SERVER_IDENTIFIER.stub)
  
  ::rpc_msg::CHANNEL* temp = _impl_.stub_;
  _impl_.stub_ = nullptr;
  return temp;
}
inline ::rpc_msg::CHANNEL* SERVER_IDENTIFIER::_internal_mutable_stub() {
  
  if (_impl_.stub_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::CHANNEL>(GetArenaForAllocation());
    _impl_.stub_ = p;
  }
  return _impl_.stub_;
}
inline ::rpc_msg::CHANNEL* SERVER_IDENTIFIER::mutable_stub() {
  ::rpc_msg::CHANNEL* _msg = _internal_mutable_stub();
  // @@protoc_insertion_point(field_mutable:rpc_msg.SERVER_IDENTIFIER.stub)
  return _msg;
}
inline void SERVER_IDENTIFIER::set_allocated_stub(::rpc_msg::CHANNEL* stub) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stub_;
  }
  if (stub) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stub);
    if (message_arena != submessage_arena) {
      stub = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stub, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stub_ = stub;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.SERVER_IDENTIFIER.stub)
}

// -------------------------------------------------------------------

// RPC_REQUEST

// .rpc_msg.CLIENT_IDENTIFIER client = 1;
inline bool RPC_REQUEST::_internal_has_client() const {
  return this != internal_default_instance() && _impl_.client_ != nullptr;
}
inline bool RPC_REQUEST::has_client() const {
  return _internal_has_client();
}
inline void RPC_REQUEST::clear_client() {
  if (GetArenaForAllocation() == nullptr && _impl_.client_ != nullptr) {
    delete _impl_.client_;
  }
  _impl_.client_ = nullptr;
}
inline const ::rpc_msg::CLIENT_IDENTIFIER& RPC_REQUEST::_internal_client() const {
  const ::rpc_msg::CLIENT_IDENTIFIER* p = _impl_.client_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::CLIENT_IDENTIFIER&>(
      ::rpc_msg::_CLIENT_IDENTIFIER_default_instance_);
}
inline const ::rpc_msg::CLIENT_IDENTIFIER& RPC_REQUEST::client() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_REQUEST.client)
  return _internal_client();
}
inline void RPC_REQUEST::unsafe_arena_set_allocated_client(
    ::rpc_msg::CLIENT_IDENTIFIER* client) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_);
  }
  _impl_.client_ = client;
  if (client) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.RPC_REQUEST.client)
}
inline ::rpc_msg::CLIENT_IDENTIFIER* RPC_REQUEST::release_client() {
  
  ::rpc_msg::CLIENT_IDENTIFIER* temp = _impl_.client_;
  _impl_.client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::CLIENT_IDENTIFIER* RPC_REQUEST::unsafe_arena_release_client() {
  // @@protoc_insertion_point(field_release:rpc_msg.RPC_REQUEST.client)
  
  ::rpc_msg::CLIENT_IDENTIFIER* temp = _impl_.client_;
  _impl_.client_ = nullptr;
  return temp;
}
inline ::rpc_msg::CLIENT_IDENTIFIER* RPC_REQUEST::_internal_mutable_client() {
  
  if (_impl_.client_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::CLIENT_IDENTIFIER>(GetArenaForAllocation());
    _impl_.client_ = p;
  }
  return _impl_.client_;
}
inline ::rpc_msg::CLIENT_IDENTIFIER* RPC_REQUEST::mutable_client() {
  ::rpc_msg::CLIENT_IDENTIFIER* _msg = _internal_mutable_client();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RPC_REQUEST.client)
  return _msg;
}
inline void RPC_REQUEST::set_allocated_client(::rpc_msg::CLIENT_IDENTIFIER* client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.client_;
  }
  if (client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client);
    if (message_arena != submessage_arena) {
      client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.client_ = client;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RPC_REQUEST.client)
}

// .rpc_msg.SERVER_IDENTIFIER server = 2;
inline bool RPC_REQUEST::_internal_has_server() const {
  return this != internal_default_instance() && _impl_.server_ != nullptr;
}
inline bool RPC_REQUEST::has_server() const {
  return _internal_has_server();
}
inline void RPC_REQUEST::clear_server() {
  if (GetArenaForAllocation() == nullptr && _impl_.server_ != nullptr) {
    delete _impl_.server_;
  }
  _impl_.server_ = nullptr;
}
inline const ::rpc_msg::SERVER_IDENTIFIER& RPC_REQUEST::_internal_server() const {
  const ::rpc_msg::SERVER_IDENTIFIER* p = _impl_.server_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::SERVER_IDENTIFIER&>(
      ::rpc_msg::_SERVER_IDENTIFIER_default_instance_);
}
inline const ::rpc_msg::SERVER_IDENTIFIER& RPC_REQUEST::server() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_REQUEST.server)
  return _internal_server();
}
inline void RPC_REQUEST::unsafe_arena_set_allocated_server(
    ::rpc_msg::SERVER_IDENTIFIER* server) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_);
  }
  _impl_.server_ = server;
  if (server) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.RPC_REQUEST.server)
}
inline ::rpc_msg::SERVER_IDENTIFIER* RPC_REQUEST::release_server() {
  
  ::rpc_msg::SERVER_IDENTIFIER* temp = _impl_.server_;
  _impl_.server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::SERVER_IDENTIFIER* RPC_REQUEST::unsafe_arena_release_server() {
  // @@protoc_insertion_point(field_release:rpc_msg.RPC_REQUEST.server)
  
  ::rpc_msg::SERVER_IDENTIFIER* temp = _impl_.server_;
  _impl_.server_ = nullptr;
  return temp;
}
inline ::rpc_msg::SERVER_IDENTIFIER* RPC_REQUEST::_internal_mutable_server() {
  
  if (_impl_.server_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::SERVER_IDENTIFIER>(GetArenaForAllocation());
    _impl_.server_ = p;
  }
  return _impl_.server_;
}
inline ::rpc_msg::SERVER_IDENTIFIER* RPC_REQUEST::mutable_server() {
  ::rpc_msg::SERVER_IDENTIFIER* _msg = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RPC_REQUEST.server)
  return _msg;
}
inline void RPC_REQUEST::set_allocated_server(::rpc_msg::SERVER_IDENTIFIER* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.server_;
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server);
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_ = server;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RPC_REQUEST.server)
}

// bool server_stream = 3;
inline void RPC_REQUEST::clear_server_stream() {
  _impl_.server_stream_ = false;
}
inline bool RPC_REQUEST::_internal_server_stream() const {
  return _impl_.server_stream_;
}
inline bool RPC_REQUEST::server_stream() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_REQUEST.server_stream)
  return _internal_server_stream();
}
inline void RPC_REQUEST::_internal_set_server_stream(bool value) {
  
  _impl_.server_stream_ = value;
}
inline void RPC_REQUEST::set_server_stream(bool value) {
  _internal_set_server_stream(value);
  // @@protoc_insertion_point(field_set:rpc_msg.RPC_REQUEST.server_stream)
}

// uint32 opcodes = 4;
inline void RPC_REQUEST::clear_opcodes() {
  _impl_.opcodes_ = 0u;
}
inline uint32_t RPC_REQUEST::_internal_opcodes() const {
  return _impl_.opcodes_;
}
inline uint32_t RPC_REQUEST::opcodes() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_REQUEST.opcodes)
  return _internal_opcodes();
}
inline void RPC_REQUEST::_internal_set_opcodes(uint32_t value) {
  
  _impl_.opcodes_ = value;
}
inline void RPC_REQUEST::set_opcodes(uint32_t value) {
  _internal_set_opcodes(value);
  // @@protoc_insertion_point(field_set:rpc_msg.RPC_REQUEST.opcodes)
}

// bytes args_data = 5;
inline void RPC_REQUEST::clear_args_data() {
  _impl_.args_data_.ClearToEmpty();
}
inline const std::string& RPC_REQUEST::args_data() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_REQUEST.args_data)
  return _internal_args_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RPC_REQUEST::set_args_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.args_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc_msg.RPC_REQUEST.args_data)
}
inline std::string* RPC_REQUEST::mutable_args_data() {
  std::string* _s = _internal_mutable_args_data();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RPC_REQUEST.args_data)
  return _s;
}
inline const std::string& RPC_REQUEST::_internal_args_data() const {
  return _impl_.args_data_.Get();
}
inline void RPC_REQUEST::_internal_set_args_data(const std::string& value) {
  
  _impl_.args_data_.Set(value, GetArenaForAllocation());
}
inline std::string* RPC_REQUEST::_internal_mutable_args_data() {
  
  return _impl_.args_data_.Mutable(GetArenaForAllocation());
}
inline std::string* RPC_REQUEST::release_args_data() {
  // @@protoc_insertion_point(field_release:rpc_msg.RPC_REQUEST.args_data)
  return _impl_.args_data_.Release();
}
inline void RPC_REQUEST::set_allocated_args_data(std::string* args_data) {
  if (args_data != nullptr) {
    
  } else {
    
  }
  _impl_.args_data_.SetAllocated(args_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.args_data_.IsDefault()) {
    _impl_.args_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RPC_REQUEST.args_data)
}

// -------------------------------------------------------------------

// STATUS

// uint32 code = 1;
inline void STATUS::clear_code() {
  _impl_.code_ = 0u;
}
inline uint32_t STATUS::_internal_code() const {
  return _impl_.code_;
}
inline uint32_t STATUS::code() const {
  // @@protoc_insertion_point(field_get:rpc_msg.STATUS.code)
  return _internal_code();
}
inline void STATUS::_internal_set_code(uint32_t value) {
  
  _impl_.code_ = value;
}
inline void STATUS::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:rpc_msg.STATUS.code)
}

// string msg = 2;
inline void STATUS::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& STATUS::msg() const {
  // @@protoc_insertion_point(field_get:rpc_msg.STATUS.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void STATUS::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc_msg.STATUS.msg)
}
inline std::string* STATUS::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:rpc_msg.STATUS.msg)
  return _s;
}
inline const std::string& STATUS::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void STATUS::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* STATUS::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* STATUS::release_msg() {
  // @@protoc_insertion_point(field_release:rpc_msg.STATUS.msg)
  return _impl_.msg_.Release();
}
inline void STATUS::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.STATUS.msg)
}

// -------------------------------------------------------------------

// RPC_RESPONSE

// .rpc_msg.CLIENT_IDENTIFIER client = 1;
inline bool RPC_RESPONSE::_internal_has_client() const {
  return this != internal_default_instance() && _impl_.client_ != nullptr;
}
inline bool RPC_RESPONSE::has_client() const {
  return _internal_has_client();
}
inline void RPC_RESPONSE::clear_client() {
  if (GetArenaForAllocation() == nullptr && _impl_.client_ != nullptr) {
    delete _impl_.client_;
  }
  _impl_.client_ = nullptr;
}
inline const ::rpc_msg::CLIENT_IDENTIFIER& RPC_RESPONSE::_internal_client() const {
  const ::rpc_msg::CLIENT_IDENTIFIER* p = _impl_.client_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::CLIENT_IDENTIFIER&>(
      ::rpc_msg::_CLIENT_IDENTIFIER_default_instance_);
}
inline const ::rpc_msg::CLIENT_IDENTIFIER& RPC_RESPONSE::client() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_RESPONSE.client)
  return _internal_client();
}
inline void RPC_RESPONSE::unsafe_arena_set_allocated_client(
    ::rpc_msg::CLIENT_IDENTIFIER* client) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_);
  }
  _impl_.client_ = client;
  if (client) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.RPC_RESPONSE.client)
}
inline ::rpc_msg::CLIENT_IDENTIFIER* RPC_RESPONSE::release_client() {
  
  ::rpc_msg::CLIENT_IDENTIFIER* temp = _impl_.client_;
  _impl_.client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::CLIENT_IDENTIFIER* RPC_RESPONSE::unsafe_arena_release_client() {
  // @@protoc_insertion_point(field_release:rpc_msg.RPC_RESPONSE.client)
  
  ::rpc_msg::CLIENT_IDENTIFIER* temp = _impl_.client_;
  _impl_.client_ = nullptr;
  return temp;
}
inline ::rpc_msg::CLIENT_IDENTIFIER* RPC_RESPONSE::_internal_mutable_client() {
  
  if (_impl_.client_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::CLIENT_IDENTIFIER>(GetArenaForAllocation());
    _impl_.client_ = p;
  }
  return _impl_.client_;
}
inline ::rpc_msg::CLIENT_IDENTIFIER* RPC_RESPONSE::mutable_client() {
  ::rpc_msg::CLIENT_IDENTIFIER* _msg = _internal_mutable_client();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RPC_RESPONSE.client)
  return _msg;
}
inline void RPC_RESPONSE::set_allocated_client(::rpc_msg::CLIENT_IDENTIFIER* client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.client_;
  }
  if (client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client);
    if (message_arena != submessage_arena) {
      client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.client_ = client;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RPC_RESPONSE.client)
}

// .rpc_msg.SERVER_IDENTIFIER server = 2;
inline bool RPC_RESPONSE::_internal_has_server() const {
  return this != internal_default_instance() && _impl_.server_ != nullptr;
}
inline bool RPC_RESPONSE::has_server() const {
  return _internal_has_server();
}
inline void RPC_RESPONSE::clear_server() {
  if (GetArenaForAllocation() == nullptr && _impl_.server_ != nullptr) {
    delete _impl_.server_;
  }
  _impl_.server_ = nullptr;
}
inline const ::rpc_msg::SERVER_IDENTIFIER& RPC_RESPONSE::_internal_server() const {
  const ::rpc_msg::SERVER_IDENTIFIER* p = _impl_.server_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::SERVER_IDENTIFIER&>(
      ::rpc_msg::_SERVER_IDENTIFIER_default_instance_);
}
inline const ::rpc_msg::SERVER_IDENTIFIER& RPC_RESPONSE::server() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_RESPONSE.server)
  return _internal_server();
}
inline void RPC_RESPONSE::unsafe_arena_set_allocated_server(
    ::rpc_msg::SERVER_IDENTIFIER* server) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_);
  }
  _impl_.server_ = server;
  if (server) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.RPC_RESPONSE.server)
}
inline ::rpc_msg::SERVER_IDENTIFIER* RPC_RESPONSE::release_server() {
  
  ::rpc_msg::SERVER_IDENTIFIER* temp = _impl_.server_;
  _impl_.server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::SERVER_IDENTIFIER* RPC_RESPONSE::unsafe_arena_release_server() {
  // @@protoc_insertion_point(field_release:rpc_msg.RPC_RESPONSE.server)
  
  ::rpc_msg::SERVER_IDENTIFIER* temp = _impl_.server_;
  _impl_.server_ = nullptr;
  return temp;
}
inline ::rpc_msg::SERVER_IDENTIFIER* RPC_RESPONSE::_internal_mutable_server() {
  
  if (_impl_.server_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::SERVER_IDENTIFIER>(GetArenaForAllocation());
    _impl_.server_ = p;
  }
  return _impl_.server_;
}
inline ::rpc_msg::SERVER_IDENTIFIER* RPC_RESPONSE::mutable_server() {
  ::rpc_msg::SERVER_IDENTIFIER* _msg = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RPC_RESPONSE.server)
  return _msg;
}
inline void RPC_RESPONSE::set_allocated_server(::rpc_msg::SERVER_IDENTIFIER* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.server_;
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server);
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_ = server;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RPC_RESPONSE.server)
}

// .rpc_msg.STATUS status = 3;
inline bool RPC_RESPONSE::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool RPC_RESPONSE::has_status() const {
  return _internal_has_status();
}
inline void RPC_RESPONSE::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::rpc_msg::STATUS& RPC_RESPONSE::_internal_status() const {
  const ::rpc_msg::STATUS* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::STATUS&>(
      ::rpc_msg::_STATUS_default_instance_);
}
inline const ::rpc_msg::STATUS& RPC_RESPONSE::status() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_RESPONSE.status)
  return _internal_status();
}
inline void RPC_RESPONSE::unsafe_arena_set_allocated_status(
    ::rpc_msg::STATUS* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.RPC_RESPONSE.status)
}
inline ::rpc_msg::STATUS* RPC_RESPONSE::release_status() {
  
  ::rpc_msg::STATUS* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::STATUS* RPC_RESPONSE::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:rpc_msg.RPC_RESPONSE.status)
  
  ::rpc_msg::STATUS* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::rpc_msg::STATUS* RPC_RESPONSE::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::STATUS>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::rpc_msg::STATUS* RPC_RESPONSE::mutable_status() {
  ::rpc_msg::STATUS* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RPC_RESPONSE.status)
  return _msg;
}
inline void RPC_RESPONSE::set_allocated_status(::rpc_msg::STATUS* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RPC_RESPONSE.status)
}

// bool has_more = 4;
inline void RPC_RESPONSE::clear_has_more() {
  _impl_.has_more_ = false;
}
inline bool RPC_RESPONSE::_internal_has_more() const {
  return _impl_.has_more_;
}
inline bool RPC_RESPONSE::has_more() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_RESPONSE.has_more)
  return _internal_has_more();
}
inline void RPC_RESPONSE::_internal_set_has_more(bool value) {
  
  _impl_.has_more_ = value;
}
inline void RPC_RESPONSE::set_has_more(bool value) {
  _internal_set_has_more(value);
  // @@protoc_insertion_point(field_set:rpc_msg.RPC_RESPONSE.has_more)
}

// uint32 offset = 5;
inline void RPC_RESPONSE::clear_offset() {
  _impl_.offset_ = 0u;
}
inline uint32_t RPC_RESPONSE::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t RPC_RESPONSE::offset() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_RESPONSE.offset)
  return _internal_offset();
}
inline void RPC_RESPONSE::_internal_set_offset(uint32_t value) {
  
  _impl_.offset_ = value;
}
inline void RPC_RESPONSE::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:rpc_msg.RPC_RESPONSE.offset)
}

// bytes result_data = 6;
inline void RPC_RESPONSE::clear_result_data() {
  _impl_.result_data_.ClearToEmpty();
}
inline const std::string& RPC_RESPONSE::result_data() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_RESPONSE.result_data)
  return _internal_result_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RPC_RESPONSE::set_result_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc_msg.RPC_RESPONSE.result_data)
}
inline std::string* RPC_RESPONSE::mutable_result_data() {
  std::string* _s = _internal_mutable_result_data();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RPC_RESPONSE.result_data)
  return _s;
}
inline const std::string& RPC_RESPONSE::_internal_result_data() const {
  return _impl_.result_data_.Get();
}
inline void RPC_RESPONSE::_internal_set_result_data(const std::string& value) {
  
  _impl_.result_data_.Set(value, GetArenaForAllocation());
}
inline std::string* RPC_RESPONSE::_internal_mutable_result_data() {
  
  return _impl_.result_data_.Mutable(GetArenaForAllocation());
}
inline std::string* RPC_RESPONSE::release_result_data() {
  // @@protoc_insertion_point(field_release:rpc_msg.RPC_RESPONSE.result_data)
  return _impl_.result_data_.Release();
}
inline void RPC_RESPONSE::set_allocated_result_data(std::string* result_data) {
  if (result_data != nullptr) {
    
  } else {
    
  }
  _impl_.result_data_.SetAllocated(result_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_data_.IsDefault()) {
    _impl_.result_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RPC_RESPONSE.result_data)
}

// -------------------------------------------------------------------

// RPC_Multiplexer_Forward

// .rpc_msg.RoleIdentifier role = 1;
inline bool RPC_Multiplexer_Forward::_internal_has_role() const {
  return this != internal_default_instance() && _impl_.role_ != nullptr;
}
inline bool RPC_Multiplexer_Forward::has_role() const {
  return _internal_has_role();
}
inline void RPC_Multiplexer_Forward::clear_role() {
  if (GetArenaForAllocation() == nullptr && _impl_.role_ != nullptr) {
    delete _impl_.role_;
  }
  _impl_.role_ = nullptr;
}
inline const ::rpc_msg::RoleIdentifier& RPC_Multiplexer_Forward::_internal_role() const {
  const ::rpc_msg::RoleIdentifier* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::RoleIdentifier&>(
      ::rpc_msg::_RoleIdentifier_default_instance_);
}
inline const ::rpc_msg::RoleIdentifier& RPC_Multiplexer_Forward::role() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_Multiplexer_Forward.role)
  return _internal_role();
}
inline void RPC_Multiplexer_Forward::unsafe_arena_set_allocated_role(
    ::rpc_msg::RoleIdentifier* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.RPC_Multiplexer_Forward.role)
}
inline ::rpc_msg::RoleIdentifier* RPC_Multiplexer_Forward::release_role() {
  
  ::rpc_msg::RoleIdentifier* temp = _impl_.role_;
  _impl_.role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::RoleIdentifier* RPC_Multiplexer_Forward::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:rpc_msg.RPC_Multiplexer_Forward.role)
  
  ::rpc_msg::RoleIdentifier* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::rpc_msg::RoleIdentifier* RPC_Multiplexer_Forward::_internal_mutable_role() {
  
  if (_impl_.role_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::RoleIdentifier>(GetArenaForAllocation());
    _impl_.role_ = p;
  }
  return _impl_.role_;
}
inline ::rpc_msg::RoleIdentifier* RPC_Multiplexer_Forward::mutable_role() {
  ::rpc_msg::RoleIdentifier* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RPC_Multiplexer_Forward.role)
  return _msg;
}
inline void RPC_Multiplexer_Forward::set_allocated_role(::rpc_msg::RoleIdentifier* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.role_ = role;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RPC_Multiplexer_Forward.role)
}

// .rpc_msg.ClientMessageInfo info = 2;
inline bool RPC_Multiplexer_Forward::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool RPC_Multiplexer_Forward::has_info() const {
  return _internal_has_info();
}
inline void RPC_Multiplexer_Forward::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::rpc_msg::ClientMessageInfo& RPC_Multiplexer_Forward::_internal_info() const {
  const ::rpc_msg::ClientMessageInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::ClientMessageInfo&>(
      ::rpc_msg::_ClientMessageInfo_default_instance_);
}
inline const ::rpc_msg::ClientMessageInfo& RPC_Multiplexer_Forward::info() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_Multiplexer_Forward.info)
  return _internal_info();
}
inline void RPC_Multiplexer_Forward::unsafe_arena_set_allocated_info(
    ::rpc_msg::ClientMessageInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.RPC_Multiplexer_Forward.info)
}
inline ::rpc_msg::ClientMessageInfo* RPC_Multiplexer_Forward::release_info() {
  
  ::rpc_msg::ClientMessageInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::ClientMessageInfo* RPC_Multiplexer_Forward::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:rpc_msg.RPC_Multiplexer_Forward.info)
  
  ::rpc_msg::ClientMessageInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::rpc_msg::ClientMessageInfo* RPC_Multiplexer_Forward::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::ClientMessageInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::rpc_msg::ClientMessageInfo* RPC_Multiplexer_Forward::mutable_info() {
  ::rpc_msg::ClientMessageInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RPC_Multiplexer_Forward.info)
  return _msg;
}
inline void RPC_Multiplexer_Forward::set_allocated_info(::rpc_msg::ClientMessageInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RPC_Multiplexer_Forward.info)
}

// bytes body_msg = 3;
inline void RPC_Multiplexer_Forward::clear_body_msg() {
  _impl_.body_msg_.ClearToEmpty();
}
inline const std::string& RPC_Multiplexer_Forward::body_msg() const {
  // @@protoc_insertion_point(field_get:rpc_msg.RPC_Multiplexer_Forward.body_msg)
  return _internal_body_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RPC_Multiplexer_Forward::set_body_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_msg_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc_msg.RPC_Multiplexer_Forward.body_msg)
}
inline std::string* RPC_Multiplexer_Forward::mutable_body_msg() {
  std::string* _s = _internal_mutable_body_msg();
  // @@protoc_insertion_point(field_mutable:rpc_msg.RPC_Multiplexer_Forward.body_msg)
  return _s;
}
inline const std::string& RPC_Multiplexer_Forward::_internal_body_msg() const {
  return _impl_.body_msg_.Get();
}
inline void RPC_Multiplexer_Forward::_internal_set_body_msg(const std::string& value) {
  
  _impl_.body_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* RPC_Multiplexer_Forward::_internal_mutable_body_msg() {
  
  return _impl_.body_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* RPC_Multiplexer_Forward::release_body_msg() {
  // @@protoc_insertion_point(field_release:rpc_msg.RPC_Multiplexer_Forward.body_msg)
  return _impl_.body_msg_.Release();
}
inline void RPC_Multiplexer_Forward::set_allocated_body_msg(std::string* body_msg) {
  if (body_msg != nullptr) {
    
  } else {
    
  }
  _impl_.body_msg_.SetAllocated(body_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_msg_.IsDefault()) {
    _impl_.body_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.RPC_Multiplexer_Forward.body_msg)
}

// -------------------------------------------------------------------

// PRC_DeMultiplexer_Forward

// .rpc_msg.RoleIdentifier role = 1;
inline bool PRC_DeMultiplexer_Forward::_internal_has_role() const {
  return this != internal_default_instance() && _impl_.role_ != nullptr;
}
inline bool PRC_DeMultiplexer_Forward::has_role() const {
  return _internal_has_role();
}
inline void PRC_DeMultiplexer_Forward::clear_role() {
  if (GetArenaForAllocation() == nullptr && _impl_.role_ != nullptr) {
    delete _impl_.role_;
  }
  _impl_.role_ = nullptr;
}
inline const ::rpc_msg::RoleIdentifier& PRC_DeMultiplexer_Forward::_internal_role() const {
  const ::rpc_msg::RoleIdentifier* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::RoleIdentifier&>(
      ::rpc_msg::_RoleIdentifier_default_instance_);
}
inline const ::rpc_msg::RoleIdentifier& PRC_DeMultiplexer_Forward::role() const {
  // @@protoc_insertion_point(field_get:rpc_msg.PRC_DeMultiplexer_Forward.role)
  return _internal_role();
}
inline void PRC_DeMultiplexer_Forward::unsafe_arena_set_allocated_role(
    ::rpc_msg::RoleIdentifier* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.PRC_DeMultiplexer_Forward.role)
}
inline ::rpc_msg::RoleIdentifier* PRC_DeMultiplexer_Forward::release_role() {
  
  ::rpc_msg::RoleIdentifier* temp = _impl_.role_;
  _impl_.role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::RoleIdentifier* PRC_DeMultiplexer_Forward::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:rpc_msg.PRC_DeMultiplexer_Forward.role)
  
  ::rpc_msg::RoleIdentifier* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::rpc_msg::RoleIdentifier* PRC_DeMultiplexer_Forward::_internal_mutable_role() {
  
  if (_impl_.role_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::RoleIdentifier>(GetArenaForAllocation());
    _impl_.role_ = p;
  }
  return _impl_.role_;
}
inline ::rpc_msg::RoleIdentifier* PRC_DeMultiplexer_Forward::mutable_role() {
  ::rpc_msg::RoleIdentifier* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:rpc_msg.PRC_DeMultiplexer_Forward.role)
  return _msg;
}
inline void PRC_DeMultiplexer_Forward::set_allocated_role(::rpc_msg::RoleIdentifier* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.role_ = role;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.PRC_DeMultiplexer_Forward.role)
}

// .rpc_msg.ClientMessageInfo info = 2;
inline bool PRC_DeMultiplexer_Forward::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool PRC_DeMultiplexer_Forward::has_info() const {
  return _internal_has_info();
}
inline void PRC_DeMultiplexer_Forward::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::rpc_msg::ClientMessageInfo& PRC_DeMultiplexer_Forward::_internal_info() const {
  const ::rpc_msg::ClientMessageInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpc_msg::ClientMessageInfo&>(
      ::rpc_msg::_ClientMessageInfo_default_instance_);
}
inline const ::rpc_msg::ClientMessageInfo& PRC_DeMultiplexer_Forward::info() const {
  // @@protoc_insertion_point(field_get:rpc_msg.PRC_DeMultiplexer_Forward.info)
  return _internal_info();
}
inline void PRC_DeMultiplexer_Forward::unsafe_arena_set_allocated_info(
    ::rpc_msg::ClientMessageInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpc_msg.PRC_DeMultiplexer_Forward.info)
}
inline ::rpc_msg::ClientMessageInfo* PRC_DeMultiplexer_Forward::release_info() {
  
  ::rpc_msg::ClientMessageInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rpc_msg::ClientMessageInfo* PRC_DeMultiplexer_Forward::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:rpc_msg.PRC_DeMultiplexer_Forward.info)
  
  ::rpc_msg::ClientMessageInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::rpc_msg::ClientMessageInfo* PRC_DeMultiplexer_Forward::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpc_msg::ClientMessageInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::rpc_msg::ClientMessageInfo* PRC_DeMultiplexer_Forward::mutable_info() {
  ::rpc_msg::ClientMessageInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:rpc_msg.PRC_DeMultiplexer_Forward.info)
  return _msg;
}
inline void PRC_DeMultiplexer_Forward::set_allocated_info(::rpc_msg::ClientMessageInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.PRC_DeMultiplexer_Forward.info)
}

// bytes body_msg = 3;
inline void PRC_DeMultiplexer_Forward::clear_body_msg() {
  _impl_.body_msg_.ClearToEmpty();
}
inline const std::string& PRC_DeMultiplexer_Forward::body_msg() const {
  // @@protoc_insertion_point(field_get:rpc_msg.PRC_DeMultiplexer_Forward.body_msg)
  return _internal_body_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PRC_DeMultiplexer_Forward::set_body_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_msg_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc_msg.PRC_DeMultiplexer_Forward.body_msg)
}
inline std::string* PRC_DeMultiplexer_Forward::mutable_body_msg() {
  std::string* _s = _internal_mutable_body_msg();
  // @@protoc_insertion_point(field_mutable:rpc_msg.PRC_DeMultiplexer_Forward.body_msg)
  return _s;
}
inline const std::string& PRC_DeMultiplexer_Forward::_internal_body_msg() const {
  return _impl_.body_msg_.Get();
}
inline void PRC_DeMultiplexer_Forward::_internal_set_body_msg(const std::string& value) {
  
  _impl_.body_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* PRC_DeMultiplexer_Forward::_internal_mutable_body_msg() {
  
  return _impl_.body_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* PRC_DeMultiplexer_Forward::release_body_msg() {
  // @@protoc_insertion_point(field_release:rpc_msg.PRC_DeMultiplexer_Forward.body_msg)
  return _impl_.body_msg_.Release();
}
inline void PRC_DeMultiplexer_Forward::set_allocated_body_msg(std::string* body_msg) {
  if (body_msg != nullptr) {
    
  } else {
    
  }
  _impl_.body_msg_.SetAllocated(body_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_msg_.IsDefault()) {
    _impl_.body_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc_msg.PRC_DeMultiplexer_Forward.body_msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc_msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::rpc_msg::RPC_OPCODES> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rpc_msg::RPC_OPCODES>() {
  return ::rpc_msg::RPC_OPCODES_descriptor();
}
template <> struct is_proto_enum< ::rpc_msg::RPC_CODE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rpc_msg::RPC_CODE>() {
  return ::rpc_msg::RPC_CODE_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rpc_5fmsg_2eproto
