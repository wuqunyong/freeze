// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: login.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_login_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_login_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_login_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_login_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_login_2eproto;
namespace pb {
namespace login {
class Base_Cmd;
struct Base_CmdDefaultTypeInternal;
extern Base_CmdDefaultTypeInternal _Base_Cmd_default_instance_;
class KickPlayer;
struct KickPlayerDefaultTypeInternal;
extern KickPlayerDefaultTypeInternal _KickPlayer_default_instance_;
class LoginC2GS;
struct LoginC2GSDefaultTypeInternal;
extern LoginC2GSDefaultTypeInternal _LoginC2GS_default_instance_;
class LoginC2LS;
struct LoginC2LSDefaultTypeInternal;
extern LoginC2LSDefaultTypeInternal _LoginC2LS_default_instance_;
class LoginGS2MS;
struct LoginGS2MSDefaultTypeInternal;
extern LoginGS2MSDefaultTypeInternal _LoginGS2MS_default_instance_;
class LoginKeepAlive;
struct LoginKeepAliveDefaultTypeInternal;
extern LoginKeepAliveDefaultTypeInternal _LoginKeepAlive_default_instance_;
class LoginLS_Resp;
struct LoginLS_RespDefaultTypeInternal;
extern LoginLS_RespDefaultTypeInternal _LoginLS_Resp_default_instance_;
class LoginMS2GS;
struct LoginMS2GSDefaultTypeInternal;
extern LoginMS2GSDefaultTypeInternal _LoginMS2GS_default_instance_;
class UserLogin;
struct UserLoginDefaultTypeInternal;
extern UserLoginDefaultTypeInternal _UserLogin_default_instance_;
}  // namespace login
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::login::Base_Cmd* Arena::CreateMaybeMessage<::pb::login::Base_Cmd>(Arena*);
template<> ::pb::login::KickPlayer* Arena::CreateMaybeMessage<::pb::login::KickPlayer>(Arena*);
template<> ::pb::login::LoginC2GS* Arena::CreateMaybeMessage<::pb::login::LoginC2GS>(Arena*);
template<> ::pb::login::LoginC2LS* Arena::CreateMaybeMessage<::pb::login::LoginC2LS>(Arena*);
template<> ::pb::login::LoginGS2MS* Arena::CreateMaybeMessage<::pb::login::LoginGS2MS>(Arena*);
template<> ::pb::login::LoginKeepAlive* Arena::CreateMaybeMessage<::pb::login::LoginKeepAlive>(Arena*);
template<> ::pb::login::LoginLS_Resp* Arena::CreateMaybeMessage<::pb::login::LoginLS_Resp>(Arena*);
template<> ::pb::login::LoginMS2GS* Arena::CreateMaybeMessage<::pb::login::LoginMS2GS>(Arena*);
template<> ::pb::login::UserLogin* Arena::CreateMaybeMessage<::pb::login::UserLogin>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {
namespace login {

enum E_Login_Result : int {
  Succ = 0,
  Error_Version = 1,
  Not_Allow = 2,
  Error_UserIdData = 3,
  No_GateServer = 4,
  GateServer_Full = 5,
  Http_AuthError = 6,
  Result_Ban = 7,
  NotFoundReloginKey = 8,
  Invalid_ReloginKey = 9,
  ReloginKey_Timeout = 10,
  No_GameServer = 11,
  Server_Maintance = 12,
  E_Login_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_Login_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_Login_Result_IsValid(int value);
constexpr E_Login_Result E_Login_Result_MIN = Succ;
constexpr E_Login_Result E_Login_Result_MAX = Server_Maintance;
constexpr int E_Login_Result_ARRAYSIZE = E_Login_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_Login_Result_descriptor();
template<typename T>
inline const std::string& E_Login_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_Login_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_Login_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_Login_Result_descriptor(), enum_t_value);
}
inline bool E_Login_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_Login_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_Login_Result>(
    E_Login_Result_descriptor(), name, value);
}
enum E_Kick_Reason : int {
  Repeat_Login = 0,
  Ban = 1,
  Seq_Mismatch = 2,
  E_Kick_Reason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_Kick_Reason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_Kick_Reason_IsValid(int value);
constexpr E_Kick_Reason E_Kick_Reason_MIN = Repeat_Login;
constexpr E_Kick_Reason E_Kick_Reason_MAX = Seq_Mismatch;
constexpr int E_Kick_Reason_ARRAYSIZE = E_Kick_Reason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_Kick_Reason_descriptor();
template<typename T>
inline const std::string& E_Kick_Reason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_Kick_Reason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_Kick_Reason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_Kick_Reason_descriptor(), enum_t_value);
}
inline bool E_Kick_Reason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_Kick_Reason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_Kick_Reason>(
    E_Kick_Reason_descriptor(), name, value);
}
enum E_Login_CMD : int {
  Login = 0,
  Logout = 1,
  KeepAlive = 2,
  LoginResp_MS = 3,
  Kick = 4,
  ReLogin = 5,
  ReLoginKey = 6,
  E_Login_CMD_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_Login_CMD_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_Login_CMD_IsValid(int value);
constexpr E_Login_CMD E_Login_CMD_MIN = Login;
constexpr E_Login_CMD E_Login_CMD_MAX = ReLoginKey;
constexpr int E_Login_CMD_ARRAYSIZE = E_Login_CMD_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_Login_CMD_descriptor();
template<typename T>
inline const std::string& E_Login_CMD_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_Login_CMD>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_Login_CMD_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_Login_CMD_descriptor(), enum_t_value);
}
inline bool E_Login_CMD_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_Login_CMD* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_Login_CMD>(
    E_Login_CMD_descriptor(), name, value);
}
// ===================================================================

class Base_Cmd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.login.Base_Cmd) */ {
 public:
  inline Base_Cmd() : Base_Cmd(nullptr) {}
  ~Base_Cmd() override;
  explicit PROTOBUF_CONSTEXPR Base_Cmd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Base_Cmd(const Base_Cmd& from);
  Base_Cmd(Base_Cmd&& from) noexcept
    : Base_Cmd() {
    *this = ::std::move(from);
  }

  inline Base_Cmd& operator=(const Base_Cmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline Base_Cmd& operator=(Base_Cmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Base_Cmd& default_instance() {
    return *internal_default_instance();
  }
  static inline const Base_Cmd* internal_default_instance() {
    return reinterpret_cast<const Base_Cmd*>(
               &_Base_Cmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Base_Cmd& a, Base_Cmd& b) {
    a.Swap(&b);
  }
  inline void Swap(Base_Cmd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Base_Cmd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Base_Cmd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Base_Cmd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Base_Cmd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Base_Cmd& from) {
    Base_Cmd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Base_Cmd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.login.Base_Cmd";
  }
  protected:
  explicit Base_Cmd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdFieldNumber = 1,
  };
  // .pb.login.E_Login_CMD cmd = 1;
  void clear_cmd();
  ::pb::login::E_Login_CMD cmd() const;
  void set_cmd(::pb::login::E_Login_CMD value);
  private:
  ::pb::login::E_Login_CMD _internal_cmd() const;
  void _internal_set_cmd(::pb::login::E_Login_CMD value);
  public:

  // @@protoc_insertion_point(class_scope:pb.login.Base_Cmd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int cmd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class LoginKeepAlive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.login.LoginKeepAlive) */ {
 public:
  inline LoginKeepAlive() : LoginKeepAlive(nullptr) {}
  ~LoginKeepAlive() override;
  explicit PROTOBUF_CONSTEXPR LoginKeepAlive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginKeepAlive(const LoginKeepAlive& from);
  LoginKeepAlive(LoginKeepAlive&& from) noexcept
    : LoginKeepAlive() {
    *this = ::std::move(from);
  }

  inline LoginKeepAlive& operator=(const LoginKeepAlive& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginKeepAlive& operator=(LoginKeepAlive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginKeepAlive& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginKeepAlive* internal_default_instance() {
    return reinterpret_cast<const LoginKeepAlive*>(
               &_LoginKeepAlive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginKeepAlive& a, LoginKeepAlive& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginKeepAlive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginKeepAlive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginKeepAlive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginKeepAlive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginKeepAlive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginKeepAlive& from) {
    LoginKeepAlive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginKeepAlive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.login.LoginKeepAlive";
  }
  protected:
  explicit LoginKeepAlive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerTimeFieldNumber = 1,
    kSSeqidFieldNumber = 2,
  };
  // int64 server_time = 1;
  void clear_server_time();
  int64_t server_time() const;
  void set_server_time(int64_t value);
  private:
  int64_t _internal_server_time() const;
  void _internal_set_server_time(int64_t value);
  public:

  // uint32 s_seqid = 2;
  void clear_s_seqid();
  uint32_t s_seqid() const;
  void set_s_seqid(uint32_t value);
  private:
  uint32_t _internal_s_seqid() const;
  void _internal_set_s_seqid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.login.LoginKeepAlive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t server_time_;
    uint32_t s_seqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class KickPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.login.KickPlayer) */ {
 public:
  inline KickPlayer() : KickPlayer(nullptr) {}
  ~KickPlayer() override;
  explicit PROTOBUF_CONSTEXPR KickPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KickPlayer(const KickPlayer& from);
  KickPlayer(KickPlayer&& from) noexcept
    : KickPlayer() {
    *this = ::std::move(from);
  }

  inline KickPlayer& operator=(const KickPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickPlayer& operator=(KickPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KickPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickPlayer* internal_default_instance() {
    return reinterpret_cast<const KickPlayer*>(
               &_KickPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(KickPlayer& a, KickPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(KickPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KickPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KickPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KickPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KickPlayer& from) {
    KickPlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KickPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.login.KickPlayer";
  }
  protected:
  explicit KickPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kReasonFieldNumber = 1,
  };
  // int64 user_id = 2;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // .pb.login.E_Kick_Reason reason = 1;
  void clear_reason();
  ::pb::login::E_Kick_Reason reason() const;
  void set_reason(::pb::login::E_Kick_Reason value);
  private:
  ::pb::login::E_Kick_Reason _internal_reason() const;
  void _internal_set_reason(::pb::login::E_Kick_Reason value);
  public:

  // @@protoc_insertion_point(class_scope:pb.login.KickPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t user_id_;
    int reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class UserLogin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.login.UserLogin) */ {
 public:
  inline UserLogin() : UserLogin(nullptr) {}
  ~UserLogin() override;
  explicit PROTOBUF_CONSTEXPR UserLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLogin(const UserLogin& from);
  UserLogin(UserLogin&& from) noexcept
    : UserLogin() {
    *this = ::std::move(from);
  }

  inline UserLogin& operator=(const UserLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLogin& operator=(UserLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLogin* internal_default_instance() {
    return reinterpret_cast<const UserLogin*>(
               &_UserLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserLogin& a, UserLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLogin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLogin& from) {
    UserLogin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLogin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.login.UserLogin";
  }
  protected:
  explicit UserLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionKeyFieldNumber = 3,
    kUserIdFieldNumber = 2,
    kGameIdFieldNumber = 1,
    kResultFieldNumber = 4,
    kSSeqidFieldNumber = 5,
  };
  // string session_key = 3;
  void clear_session_key();
  const std::string& session_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_key();
  PROTOBUF_NODISCARD std::string* release_session_key();
  void set_allocated_session_key(std::string* session_key);
  private:
  const std::string& _internal_session_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_key(const std::string& value);
  std::string* _internal_mutable_session_key();
  public:

  // int64 user_id = 2;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // uint32 game_id = 1;
  void clear_game_id();
  uint32_t game_id() const;
  void set_game_id(uint32_t value);
  private:
  uint32_t _internal_game_id() const;
  void _internal_set_game_id(uint32_t value);
  public:

  // .pb.login.E_Login_Result result = 4;
  void clear_result();
  ::pb::login::E_Login_Result result() const;
  void set_result(::pb::login::E_Login_Result value);
  private:
  ::pb::login::E_Login_Result _internal_result() const;
  void _internal_set_result(::pb::login::E_Login_Result value);
  public:

  // uint32 s_seqid = 5;
  void clear_s_seqid();
  uint32_t s_seqid() const;
  void set_s_seqid(uint32_t value);
  private:
  uint32_t _internal_s_seqid() const;
  void _internal_set_s_seqid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.login.UserLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_key_;
    int64_t user_id_;
    uint32_t game_id_;
    int result_;
    uint32_t s_seqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class LoginC2LS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.login.LoginC2LS) */ {
 public:
  inline LoginC2LS() : LoginC2LS(nullptr) {}
  ~LoginC2LS() override;
  explicit PROTOBUF_CONSTEXPR LoginC2LS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginC2LS(const LoginC2LS& from);
  LoginC2LS(LoginC2LS&& from) noexcept
    : LoginC2LS() {
    *this = ::std::move(from);
  }

  inline LoginC2LS& operator=(const LoginC2LS& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginC2LS& operator=(LoginC2LS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginC2LS& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginC2LS* internal_default_instance() {
    return reinterpret_cast<const LoginC2LS*>(
               &_LoginC2LS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginC2LS& a, LoginC2LS& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginC2LS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginC2LS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginC2LS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginC2LS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginC2LS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginC2LS& from) {
    LoginC2LS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginC2LS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.login.LoginC2LS";
  }
  protected:
  explicit LoginC2LS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionKeyFieldNumber = 3,
    kUdIdFieldNumber = 5,
    kSdkGameIdFieldNumber = 6,
    kUserIdFieldNumber = 2,
    kGameIdFieldNumber = 1,
    kVersionFieldNumber = 4,
  };
  // string session_key = 3;
  void clear_session_key();
  const std::string& session_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_key();
  PROTOBUF_NODISCARD std::string* release_session_key();
  void set_allocated_session_key(std::string* session_key);
  private:
  const std::string& _internal_session_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_key(const std::string& value);
  std::string* _internal_mutable_session_key();
  public:

  // string ud_id = 5;
  void clear_ud_id();
  const std::string& ud_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ud_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ud_id();
  PROTOBUF_NODISCARD std::string* release_ud_id();
  void set_allocated_ud_id(std::string* ud_id);
  private:
  const std::string& _internal_ud_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ud_id(const std::string& value);
  std::string* _internal_mutable_ud_id();
  public:

  // string sdk_game_id = 6;
  void clear_sdk_game_id();
  const std::string& sdk_game_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdk_game_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdk_game_id();
  PROTOBUF_NODISCARD std::string* release_sdk_game_id();
  void set_allocated_sdk_game_id(std::string* sdk_game_id);
  private:
  const std::string& _internal_sdk_game_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdk_game_id(const std::string& value);
  std::string* _internal_mutable_sdk_game_id();
  public:

  // int64 user_id = 2;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // uint32 game_id = 1;
  void clear_game_id();
  uint32_t game_id() const;
  void set_game_id(uint32_t value);
  private:
  uint32_t _internal_game_id() const;
  void _internal_set_game_id(uint32_t value);
  public:

  // uint32 version = 4;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.login.LoginC2LS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ud_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdk_game_id_;
    int64_t user_id_;
    uint32_t game_id_;
    uint32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class LoginLS_Resp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.login.LoginLS_Resp) */ {
 public:
  inline LoginLS_Resp() : LoginLS_Resp(nullptr) {}
  ~LoginLS_Resp() override;
  explicit PROTOBUF_CONSTEXPR LoginLS_Resp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginLS_Resp(const LoginLS_Resp& from);
  LoginLS_Resp(LoginLS_Resp&& from) noexcept
    : LoginLS_Resp() {
    *this = ::std::move(from);
  }

  inline LoginLS_Resp& operator=(const LoginLS_Resp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginLS_Resp& operator=(LoginLS_Resp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginLS_Resp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginLS_Resp* internal_default_instance() {
    return reinterpret_cast<const LoginLS_Resp*>(
               &_LoginLS_Resp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginLS_Resp& a, LoginLS_Resp& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginLS_Resp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginLS_Resp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginLS_Resp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginLS_Resp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginLS_Resp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginLS_Resp& from) {
    LoginLS_Resp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginLS_Resp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.login.LoginLS_Resp";
  }
  protected:
  explicit LoginLS_Resp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDnsFieldNumber = 2,
    kCheckOutTextFieldNumber = 3,
    kIpFieldNumber = 4,
    kResultFieldNumber = 1,
    kPortFieldNumber = 5,
    kUserIdFieldNumber = 6,
    kSdkGameidFieldNumber = 7,
  };
  // string dns = 2;
  void clear_dns();
  const std::string& dns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dns();
  PROTOBUF_NODISCARD std::string* release_dns();
  void set_allocated_dns(std::string* dns);
  private:
  const std::string& _internal_dns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns(const std::string& value);
  std::string* _internal_mutable_dns();
  public:

  // string check_out_text = 3;
  void clear_check_out_text();
  const std::string& check_out_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_check_out_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_check_out_text();
  PROTOBUF_NODISCARD std::string* release_check_out_text();
  void set_allocated_check_out_text(std::string* check_out_text);
  private:
  const std::string& _internal_check_out_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_check_out_text(const std::string& value);
  std::string* _internal_mutable_check_out_text();
  public:

  // string ip = 4;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // uint32 result = 1;
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // uint32 port = 5;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // int64 user_id = 6;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // int64 sdk_gameid = 7;
  void clear_sdk_gameid();
  int64_t sdk_gameid() const;
  void set_sdk_gameid(int64_t value);
  private:
  int64_t _internal_sdk_gameid() const;
  void _internal_set_sdk_gameid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.login.LoginLS_Resp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr check_out_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    uint32_t result_;
    uint32_t port_;
    int64_t user_id_;
    int64_t sdk_gameid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class LoginC2GS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.login.LoginC2GS) */ {
 public:
  inline LoginC2GS() : LoginC2GS(nullptr) {}
  ~LoginC2GS() override;
  explicit PROTOBUF_CONSTEXPR LoginC2GS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginC2GS(const LoginC2GS& from);
  LoginC2GS(LoginC2GS&& from) noexcept
    : LoginC2GS() {
    *this = ::std::move(from);
  }

  inline LoginC2GS& operator=(const LoginC2GS& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginC2GS& operator=(LoginC2GS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginC2GS& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginC2GS* internal_default_instance() {
    return reinterpret_cast<const LoginC2GS*>(
               &_LoginC2GS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoginC2GS& a, LoginC2GS& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginC2GS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginC2GS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginC2GS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginC2GS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginC2GS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginC2GS& from) {
    LoginC2GS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginC2GS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.login.LoginC2GS";
  }
  protected:
  explicit LoginC2GS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCheckOutTextFieldNumber = 3,
    kSessionKeyFieldNumber = 4,
    kUserIdFieldNumber = 2,
    kOperatorFieldNumber = 1,
    kVersionFieldNumber = 5,
    kGameIdFieldNumber = 6,
    kClientSignFieldNumber = 7,
    kClientSign2FieldNumber = 8,
    kWebFlagFieldNumber = 9,
  };
  // string check_out_text = 3;
  void clear_check_out_text();
  const std::string& check_out_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_check_out_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_check_out_text();
  PROTOBUF_NODISCARD std::string* release_check_out_text();
  void set_allocated_check_out_text(std::string* check_out_text);
  private:
  const std::string& _internal_check_out_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_check_out_text(const std::string& value);
  std::string* _internal_mutable_check_out_text();
  public:

  // string session_key = 4;
  void clear_session_key();
  const std::string& session_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_key();
  PROTOBUF_NODISCARD std::string* release_session_key();
  void set_allocated_session_key(std::string* session_key);
  private:
  const std::string& _internal_session_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_key(const std::string& value);
  std::string* _internal_mutable_session_key();
  public:

  // int64 user_id = 2;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // uint32 operator = 1;
  void clear_operator_();
  uint32_t operator_() const;
  void set_operator_(uint32_t value);
  private:
  uint32_t _internal_operator_() const;
  void _internal_set_operator_(uint32_t value);
  public:

  // uint32 version = 5;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // uint32 game_id = 6;
  void clear_game_id();
  uint32_t game_id() const;
  void set_game_id(uint32_t value);
  private:
  uint32_t _internal_game_id() const;
  void _internal_set_game_id(uint32_t value);
  public:

  // uint32 client_sign = 7;
  void clear_client_sign();
  uint32_t client_sign() const;
  void set_client_sign(uint32_t value);
  private:
  uint32_t _internal_client_sign() const;
  void _internal_set_client_sign(uint32_t value);
  public:

  // uint32 client_sign2 = 8;
  void clear_client_sign2();
  uint32_t client_sign2() const;
  void set_client_sign2(uint32_t value);
  private:
  uint32_t _internal_client_sign2() const;
  void _internal_set_client_sign2(uint32_t value);
  public:

  // uint32 web_flag = 9;
  void clear_web_flag();
  uint32_t web_flag() const;
  void set_web_flag(uint32_t value);
  private:
  uint32_t _internal_web_flag() const;
  void _internal_set_web_flag(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.login.LoginC2GS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr check_out_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_key_;
    int64_t user_id_;
    uint32_t operator__;
    uint32_t version_;
    uint32_t game_id_;
    uint32_t client_sign_;
    uint32_t client_sign2_;
    uint32_t web_flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class LoginGS2MS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.login.LoginGS2MS) */ {
 public:
  inline LoginGS2MS() : LoginGS2MS(nullptr) {}
  ~LoginGS2MS() override;
  explicit PROTOBUF_CONSTEXPR LoginGS2MS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginGS2MS(const LoginGS2MS& from);
  LoginGS2MS(LoginGS2MS&& from) noexcept
    : LoginGS2MS() {
    *this = ::std::move(from);
  }

  inline LoginGS2MS& operator=(const LoginGS2MS& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginGS2MS& operator=(LoginGS2MS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginGS2MS& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginGS2MS* internal_default_instance() {
    return reinterpret_cast<const LoginGS2MS*>(
               &_LoginGS2MS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoginGS2MS& a, LoginGS2MS& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginGS2MS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginGS2MS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginGS2MS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginGS2MS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginGS2MS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginGS2MS& from) {
    LoginGS2MS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginGS2MS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.login.LoginGS2MS";
  }
  protected:
  explicit LoginGS2MS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kStateFieldNumber = 9,
    kGateserverIdFieldNumber = 2,
    kGlobalMailIdFieldNumber = 3,
    kRegisterTimeFieldNumber = 4,
    kUserIdFieldNumber = 5,
    kIggIdFieldNumber = 6,
    kSdkGameidFieldNumber = 8,
    kGameIdFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string state = 9;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // uint32 gateserver_id = 2;
  void clear_gateserver_id();
  uint32_t gateserver_id() const;
  void set_gateserver_id(uint32_t value);
  private:
  uint32_t _internal_gateserver_id() const;
  void _internal_set_gateserver_id(uint32_t value);
  public:

  // uint32 global_mail_id = 3;
  void clear_global_mail_id();
  uint32_t global_mail_id() const;
  void set_global_mail_id(uint32_t value);
  private:
  uint32_t _internal_global_mail_id() const;
  void _internal_set_global_mail_id(uint32_t value);
  public:

  // int64 register_time = 4;
  void clear_register_time();
  int64_t register_time() const;
  void set_register_time(int64_t value);
  private:
  int64_t _internal_register_time() const;
  void _internal_set_register_time(int64_t value);
  public:

  // int64 user_id = 5;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // int64 igg_id = 6;
  void clear_igg_id();
  int64_t igg_id() const;
  void set_igg_id(int64_t value);
  private:
  int64_t _internal_igg_id() const;
  void _internal_set_igg_id(int64_t value);
  public:

  // int64 sdk_gameid = 8;
  void clear_sdk_gameid();
  int64_t sdk_gameid() const;
  void set_sdk_gameid(int64_t value);
  private:
  int64_t _internal_sdk_gameid() const;
  void _internal_set_sdk_gameid(int64_t value);
  public:

  // uint32 game_id = 7;
  void clear_game_id();
  uint32_t game_id() const;
  void set_game_id(uint32_t value);
  private:
  uint32_t _internal_game_id() const;
  void _internal_set_game_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.login.LoginGS2MS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    uint32_t gateserver_id_;
    uint32_t global_mail_id_;
    int64_t register_time_;
    int64_t user_id_;
    int64_t igg_id_;
    int64_t sdk_gameid_;
    uint32_t game_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_login_2eproto;
};
// -------------------------------------------------------------------

class LoginMS2GS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.login.LoginMS2GS) */ {
 public:
  inline LoginMS2GS() : LoginMS2GS(nullptr) {}
  ~LoginMS2GS() override;
  explicit PROTOBUF_CONSTEXPR LoginMS2GS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginMS2GS(const LoginMS2GS& from);
  LoginMS2GS(LoginMS2GS&& from) noexcept
    : LoginMS2GS() {
    *this = ::std::move(from);
  }

  inline LoginMS2GS& operator=(const LoginMS2GS& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginMS2GS& operator=(LoginMS2GS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginMS2GS& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginMS2GS* internal_default_instance() {
    return reinterpret_cast<const LoginMS2GS*>(
               &_LoginMS2GS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoginMS2GS& a, LoginMS2GS& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginMS2GS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginMS2GS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginMS2GS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginMS2GS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginMS2GS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginMS2GS& from) {
    LoginMS2GS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginMS2GS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.login.LoginMS2GS";
  }
  protected:
  explicit LoginMS2GS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIggIdFieldNumber = 1,
    kUserIdFieldNumber = 3,
    kGameIdFieldNumber = 2,
    kDbServerIdFieldNumber = 4,
    kSdkGameidFieldNumber = 5,
  };
  // int64 igg_id = 1;
  void clear_igg_id();
  int64_t igg_id() const;
  void set_igg_id(int64_t value);
  private:
  int64_t _internal_igg_id() const;
  void _internal_set_igg_id(int64_t value);
  public:

  // int64 user_id = 3;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // uint32 game_id = 2;
  void clear_game_id();
  uint32_t game_id() const;
  void set_game_id(uint32_t value);
  private:
  uint32_t _internal_game_id() const;
  void _internal_set_game_id(uint32_t value);
  public:

  // int32 db_server_id = 4;
  void clear_db_server_id();
  int32_t db_server_id() const;
  void set_db_server_id(int32_t value);
  private:
  int32_t _internal_db_server_id() const;
  void _internal_set_db_server_id(int32_t value);
  public:

  // int64 sdk_gameid = 5;
  void clear_sdk_gameid();
  int64_t sdk_gameid() const;
  void set_sdk_gameid(int64_t value);
  private:
  int64_t _internal_sdk_gameid() const;
  void _internal_set_sdk_gameid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.login.LoginMS2GS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t igg_id_;
    int64_t user_id_;
    uint32_t game_id_;
    int32_t db_server_id_;
    int64_t sdk_gameid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_login_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Base_Cmd

// .pb.login.E_Login_CMD cmd = 1;
inline void Base_Cmd::clear_cmd() {
  _impl_.cmd_ = 0;
}
inline ::pb::login::E_Login_CMD Base_Cmd::_internal_cmd() const {
  return static_cast< ::pb::login::E_Login_CMD >(_impl_.cmd_);
}
inline ::pb::login::E_Login_CMD Base_Cmd::cmd() const {
  // @@protoc_insertion_point(field_get:pb.login.Base_Cmd.cmd)
  return _internal_cmd();
}
inline void Base_Cmd::_internal_set_cmd(::pb::login::E_Login_CMD value) {
  
  _impl_.cmd_ = value;
}
inline void Base_Cmd::set_cmd(::pb::login::E_Login_CMD value) {
  _internal_set_cmd(value);
  // @@protoc_insertion_point(field_set:pb.login.Base_Cmd.cmd)
}

// -------------------------------------------------------------------

// LoginKeepAlive

// int64 server_time = 1;
inline void LoginKeepAlive::clear_server_time() {
  _impl_.server_time_ = int64_t{0};
}
inline int64_t LoginKeepAlive::_internal_server_time() const {
  return _impl_.server_time_;
}
inline int64_t LoginKeepAlive::server_time() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginKeepAlive.server_time)
  return _internal_server_time();
}
inline void LoginKeepAlive::_internal_set_server_time(int64_t value) {
  
  _impl_.server_time_ = value;
}
inline void LoginKeepAlive::set_server_time(int64_t value) {
  _internal_set_server_time(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginKeepAlive.server_time)
}

// uint32 s_seqid = 2;
inline void LoginKeepAlive::clear_s_seqid() {
  _impl_.s_seqid_ = 0u;
}
inline uint32_t LoginKeepAlive::_internal_s_seqid() const {
  return _impl_.s_seqid_;
}
inline uint32_t LoginKeepAlive::s_seqid() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginKeepAlive.s_seqid)
  return _internal_s_seqid();
}
inline void LoginKeepAlive::_internal_set_s_seqid(uint32_t value) {
  
  _impl_.s_seqid_ = value;
}
inline void LoginKeepAlive::set_s_seqid(uint32_t value) {
  _internal_set_s_seqid(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginKeepAlive.s_seqid)
}

// -------------------------------------------------------------------

// KickPlayer

// .pb.login.E_Kick_Reason reason = 1;
inline void KickPlayer::clear_reason() {
  _impl_.reason_ = 0;
}
inline ::pb::login::E_Kick_Reason KickPlayer::_internal_reason() const {
  return static_cast< ::pb::login::E_Kick_Reason >(_impl_.reason_);
}
inline ::pb::login::E_Kick_Reason KickPlayer::reason() const {
  // @@protoc_insertion_point(field_get:pb.login.KickPlayer.reason)
  return _internal_reason();
}
inline void KickPlayer::_internal_set_reason(::pb::login::E_Kick_Reason value) {
  
  _impl_.reason_ = value;
}
inline void KickPlayer::set_reason(::pb::login::E_Kick_Reason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:pb.login.KickPlayer.reason)
}

// int64 user_id = 2;
inline void KickPlayer::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t KickPlayer::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t KickPlayer::user_id() const {
  // @@protoc_insertion_point(field_get:pb.login.KickPlayer.user_id)
  return _internal_user_id();
}
inline void KickPlayer::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void KickPlayer::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:pb.login.KickPlayer.user_id)
}

// -------------------------------------------------------------------

// UserLogin

// uint32 game_id = 1;
inline void UserLogin::clear_game_id() {
  _impl_.game_id_ = 0u;
}
inline uint32_t UserLogin::_internal_game_id() const {
  return _impl_.game_id_;
}
inline uint32_t UserLogin::game_id() const {
  // @@protoc_insertion_point(field_get:pb.login.UserLogin.game_id)
  return _internal_game_id();
}
inline void UserLogin::_internal_set_game_id(uint32_t value) {
  
  _impl_.game_id_ = value;
}
inline void UserLogin::set_game_id(uint32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:pb.login.UserLogin.game_id)
}

// int64 user_id = 2;
inline void UserLogin::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t UserLogin::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t UserLogin::user_id() const {
  // @@protoc_insertion_point(field_get:pb.login.UserLogin.user_id)
  return _internal_user_id();
}
inline void UserLogin::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void UserLogin::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:pb.login.UserLogin.user_id)
}

// string session_key = 3;
inline void UserLogin::clear_session_key() {
  _impl_.session_key_.ClearToEmpty();
}
inline const std::string& UserLogin::session_key() const {
  // @@protoc_insertion_point(field_get:pb.login.UserLogin.session_key)
  return _internal_session_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLogin::set_session_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.login.UserLogin.session_key)
}
inline std::string* UserLogin::mutable_session_key() {
  std::string* _s = _internal_mutable_session_key();
  // @@protoc_insertion_point(field_mutable:pb.login.UserLogin.session_key)
  return _s;
}
inline const std::string& UserLogin::_internal_session_key() const {
  return _impl_.session_key_.Get();
}
inline void UserLogin::_internal_set_session_key(const std::string& value) {
  
  _impl_.session_key_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogin::_internal_mutable_session_key() {
  
  return _impl_.session_key_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLogin::release_session_key() {
  // @@protoc_insertion_point(field_release:pb.login.UserLogin.session_key)
  return _impl_.session_key_.Release();
}
inline void UserLogin::set_allocated_session_key(std::string* session_key) {
  if (session_key != nullptr) {
    
  } else {
    
  }
  _impl_.session_key_.SetAllocated(session_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_key_.IsDefault()) {
    _impl_.session_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.login.UserLogin.session_key)
}

// .pb.login.E_Login_Result result = 4;
inline void UserLogin::clear_result() {
  _impl_.result_ = 0;
}
inline ::pb::login::E_Login_Result UserLogin::_internal_result() const {
  return static_cast< ::pb::login::E_Login_Result >(_impl_.result_);
}
inline ::pb::login::E_Login_Result UserLogin::result() const {
  // @@protoc_insertion_point(field_get:pb.login.UserLogin.result)
  return _internal_result();
}
inline void UserLogin::_internal_set_result(::pb::login::E_Login_Result value) {
  
  _impl_.result_ = value;
}
inline void UserLogin::set_result(::pb::login::E_Login_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:pb.login.UserLogin.result)
}

// uint32 s_seqid = 5;
inline void UserLogin::clear_s_seqid() {
  _impl_.s_seqid_ = 0u;
}
inline uint32_t UserLogin::_internal_s_seqid() const {
  return _impl_.s_seqid_;
}
inline uint32_t UserLogin::s_seqid() const {
  // @@protoc_insertion_point(field_get:pb.login.UserLogin.s_seqid)
  return _internal_s_seqid();
}
inline void UserLogin::_internal_set_s_seqid(uint32_t value) {
  
  _impl_.s_seqid_ = value;
}
inline void UserLogin::set_s_seqid(uint32_t value) {
  _internal_set_s_seqid(value);
  // @@protoc_insertion_point(field_set:pb.login.UserLogin.s_seqid)
}

// -------------------------------------------------------------------

// LoginC2LS

// uint32 game_id = 1;
inline void LoginC2LS::clear_game_id() {
  _impl_.game_id_ = 0u;
}
inline uint32_t LoginC2LS::_internal_game_id() const {
  return _impl_.game_id_;
}
inline uint32_t LoginC2LS::game_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2LS.game_id)
  return _internal_game_id();
}
inline void LoginC2LS::_internal_set_game_id(uint32_t value) {
  
  _impl_.game_id_ = value;
}
inline void LoginC2LS::set_game_id(uint32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginC2LS.game_id)
}

// int64 user_id = 2;
inline void LoginC2LS::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t LoginC2LS::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t LoginC2LS::user_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2LS.user_id)
  return _internal_user_id();
}
inline void LoginC2LS::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void LoginC2LS::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginC2LS.user_id)
}

// string session_key = 3;
inline void LoginC2LS::clear_session_key() {
  _impl_.session_key_.ClearToEmpty();
}
inline const std::string& LoginC2LS::session_key() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2LS.session_key)
  return _internal_session_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginC2LS::set_session_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.login.LoginC2LS.session_key)
}
inline std::string* LoginC2LS::mutable_session_key() {
  std::string* _s = _internal_mutable_session_key();
  // @@protoc_insertion_point(field_mutable:pb.login.LoginC2LS.session_key)
  return _s;
}
inline const std::string& LoginC2LS::_internal_session_key() const {
  return _impl_.session_key_.Get();
}
inline void LoginC2LS::_internal_set_session_key(const std::string& value) {
  
  _impl_.session_key_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginC2LS::_internal_mutable_session_key() {
  
  return _impl_.session_key_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginC2LS::release_session_key() {
  // @@protoc_insertion_point(field_release:pb.login.LoginC2LS.session_key)
  return _impl_.session_key_.Release();
}
inline void LoginC2LS::set_allocated_session_key(std::string* session_key) {
  if (session_key != nullptr) {
    
  } else {
    
  }
  _impl_.session_key_.SetAllocated(session_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_key_.IsDefault()) {
    _impl_.session_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.login.LoginC2LS.session_key)
}

// uint32 version = 4;
inline void LoginC2LS::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t LoginC2LS::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t LoginC2LS::version() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2LS.version)
  return _internal_version();
}
inline void LoginC2LS::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void LoginC2LS::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginC2LS.version)
}

// string ud_id = 5;
inline void LoginC2LS::clear_ud_id() {
  _impl_.ud_id_.ClearToEmpty();
}
inline const std::string& LoginC2LS::ud_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2LS.ud_id)
  return _internal_ud_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginC2LS::set_ud_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ud_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.login.LoginC2LS.ud_id)
}
inline std::string* LoginC2LS::mutable_ud_id() {
  std::string* _s = _internal_mutable_ud_id();
  // @@protoc_insertion_point(field_mutable:pb.login.LoginC2LS.ud_id)
  return _s;
}
inline const std::string& LoginC2LS::_internal_ud_id() const {
  return _impl_.ud_id_.Get();
}
inline void LoginC2LS::_internal_set_ud_id(const std::string& value) {
  
  _impl_.ud_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginC2LS::_internal_mutable_ud_id() {
  
  return _impl_.ud_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginC2LS::release_ud_id() {
  // @@protoc_insertion_point(field_release:pb.login.LoginC2LS.ud_id)
  return _impl_.ud_id_.Release();
}
inline void LoginC2LS::set_allocated_ud_id(std::string* ud_id) {
  if (ud_id != nullptr) {
    
  } else {
    
  }
  _impl_.ud_id_.SetAllocated(ud_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ud_id_.IsDefault()) {
    _impl_.ud_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.login.LoginC2LS.ud_id)
}

// string sdk_game_id = 6;
inline void LoginC2LS::clear_sdk_game_id() {
  _impl_.sdk_game_id_.ClearToEmpty();
}
inline const std::string& LoginC2LS::sdk_game_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2LS.sdk_game_id)
  return _internal_sdk_game_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginC2LS::set_sdk_game_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdk_game_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.login.LoginC2LS.sdk_game_id)
}
inline std::string* LoginC2LS::mutable_sdk_game_id() {
  std::string* _s = _internal_mutable_sdk_game_id();
  // @@protoc_insertion_point(field_mutable:pb.login.LoginC2LS.sdk_game_id)
  return _s;
}
inline const std::string& LoginC2LS::_internal_sdk_game_id() const {
  return _impl_.sdk_game_id_.Get();
}
inline void LoginC2LS::_internal_set_sdk_game_id(const std::string& value) {
  
  _impl_.sdk_game_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginC2LS::_internal_mutable_sdk_game_id() {
  
  return _impl_.sdk_game_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginC2LS::release_sdk_game_id() {
  // @@protoc_insertion_point(field_release:pb.login.LoginC2LS.sdk_game_id)
  return _impl_.sdk_game_id_.Release();
}
inline void LoginC2LS::set_allocated_sdk_game_id(std::string* sdk_game_id) {
  if (sdk_game_id != nullptr) {
    
  } else {
    
  }
  _impl_.sdk_game_id_.SetAllocated(sdk_game_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdk_game_id_.IsDefault()) {
    _impl_.sdk_game_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.login.LoginC2LS.sdk_game_id)
}

// -------------------------------------------------------------------

// LoginLS_Resp

// uint32 result = 1;
inline void LoginLS_Resp::clear_result() {
  _impl_.result_ = 0u;
}
inline uint32_t LoginLS_Resp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t LoginLS_Resp::result() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginLS_Resp.result)
  return _internal_result();
}
inline void LoginLS_Resp::_internal_set_result(uint32_t value) {
  
  _impl_.result_ = value;
}
inline void LoginLS_Resp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginLS_Resp.result)
}

// string dns = 2;
inline void LoginLS_Resp::clear_dns() {
  _impl_.dns_.ClearToEmpty();
}
inline const std::string& LoginLS_Resp::dns() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginLS_Resp.dns)
  return _internal_dns();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginLS_Resp::set_dns(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dns_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.login.LoginLS_Resp.dns)
}
inline std::string* LoginLS_Resp::mutable_dns() {
  std::string* _s = _internal_mutable_dns();
  // @@protoc_insertion_point(field_mutable:pb.login.LoginLS_Resp.dns)
  return _s;
}
inline const std::string& LoginLS_Resp::_internal_dns() const {
  return _impl_.dns_.Get();
}
inline void LoginLS_Resp::_internal_set_dns(const std::string& value) {
  
  _impl_.dns_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginLS_Resp::_internal_mutable_dns() {
  
  return _impl_.dns_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginLS_Resp::release_dns() {
  // @@protoc_insertion_point(field_release:pb.login.LoginLS_Resp.dns)
  return _impl_.dns_.Release();
}
inline void LoginLS_Resp::set_allocated_dns(std::string* dns) {
  if (dns != nullptr) {
    
  } else {
    
  }
  _impl_.dns_.SetAllocated(dns, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dns_.IsDefault()) {
    _impl_.dns_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.login.LoginLS_Resp.dns)
}

// string check_out_text = 3;
inline void LoginLS_Resp::clear_check_out_text() {
  _impl_.check_out_text_.ClearToEmpty();
}
inline const std::string& LoginLS_Resp::check_out_text() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginLS_Resp.check_out_text)
  return _internal_check_out_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginLS_Resp::set_check_out_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.check_out_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.login.LoginLS_Resp.check_out_text)
}
inline std::string* LoginLS_Resp::mutable_check_out_text() {
  std::string* _s = _internal_mutable_check_out_text();
  // @@protoc_insertion_point(field_mutable:pb.login.LoginLS_Resp.check_out_text)
  return _s;
}
inline const std::string& LoginLS_Resp::_internal_check_out_text() const {
  return _impl_.check_out_text_.Get();
}
inline void LoginLS_Resp::_internal_set_check_out_text(const std::string& value) {
  
  _impl_.check_out_text_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginLS_Resp::_internal_mutable_check_out_text() {
  
  return _impl_.check_out_text_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginLS_Resp::release_check_out_text() {
  // @@protoc_insertion_point(field_release:pb.login.LoginLS_Resp.check_out_text)
  return _impl_.check_out_text_.Release();
}
inline void LoginLS_Resp::set_allocated_check_out_text(std::string* check_out_text) {
  if (check_out_text != nullptr) {
    
  } else {
    
  }
  _impl_.check_out_text_.SetAllocated(check_out_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.check_out_text_.IsDefault()) {
    _impl_.check_out_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.login.LoginLS_Resp.check_out_text)
}

// string ip = 4;
inline void LoginLS_Resp::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& LoginLS_Resp::ip() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginLS_Resp.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginLS_Resp::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.login.LoginLS_Resp.ip)
}
inline std::string* LoginLS_Resp::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:pb.login.LoginLS_Resp.ip)
  return _s;
}
inline const std::string& LoginLS_Resp::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void LoginLS_Resp::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginLS_Resp::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginLS_Resp::release_ip() {
  // @@protoc_insertion_point(field_release:pb.login.LoginLS_Resp.ip)
  return _impl_.ip_.Release();
}
inline void LoginLS_Resp::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.login.LoginLS_Resp.ip)
}

// uint32 port = 5;
inline void LoginLS_Resp::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t LoginLS_Resp::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t LoginLS_Resp::port() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginLS_Resp.port)
  return _internal_port();
}
inline void LoginLS_Resp::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void LoginLS_Resp::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginLS_Resp.port)
}

// int64 user_id = 6;
inline void LoginLS_Resp::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t LoginLS_Resp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t LoginLS_Resp::user_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginLS_Resp.user_id)
  return _internal_user_id();
}
inline void LoginLS_Resp::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void LoginLS_Resp::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginLS_Resp.user_id)
}

// int64 sdk_gameid = 7;
inline void LoginLS_Resp::clear_sdk_gameid() {
  _impl_.sdk_gameid_ = int64_t{0};
}
inline int64_t LoginLS_Resp::_internal_sdk_gameid() const {
  return _impl_.sdk_gameid_;
}
inline int64_t LoginLS_Resp::sdk_gameid() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginLS_Resp.sdk_gameid)
  return _internal_sdk_gameid();
}
inline void LoginLS_Resp::_internal_set_sdk_gameid(int64_t value) {
  
  _impl_.sdk_gameid_ = value;
}
inline void LoginLS_Resp::set_sdk_gameid(int64_t value) {
  _internal_set_sdk_gameid(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginLS_Resp.sdk_gameid)
}

// -------------------------------------------------------------------

// LoginC2GS

// uint32 operator = 1;
inline void LoginC2GS::clear_operator_() {
  _impl_.operator__ = 0u;
}
inline uint32_t LoginC2GS::_internal_operator_() const {
  return _impl_.operator__;
}
inline uint32_t LoginC2GS::operator_() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2GS.operator)
  return _internal_operator_();
}
inline void LoginC2GS::_internal_set_operator_(uint32_t value) {
  
  _impl_.operator__ = value;
}
inline void LoginC2GS::set_operator_(uint32_t value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginC2GS.operator)
}

// int64 user_id = 2;
inline void LoginC2GS::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t LoginC2GS::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t LoginC2GS::user_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2GS.user_id)
  return _internal_user_id();
}
inline void LoginC2GS::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void LoginC2GS::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginC2GS.user_id)
}

// string check_out_text = 3;
inline void LoginC2GS::clear_check_out_text() {
  _impl_.check_out_text_.ClearToEmpty();
}
inline const std::string& LoginC2GS::check_out_text() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2GS.check_out_text)
  return _internal_check_out_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginC2GS::set_check_out_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.check_out_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.login.LoginC2GS.check_out_text)
}
inline std::string* LoginC2GS::mutable_check_out_text() {
  std::string* _s = _internal_mutable_check_out_text();
  // @@protoc_insertion_point(field_mutable:pb.login.LoginC2GS.check_out_text)
  return _s;
}
inline const std::string& LoginC2GS::_internal_check_out_text() const {
  return _impl_.check_out_text_.Get();
}
inline void LoginC2GS::_internal_set_check_out_text(const std::string& value) {
  
  _impl_.check_out_text_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginC2GS::_internal_mutable_check_out_text() {
  
  return _impl_.check_out_text_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginC2GS::release_check_out_text() {
  // @@protoc_insertion_point(field_release:pb.login.LoginC2GS.check_out_text)
  return _impl_.check_out_text_.Release();
}
inline void LoginC2GS::set_allocated_check_out_text(std::string* check_out_text) {
  if (check_out_text != nullptr) {
    
  } else {
    
  }
  _impl_.check_out_text_.SetAllocated(check_out_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.check_out_text_.IsDefault()) {
    _impl_.check_out_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.login.LoginC2GS.check_out_text)
}

// string session_key = 4;
inline void LoginC2GS::clear_session_key() {
  _impl_.session_key_.ClearToEmpty();
}
inline const std::string& LoginC2GS::session_key() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2GS.session_key)
  return _internal_session_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginC2GS::set_session_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.login.LoginC2GS.session_key)
}
inline std::string* LoginC2GS::mutable_session_key() {
  std::string* _s = _internal_mutable_session_key();
  // @@protoc_insertion_point(field_mutable:pb.login.LoginC2GS.session_key)
  return _s;
}
inline const std::string& LoginC2GS::_internal_session_key() const {
  return _impl_.session_key_.Get();
}
inline void LoginC2GS::_internal_set_session_key(const std::string& value) {
  
  _impl_.session_key_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginC2GS::_internal_mutable_session_key() {
  
  return _impl_.session_key_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginC2GS::release_session_key() {
  // @@protoc_insertion_point(field_release:pb.login.LoginC2GS.session_key)
  return _impl_.session_key_.Release();
}
inline void LoginC2GS::set_allocated_session_key(std::string* session_key) {
  if (session_key != nullptr) {
    
  } else {
    
  }
  _impl_.session_key_.SetAllocated(session_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_key_.IsDefault()) {
    _impl_.session_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.login.LoginC2GS.session_key)
}

// uint32 version = 5;
inline void LoginC2GS::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t LoginC2GS::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t LoginC2GS::version() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2GS.version)
  return _internal_version();
}
inline void LoginC2GS::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void LoginC2GS::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginC2GS.version)
}

// uint32 game_id = 6;
inline void LoginC2GS::clear_game_id() {
  _impl_.game_id_ = 0u;
}
inline uint32_t LoginC2GS::_internal_game_id() const {
  return _impl_.game_id_;
}
inline uint32_t LoginC2GS::game_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2GS.game_id)
  return _internal_game_id();
}
inline void LoginC2GS::_internal_set_game_id(uint32_t value) {
  
  _impl_.game_id_ = value;
}
inline void LoginC2GS::set_game_id(uint32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginC2GS.game_id)
}

// uint32 client_sign = 7;
inline void LoginC2GS::clear_client_sign() {
  _impl_.client_sign_ = 0u;
}
inline uint32_t LoginC2GS::_internal_client_sign() const {
  return _impl_.client_sign_;
}
inline uint32_t LoginC2GS::client_sign() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2GS.client_sign)
  return _internal_client_sign();
}
inline void LoginC2GS::_internal_set_client_sign(uint32_t value) {
  
  _impl_.client_sign_ = value;
}
inline void LoginC2GS::set_client_sign(uint32_t value) {
  _internal_set_client_sign(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginC2GS.client_sign)
}

// uint32 client_sign2 = 8;
inline void LoginC2GS::clear_client_sign2() {
  _impl_.client_sign2_ = 0u;
}
inline uint32_t LoginC2GS::_internal_client_sign2() const {
  return _impl_.client_sign2_;
}
inline uint32_t LoginC2GS::client_sign2() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2GS.client_sign2)
  return _internal_client_sign2();
}
inline void LoginC2GS::_internal_set_client_sign2(uint32_t value) {
  
  _impl_.client_sign2_ = value;
}
inline void LoginC2GS::set_client_sign2(uint32_t value) {
  _internal_set_client_sign2(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginC2GS.client_sign2)
}

// uint32 web_flag = 9;
inline void LoginC2GS::clear_web_flag() {
  _impl_.web_flag_ = 0u;
}
inline uint32_t LoginC2GS::_internal_web_flag() const {
  return _impl_.web_flag_;
}
inline uint32_t LoginC2GS::web_flag() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginC2GS.web_flag)
  return _internal_web_flag();
}
inline void LoginC2GS::_internal_set_web_flag(uint32_t value) {
  
  _impl_.web_flag_ = value;
}
inline void LoginC2GS::set_web_flag(uint32_t value) {
  _internal_set_web_flag(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginC2GS.web_flag)
}

// -------------------------------------------------------------------

// LoginGS2MS

// string name = 1;
inline void LoginGS2MS::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LoginGS2MS::name() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginGS2MS.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginGS2MS::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.login.LoginGS2MS.name)
}
inline std::string* LoginGS2MS::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pb.login.LoginGS2MS.name)
  return _s;
}
inline const std::string& LoginGS2MS::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LoginGS2MS::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginGS2MS::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginGS2MS::release_name() {
  // @@protoc_insertion_point(field_release:pb.login.LoginGS2MS.name)
  return _impl_.name_.Release();
}
inline void LoginGS2MS::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.login.LoginGS2MS.name)
}

// uint32 gateserver_id = 2;
inline void LoginGS2MS::clear_gateserver_id() {
  _impl_.gateserver_id_ = 0u;
}
inline uint32_t LoginGS2MS::_internal_gateserver_id() const {
  return _impl_.gateserver_id_;
}
inline uint32_t LoginGS2MS::gateserver_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginGS2MS.gateserver_id)
  return _internal_gateserver_id();
}
inline void LoginGS2MS::_internal_set_gateserver_id(uint32_t value) {
  
  _impl_.gateserver_id_ = value;
}
inline void LoginGS2MS::set_gateserver_id(uint32_t value) {
  _internal_set_gateserver_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginGS2MS.gateserver_id)
}

// uint32 global_mail_id = 3;
inline void LoginGS2MS::clear_global_mail_id() {
  _impl_.global_mail_id_ = 0u;
}
inline uint32_t LoginGS2MS::_internal_global_mail_id() const {
  return _impl_.global_mail_id_;
}
inline uint32_t LoginGS2MS::global_mail_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginGS2MS.global_mail_id)
  return _internal_global_mail_id();
}
inline void LoginGS2MS::_internal_set_global_mail_id(uint32_t value) {
  
  _impl_.global_mail_id_ = value;
}
inline void LoginGS2MS::set_global_mail_id(uint32_t value) {
  _internal_set_global_mail_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginGS2MS.global_mail_id)
}

// int64 register_time = 4;
inline void LoginGS2MS::clear_register_time() {
  _impl_.register_time_ = int64_t{0};
}
inline int64_t LoginGS2MS::_internal_register_time() const {
  return _impl_.register_time_;
}
inline int64_t LoginGS2MS::register_time() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginGS2MS.register_time)
  return _internal_register_time();
}
inline void LoginGS2MS::_internal_set_register_time(int64_t value) {
  
  _impl_.register_time_ = value;
}
inline void LoginGS2MS::set_register_time(int64_t value) {
  _internal_set_register_time(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginGS2MS.register_time)
}

// int64 user_id = 5;
inline void LoginGS2MS::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t LoginGS2MS::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t LoginGS2MS::user_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginGS2MS.user_id)
  return _internal_user_id();
}
inline void LoginGS2MS::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void LoginGS2MS::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginGS2MS.user_id)
}

// int64 igg_id = 6;
inline void LoginGS2MS::clear_igg_id() {
  _impl_.igg_id_ = int64_t{0};
}
inline int64_t LoginGS2MS::_internal_igg_id() const {
  return _impl_.igg_id_;
}
inline int64_t LoginGS2MS::igg_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginGS2MS.igg_id)
  return _internal_igg_id();
}
inline void LoginGS2MS::_internal_set_igg_id(int64_t value) {
  
  _impl_.igg_id_ = value;
}
inline void LoginGS2MS::set_igg_id(int64_t value) {
  _internal_set_igg_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginGS2MS.igg_id)
}

// uint32 game_id = 7;
inline void LoginGS2MS::clear_game_id() {
  _impl_.game_id_ = 0u;
}
inline uint32_t LoginGS2MS::_internal_game_id() const {
  return _impl_.game_id_;
}
inline uint32_t LoginGS2MS::game_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginGS2MS.game_id)
  return _internal_game_id();
}
inline void LoginGS2MS::_internal_set_game_id(uint32_t value) {
  
  _impl_.game_id_ = value;
}
inline void LoginGS2MS::set_game_id(uint32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginGS2MS.game_id)
}

// int64 sdk_gameid = 8;
inline void LoginGS2MS::clear_sdk_gameid() {
  _impl_.sdk_gameid_ = int64_t{0};
}
inline int64_t LoginGS2MS::_internal_sdk_gameid() const {
  return _impl_.sdk_gameid_;
}
inline int64_t LoginGS2MS::sdk_gameid() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginGS2MS.sdk_gameid)
  return _internal_sdk_gameid();
}
inline void LoginGS2MS::_internal_set_sdk_gameid(int64_t value) {
  
  _impl_.sdk_gameid_ = value;
}
inline void LoginGS2MS::set_sdk_gameid(int64_t value) {
  _internal_set_sdk_gameid(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginGS2MS.sdk_gameid)
}

// string state = 9;
inline void LoginGS2MS::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& LoginGS2MS::state() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginGS2MS.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginGS2MS::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.login.LoginGS2MS.state)
}
inline std::string* LoginGS2MS::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:pb.login.LoginGS2MS.state)
  return _s;
}
inline const std::string& LoginGS2MS::_internal_state() const {
  return _impl_.state_.Get();
}
inline void LoginGS2MS::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginGS2MS::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginGS2MS::release_state() {
  // @@protoc_insertion_point(field_release:pb.login.LoginGS2MS.state)
  return _impl_.state_.Release();
}
inline void LoginGS2MS::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.login.LoginGS2MS.state)
}

// -------------------------------------------------------------------

// LoginMS2GS

// int64 igg_id = 1;
inline void LoginMS2GS::clear_igg_id() {
  _impl_.igg_id_ = int64_t{0};
}
inline int64_t LoginMS2GS::_internal_igg_id() const {
  return _impl_.igg_id_;
}
inline int64_t LoginMS2GS::igg_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginMS2GS.igg_id)
  return _internal_igg_id();
}
inline void LoginMS2GS::_internal_set_igg_id(int64_t value) {
  
  _impl_.igg_id_ = value;
}
inline void LoginMS2GS::set_igg_id(int64_t value) {
  _internal_set_igg_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginMS2GS.igg_id)
}

// uint32 game_id = 2;
inline void LoginMS2GS::clear_game_id() {
  _impl_.game_id_ = 0u;
}
inline uint32_t LoginMS2GS::_internal_game_id() const {
  return _impl_.game_id_;
}
inline uint32_t LoginMS2GS::game_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginMS2GS.game_id)
  return _internal_game_id();
}
inline void LoginMS2GS::_internal_set_game_id(uint32_t value) {
  
  _impl_.game_id_ = value;
}
inline void LoginMS2GS::set_game_id(uint32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginMS2GS.game_id)
}

// int64 user_id = 3;
inline void LoginMS2GS::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t LoginMS2GS::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t LoginMS2GS::user_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginMS2GS.user_id)
  return _internal_user_id();
}
inline void LoginMS2GS::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void LoginMS2GS::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginMS2GS.user_id)
}

// int32 db_server_id = 4;
inline void LoginMS2GS::clear_db_server_id() {
  _impl_.db_server_id_ = 0;
}
inline int32_t LoginMS2GS::_internal_db_server_id() const {
  return _impl_.db_server_id_;
}
inline int32_t LoginMS2GS::db_server_id() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginMS2GS.db_server_id)
  return _internal_db_server_id();
}
inline void LoginMS2GS::_internal_set_db_server_id(int32_t value) {
  
  _impl_.db_server_id_ = value;
}
inline void LoginMS2GS::set_db_server_id(int32_t value) {
  _internal_set_db_server_id(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginMS2GS.db_server_id)
}

// int64 sdk_gameid = 5;
inline void LoginMS2GS::clear_sdk_gameid() {
  _impl_.sdk_gameid_ = int64_t{0};
}
inline int64_t LoginMS2GS::_internal_sdk_gameid() const {
  return _impl_.sdk_gameid_;
}
inline int64_t LoginMS2GS::sdk_gameid() const {
  // @@protoc_insertion_point(field_get:pb.login.LoginMS2GS.sdk_gameid)
  return _internal_sdk_gameid();
}
inline void LoginMS2GS::_internal_set_sdk_gameid(int64_t value) {
  
  _impl_.sdk_gameid_ = value;
}
inline void LoginMS2GS::set_sdk_gameid(int64_t value) {
  _internal_set_sdk_gameid(value);
  // @@protoc_insertion_point(field_set:pb.login.LoginMS2GS.sdk_gameid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace login
}  // namespace pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb::login::E_Login_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::login::E_Login_Result>() {
  return ::pb::login::E_Login_Result_descriptor();
}
template <> struct is_proto_enum< ::pb::login::E_Kick_Reason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::login::E_Kick_Reason>() {
  return ::pb::login::E_Kick_Reason_descriptor();
}
template <> struct is_proto_enum< ::pb::login::E_Login_CMD> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::login::E_Login_CMD>() {
  return ::pb::login::E_Login_CMD_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_login_2eproto
