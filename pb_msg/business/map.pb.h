// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_map_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_map_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_map_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_map_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_map_2eproto;
namespace pb {
namespace map {
class Base_Operate;
struct Base_OperateDefaultTypeInternal;
extern Base_OperateDefaultTypeInternal _Base_Operate_default_instance_;
class Building;
struct BuildingDefaultTypeInternal;
extern BuildingDefaultTypeInternal _Building_default_instance_;
class CampaignScale;
struct CampaignScaleDefaultTypeInternal;
extern CampaignScaleDefaultTypeInternal _CampaignScale_default_instance_;
class Choose_Country;
struct Choose_CountryDefaultTypeInternal;
extern Choose_CountryDefaultTypeInternal _Choose_Country_default_instance_;
class Collect_Map_OP;
struct Collect_Map_OPDefaultTypeInternal;
extern Collect_Map_OPDefaultTypeInternal _Collect_Map_OP_default_instance_;
class CombatantUser;
struct CombatantUserDefaultTypeInternal;
extern CombatantUserDefaultTypeInternal _CombatantUser_default_instance_;
class Country;
struct CountryDefaultTypeInternal;
extern CountryDefaultTypeInternal _Country_default_instance_;
class Country_Info;
struct Country_InfoDefaultTypeInternal;
extern Country_InfoDefaultTypeInternal _Country_Info_default_instance_;
class FieldScout;
struct FieldScoutDefaultTypeInternal;
extern FieldScoutDefaultTypeInternal _FieldScout_default_instance_;
class HEX;
struct HEXDefaultTypeInternal;
extern HEXDefaultTypeInternal _HEX_default_instance_;
class MapCampaign;
struct MapCampaignDefaultTypeInternal;
extern MapCampaignDefaultTypeInternal _MapCampaign_default_instance_;
class MapCampaignResp;
struct MapCampaignRespDefaultTypeInternal;
extern MapCampaignRespDefaultTypeInternal _MapCampaignResp_default_instance_;
class MapUserData;
struct MapUserDataDefaultTypeInternal;
extern MapUserDataDefaultTypeInternal _MapUserData_default_instance_;
class Map_Building;
struct Map_BuildingDefaultTypeInternal;
extern Map_BuildingDefaultTypeInternal _Map_Building_default_instance_;
class Map_Field;
struct Map_FieldDefaultTypeInternal;
extern Map_FieldDefaultTypeInternal _Map_Field_default_instance_;
class Map_Objs;
struct Map_ObjsDefaultTypeInternal;
extern Map_ObjsDefaultTypeInternal _Map_Objs_default_instance_;
class Map_RecoverField;
struct Map_RecoverFieldDefaultTypeInternal;
extern Map_RecoverFieldDefaultTypeInternal _Map_RecoverField_default_instance_;
class Map_Troop;
struct Map_TroopDefaultTypeInternal;
extern Map_TroopDefaultTypeInternal _Map_Troop_default_instance_;
class Map_WildBuilding;
struct Map_WildBuildingDefaultTypeInternal;
extern Map_WildBuildingDefaultTypeInternal _Map_WildBuilding_default_instance_;
class Map_WildNpcTroop;
struct Map_WildNpcTroopDefaultTypeInternal;
extern Map_WildNpcTroopDefaultTypeInternal _Map_WildNpcTroop_default_instance_;
class March_Path;
struct March_PathDefaultTypeInternal;
extern March_PathDefaultTypeInternal _March_Path_default_instance_;
class Migrate;
struct MigrateDefaultTypeInternal;
extern MigrateDefaultTypeInternal _Migrate_default_instance_;
class Move_City;
struct Move_CityDefaultTypeInternal;
extern Move_CityDefaultTypeInternal _Move_City_default_instance_;
class Obstacle_Path;
struct Obstacle_PathDefaultTypeInternal;
extern Obstacle_PathDefaultTypeInternal _Obstacle_Path_default_instance_;
class PrivateNpc_Troop;
struct PrivateNpc_TroopDefaultTypeInternal;
extern PrivateNpc_TroopDefaultTypeInternal _PrivateNpc_Troop_default_instance_;
class Private_Map_Objs;
struct Private_Map_ObjsDefaultTypeInternal;
extern Private_Map_ObjsDefaultTypeInternal _Private_Map_Objs_default_instance_;
class Ranking;
struct RankingDefaultTypeInternal;
extern RankingDefaultTypeInternal _Ranking_default_instance_;
class Rep_ClearScout;
struct Rep_ClearScoutDefaultTypeInternal;
extern Rep_ClearScoutDefaultTypeInternal _Rep_ClearScout_default_instance_;
class Rep_DeleteScout;
struct Rep_DeleteScoutDefaultTypeInternal;
extern Rep_DeleteScoutDefaultTypeInternal _Rep_DeleteScout_default_instance_;
class Rep_Scout;
struct Rep_ScoutDefaultTypeInternal;
extern Rep_ScoutDefaultTypeInternal _Rep_Scout_default_instance_;
class Rep_SearchMapObj;
struct Rep_SearchMapObjDefaultTypeInternal;
extern Rep_SearchMapObjDefaultTypeInternal _Rep_SearchMapObj_default_instance_;
class Rep_Timer_list;
struct Rep_Timer_listDefaultTypeInternal;
extern Rep_Timer_listDefaultTypeInternal _Rep_Timer_list_default_instance_;
class Req_ChgMap;
struct Req_ChgMapDefaultTypeInternal;
extern Req_ChgMapDefaultTypeInternal _Req_ChgMap_default_instance_;
class Req_Map_Chk_View;
struct Req_Map_Chk_ViewDefaultTypeInternal;
extern Req_Map_Chk_ViewDefaultTypeInternal _Req_Map_Chk_View_default_instance_;
class Req_Scout;
struct Req_ScoutDefaultTypeInternal;
extern Req_ScoutDefaultTypeInternal _Req_Scout_default_instance_;
class Req_SearchMapObj;
struct Req_SearchMapObjDefaultTypeInternal;
extern Req_SearchMapObjDefaultTypeInternal _Req_SearchMapObj_default_instance_;
class Resp_MapOperate;
struct Resp_MapOperateDefaultTypeInternal;
extern Resp_MapOperateDefaultTypeInternal _Resp_MapOperate_default_instance_;
class Resurgence;
struct ResurgenceDefaultTypeInternal;
extern ResurgenceDefaultTypeInternal _Resurgence_default_instance_;
class Robot_AI_Model;
struct Robot_AI_ModelDefaultTypeInternal;
extern Robot_AI_ModelDefaultTypeInternal _Robot_AI_Model_default_instance_;
class TimerTask;
struct TimerTaskDefaultTypeInternal;
extern TimerTaskDefaultTypeInternal _TimerTask_default_instance_;
class TroopScout;
struct TroopScoutDefaultTypeInternal;
extern TroopScoutDefaultTypeInternal _TroopScout_default_instance_;
class Troop_Map_OP;
struct Troop_Map_OPDefaultTypeInternal;
extern Troop_Map_OPDefaultTypeInternal _Troop_Map_OP_default_instance_;
class Troop_Path_Query;
struct Troop_Path_QueryDefaultTypeInternal;
extern Troop_Path_QueryDefaultTypeInternal _Troop_Path_Query_default_instance_;
}  // namespace map
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::map::Base_Operate* Arena::CreateMaybeMessage<::pb::map::Base_Operate>(Arena*);
template<> ::pb::map::Building* Arena::CreateMaybeMessage<::pb::map::Building>(Arena*);
template<> ::pb::map::CampaignScale* Arena::CreateMaybeMessage<::pb::map::CampaignScale>(Arena*);
template<> ::pb::map::Choose_Country* Arena::CreateMaybeMessage<::pb::map::Choose_Country>(Arena*);
template<> ::pb::map::Collect_Map_OP* Arena::CreateMaybeMessage<::pb::map::Collect_Map_OP>(Arena*);
template<> ::pb::map::CombatantUser* Arena::CreateMaybeMessage<::pb::map::CombatantUser>(Arena*);
template<> ::pb::map::Country* Arena::CreateMaybeMessage<::pb::map::Country>(Arena*);
template<> ::pb::map::Country_Info* Arena::CreateMaybeMessage<::pb::map::Country_Info>(Arena*);
template<> ::pb::map::FieldScout* Arena::CreateMaybeMessage<::pb::map::FieldScout>(Arena*);
template<> ::pb::map::HEX* Arena::CreateMaybeMessage<::pb::map::HEX>(Arena*);
template<> ::pb::map::MapCampaign* Arena::CreateMaybeMessage<::pb::map::MapCampaign>(Arena*);
template<> ::pb::map::MapCampaignResp* Arena::CreateMaybeMessage<::pb::map::MapCampaignResp>(Arena*);
template<> ::pb::map::MapUserData* Arena::CreateMaybeMessage<::pb::map::MapUserData>(Arena*);
template<> ::pb::map::Map_Building* Arena::CreateMaybeMessage<::pb::map::Map_Building>(Arena*);
template<> ::pb::map::Map_Field* Arena::CreateMaybeMessage<::pb::map::Map_Field>(Arena*);
template<> ::pb::map::Map_Objs* Arena::CreateMaybeMessage<::pb::map::Map_Objs>(Arena*);
template<> ::pb::map::Map_RecoverField* Arena::CreateMaybeMessage<::pb::map::Map_RecoverField>(Arena*);
template<> ::pb::map::Map_Troop* Arena::CreateMaybeMessage<::pb::map::Map_Troop>(Arena*);
template<> ::pb::map::Map_WildBuilding* Arena::CreateMaybeMessage<::pb::map::Map_WildBuilding>(Arena*);
template<> ::pb::map::Map_WildNpcTroop* Arena::CreateMaybeMessage<::pb::map::Map_WildNpcTroop>(Arena*);
template<> ::pb::map::March_Path* Arena::CreateMaybeMessage<::pb::map::March_Path>(Arena*);
template<> ::pb::map::Migrate* Arena::CreateMaybeMessage<::pb::map::Migrate>(Arena*);
template<> ::pb::map::Move_City* Arena::CreateMaybeMessage<::pb::map::Move_City>(Arena*);
template<> ::pb::map::Obstacle_Path* Arena::CreateMaybeMessage<::pb::map::Obstacle_Path>(Arena*);
template<> ::pb::map::PrivateNpc_Troop* Arena::CreateMaybeMessage<::pb::map::PrivateNpc_Troop>(Arena*);
template<> ::pb::map::Private_Map_Objs* Arena::CreateMaybeMessage<::pb::map::Private_Map_Objs>(Arena*);
template<> ::pb::map::Ranking* Arena::CreateMaybeMessage<::pb::map::Ranking>(Arena*);
template<> ::pb::map::Rep_ClearScout* Arena::CreateMaybeMessage<::pb::map::Rep_ClearScout>(Arena*);
template<> ::pb::map::Rep_DeleteScout* Arena::CreateMaybeMessage<::pb::map::Rep_DeleteScout>(Arena*);
template<> ::pb::map::Rep_Scout* Arena::CreateMaybeMessage<::pb::map::Rep_Scout>(Arena*);
template<> ::pb::map::Rep_SearchMapObj* Arena::CreateMaybeMessage<::pb::map::Rep_SearchMapObj>(Arena*);
template<> ::pb::map::Rep_Timer_list* Arena::CreateMaybeMessage<::pb::map::Rep_Timer_list>(Arena*);
template<> ::pb::map::Req_ChgMap* Arena::CreateMaybeMessage<::pb::map::Req_ChgMap>(Arena*);
template<> ::pb::map::Req_Map_Chk_View* Arena::CreateMaybeMessage<::pb::map::Req_Map_Chk_View>(Arena*);
template<> ::pb::map::Req_Scout* Arena::CreateMaybeMessage<::pb::map::Req_Scout>(Arena*);
template<> ::pb::map::Req_SearchMapObj* Arena::CreateMaybeMessage<::pb::map::Req_SearchMapObj>(Arena*);
template<> ::pb::map::Resp_MapOperate* Arena::CreateMaybeMessage<::pb::map::Resp_MapOperate>(Arena*);
template<> ::pb::map::Resurgence* Arena::CreateMaybeMessage<::pb::map::Resurgence>(Arena*);
template<> ::pb::map::Robot_AI_Model* Arena::CreateMaybeMessage<::pb::map::Robot_AI_Model>(Arena*);
template<> ::pb::map::TimerTask* Arena::CreateMaybeMessage<::pb::map::TimerTask>(Arena*);
template<> ::pb::map::TroopScout* Arena::CreateMaybeMessage<::pb::map::TroopScout>(Arena*);
template<> ::pb::map::Troop_Map_OP* Arena::CreateMaybeMessage<::pb::map::Troop_Map_OP>(Arena*);
template<> ::pb::map::Troop_Path_Query* Arena::CreateMaybeMessage<::pb::map::Troop_Path_Query>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {
namespace map {

enum E_Map_CMD : int {
  SynTroop = 0,
  Scout = 1,
  Attack_Occupy = 2,
  March = 3,
  Transfer = 4,
  Garrison = 5,
  WipeOut = 6,
  Reclamation = 7,
  Attack_City = 8,
  Suppress = 9,
  CreateBuilding = 10,
  Crusade = 11,
  BuildingLvUp = 12,
  CallRedif = 13,
  Rescue = 14,
  Annihilate = 15,
  Besiege = 16,
  QueryRoute = 20,
  ReqViewPos = 21,
  MapObjList = 22,
  SynNewBuilding = 23,
  SynBuilding = 24,
  DiscardField = 25,
  ChooseNation = 26,
  AbortMarch = 27,
  BackCity = 28,
  SpecialDefense = 29,
  CollectField = 100,
  CancelCollectField = 101,
  MoveCity = 102,
  CloseCity = 103,
  CancelCloseCity = 104,
  BackCityQuick = 105,
  EmergencyEvacuation = 106,
  CMD_MIGRATE = 107,
  Retracement = 108,
  CancelDiscardField = 109,
  PrivateMapObjList = 110,
  RepScout = 111,
  RepDeleteScout = 112,
  RepClearScout = 113,
  ReqMapInfo = 114,
  RespMapBuildingInfo = 115,
  RespMapCampaign = 116,
  QueryObstacleRoute = 117,
  CountryInfo = 118,
  ChooseCountry = 119,
  RespCampaignScale = 120,
  RespNpcBuildingOccupy = 121,
  ReqSearchMapObj = 122,
  CmdEnterMap = 123,
  RepTimerLst = 124,
  ReqChgMap = 125,
  RespDelPrivateMapObjList = 126,
  RespDelMap_RecoverField = 127,
  ReqMapChkView = 128,
  SynMapUserInfo = 129,
  RobotMarch = 180,
  RobotQueryRoute = 181,
  RobotOccupy = 182,
  RobotAtkCity = 183,
  RobotBackCity = 184,
  RobotAbortMarch = 185,
  RobotGarrison = 186,
  RobotAIModel = 187,
  RespMapOperate = 199,
  E_Map_CMD_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_Map_CMD_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_Map_CMD_IsValid(int value);
constexpr E_Map_CMD E_Map_CMD_MIN = SynTroop;
constexpr E_Map_CMD E_Map_CMD_MAX = RespMapOperate;
constexpr int E_Map_CMD_ARRAYSIZE = E_Map_CMD_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_Map_CMD_descriptor();
template<typename T>
inline const std::string& E_Map_CMD_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_Map_CMD>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_Map_CMD_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_Map_CMD_descriptor(), enum_t_value);
}
inline bool E_Map_CMD_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_Map_CMD* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_Map_CMD>(
    E_Map_CMD_descriptor(), name, value);
}
enum E_AIBehavior_Type : int {
  E_AIBehavior_None = 0,
  E_AIBehavior_Line = 1,
  E_AIBehavior_Round = 2,
  E_AIBehavior_Sector = 3,
  E_AIBehavior_Propel = 4,
  E_AIBehavior_Situ = 5,
  E_AIBehavior_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_AIBehavior_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_AIBehavior_Type_IsValid(int value);
constexpr E_AIBehavior_Type E_AIBehavior_Type_MIN = E_AIBehavior_None;
constexpr E_AIBehavior_Type E_AIBehavior_Type_MAX = E_AIBehavior_Situ;
constexpr int E_AIBehavior_Type_ARRAYSIZE = E_AIBehavior_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_AIBehavior_Type_descriptor();
template<typename T>
inline const std::string& E_AIBehavior_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_AIBehavior_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_AIBehavior_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_AIBehavior_Type_descriptor(), enum_t_value);
}
inline bool E_AIBehavior_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_AIBehavior_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_AIBehavior_Type>(
    E_AIBehavior_Type_descriptor(), name, value);
}
enum E_MapCampaignScale : int {
  E_MapCampaignScale_Small = 0,
  E_MapCampaignScale_Medium = 1,
  E_MapCampaignScale_Big = 2,
  E_MapCampaignScale_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E_MapCampaignScale_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E_MapCampaignScale_IsValid(int value);
constexpr E_MapCampaignScale E_MapCampaignScale_MIN = E_MapCampaignScale_Small;
constexpr E_MapCampaignScale E_MapCampaignScale_MAX = E_MapCampaignScale_Big;
constexpr int E_MapCampaignScale_ARRAYSIZE = E_MapCampaignScale_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E_MapCampaignScale_descriptor();
template<typename T>
inline const std::string& E_MapCampaignScale_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_MapCampaignScale>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_MapCampaignScale_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E_MapCampaignScale_descriptor(), enum_t_value);
}
inline bool E_MapCampaignScale_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_MapCampaignScale* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E_MapCampaignScale>(
    E_MapCampaignScale_descriptor(), name, value);
}
// ===================================================================

class Base_Operate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Base_Operate) */ {
 public:
  inline Base_Operate() : Base_Operate(nullptr) {}
  ~Base_Operate() override;
  explicit PROTOBUF_CONSTEXPR Base_Operate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Base_Operate(const Base_Operate& from);
  Base_Operate(Base_Operate&& from) noexcept
    : Base_Operate() {
    *this = ::std::move(from);
  }

  inline Base_Operate& operator=(const Base_Operate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Base_Operate& operator=(Base_Operate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Base_Operate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Base_Operate* internal_default_instance() {
    return reinterpret_cast<const Base_Operate*>(
               &_Base_Operate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Base_Operate& a, Base_Operate& b) {
    a.Swap(&b);
  }
  inline void Swap(Base_Operate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Base_Operate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Base_Operate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Base_Operate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Base_Operate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Base_Operate& from) {
    Base_Operate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Base_Operate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Base_Operate";
  }
  protected:
  explicit Base_Operate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // .pb.map.E_Map_CMD cmd = 1;
  void clear_cmd();
  ::pb::map::E_Map_CMD cmd() const;
  void set_cmd(::pb::map::E_Map_CMD value);
  private:
  ::pb::map::E_Map_CMD _internal_cmd() const;
  void _internal_set_cmd(::pb::map::E_Map_CMD value);
  public:

  // uint32 error_code = 2;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Base_Operate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int cmd_;
    uint32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class HEX final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.HEX) */ {
 public:
  inline HEX() : HEX(nullptr) {}
  ~HEX() override;
  explicit PROTOBUF_CONSTEXPR HEX(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HEX(const HEX& from);
  HEX(HEX&& from) noexcept
    : HEX() {
    *this = ::std::move(from);
  }

  inline HEX& operator=(const HEX& from) {
    CopyFrom(from);
    return *this;
  }
  inline HEX& operator=(HEX&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HEX& default_instance() {
    return *internal_default_instance();
  }
  static inline const HEX* internal_default_instance() {
    return reinterpret_cast<const HEX*>(
               &_HEX_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HEX& a, HEX& b) {
    a.Swap(&b);
  }
  inline void Swap(HEX* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HEX* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HEX* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HEX>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HEX& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HEX& from) {
    HEX::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HEX* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.HEX";
  }
  protected:
  explicit HEX(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kRFieldNumber = 2,
  };
  // int32 q = 1;
  void clear_q();
  int32_t q() const;
  void set_q(int32_t value);
  private:
  int32_t _internal_q() const;
  void _internal_set_q(int32_t value);
  public:

  // int32 r = 2;
  void clear_r();
  int32_t r() const;
  void set_r(int32_t value);
  private:
  int32_t _internal_r() const;
  void _internal_set_r(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.HEX)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t q_;
    int32_t r_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Resp_MapOperate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Resp_MapOperate) */ {
 public:
  inline Resp_MapOperate() : Resp_MapOperate(nullptr) {}
  ~Resp_MapOperate() override;
  explicit PROTOBUF_CONSTEXPR Resp_MapOperate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Resp_MapOperate(const Resp_MapOperate& from);
  Resp_MapOperate(Resp_MapOperate&& from) noexcept
    : Resp_MapOperate() {
    *this = ::std::move(from);
  }

  inline Resp_MapOperate& operator=(const Resp_MapOperate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resp_MapOperate& operator=(Resp_MapOperate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resp_MapOperate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Resp_MapOperate* internal_default_instance() {
    return reinterpret_cast<const Resp_MapOperate*>(
               &_Resp_MapOperate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Resp_MapOperate& a, Resp_MapOperate& b) {
    a.Swap(&b);
  }
  inline void Swap(Resp_MapOperate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resp_MapOperate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Resp_MapOperate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Resp_MapOperate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Resp_MapOperate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Resp_MapOperate& from) {
    Resp_MapOperate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resp_MapOperate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Resp_MapOperate";
  }
  protected:
  explicit Resp_MapOperate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTroopIdFieldNumber = 1,
    kOpFieldNumber = 2,
  };
  // int64 troop_id = 1;
  void clear_troop_id();
  int64_t troop_id() const;
  void set_troop_id(int64_t value);
  private:
  int64_t _internal_troop_id() const;
  void _internal_set_troop_id(int64_t value);
  public:

  // .pb.map.E_Map_CMD op = 2;
  void clear_op();
  ::pb::map::E_Map_CMD op() const;
  void set_op(::pb::map::E_Map_CMD value);
  private:
  ::pb::map::E_Map_CMD _internal_op() const;
  void _internal_set_op(::pb::map::E_Map_CMD value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Resp_MapOperate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t troop_id_;
    int op_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Building final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Building) */ {
 public:
  inline Building() : Building(nullptr) {}
  ~Building() override;
  explicit PROTOBUF_CONSTEXPR Building(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Building(const Building& from);
  Building(Building&& from) noexcept
    : Building() {
    *this = ::std::move(from);
  }

  inline Building& operator=(const Building& from) {
    CopyFrom(from);
    return *this;
  }
  inline Building& operator=(Building&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Building& default_instance() {
    return *internal_default_instance();
  }
  static inline const Building* internal_default_instance() {
    return reinterpret_cast<const Building*>(
               &_Building_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Building& a, Building& b) {
    a.Swap(&b);
  }
  inline void Swap(Building* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Building* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Building* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Building>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Building& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Building& from) {
    Building::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Building* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Building";
  }
  protected:
  explicit Building(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 4,
    kIdxFieldNumber = 1,
    kTypeFieldNumber = 2,
    kLevelFieldNumber = 3,
  };
  // .pb.map.HEX pos = 4;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // uint32 idx = 1;
  void clear_idx();
  uint32_t idx() const;
  void set_idx(uint32_t value);
  private:
  uint32_t _internal_idx() const;
  void _internal_set_idx(uint32_t value);
  public:

  // uint32 type = 2;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 level = 3;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Building)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* pos_;
    uint32_t idx_;
    uint32_t type_;
    uint32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Troop_Map_OP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Troop_Map_OP) */ {
 public:
  inline Troop_Map_OP() : Troop_Map_OP(nullptr) {}
  ~Troop_Map_OP() override;
  explicit PROTOBUF_CONSTEXPR Troop_Map_OP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Troop_Map_OP(const Troop_Map_OP& from);
  Troop_Map_OP(Troop_Map_OP&& from) noexcept
    : Troop_Map_OP() {
    *this = ::std::move(from);
  }

  inline Troop_Map_OP& operator=(const Troop_Map_OP& from) {
    CopyFrom(from);
    return *this;
  }
  inline Troop_Map_OP& operator=(Troop_Map_OP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Troop_Map_OP& default_instance() {
    return *internal_default_instance();
  }
  static inline const Troop_Map_OP* internal_default_instance() {
    return reinterpret_cast<const Troop_Map_OP*>(
               &_Troop_Map_OP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Troop_Map_OP& a, Troop_Map_OP& b) {
    a.Swap(&b);
  }
  inline void Swap(Troop_Map_OP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Troop_Map_OP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Troop_Map_OP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Troop_Map_OP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Troop_Map_OP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Troop_Map_OP& from) {
    Troop_Map_OP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Troop_Map_OP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Troop_Map_OP";
  }
  protected:
  explicit Troop_Map_OP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndPosFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
    kIdxTroopFieldNumber = 3,
    kCountFieldNumber = 4,
    kIsAutoreturnFieldNumber = 5,
    kTargetTypeFieldNumber = 6,
  };
  // .pb.map.HEX end_pos = 2;
  bool has_end_pos() const;
  private:
  bool _internal_has_end_pos() const;
  public:
  void clear_end_pos();
  const ::pb::map::HEX& end_pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_end_pos();
  ::pb::map::HEX* mutable_end_pos();
  void set_allocated_end_pos(::pb::map::HEX* end_pos);
  private:
  const ::pb::map::HEX& _internal_end_pos() const;
  ::pb::map::HEX* _internal_mutable_end_pos();
  public:
  void unsafe_arena_set_allocated_end_pos(
      ::pb::map::HEX* end_pos);
  ::pb::map::HEX* unsafe_arena_release_end_pos();

  // uint32 error_code = 1;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // uint32 idx_troop = 3;
  void clear_idx_troop();
  uint32_t idx_troop() const;
  void set_idx_troop(uint32_t value);
  private:
  uint32_t _internal_idx_troop() const;
  void _internal_set_idx_troop(uint32_t value);
  public:

  // uint32 count = 4;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // uint32 is_autoreturn = 5;
  void clear_is_autoreturn();
  uint32_t is_autoreturn() const;
  void set_is_autoreturn(uint32_t value);
  private:
  uint32_t _internal_is_autoreturn() const;
  void _internal_set_is_autoreturn(uint32_t value);
  public:

  // uint32 target_type = 6;
  void clear_target_type();
  uint32_t target_type() const;
  void set_target_type(uint32_t value);
  private:
  uint32_t _internal_target_type() const;
  void _internal_set_target_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Troop_Map_OP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* end_pos_;
    uint32_t error_code_;
    uint32_t idx_troop_;
    uint32_t count_;
    uint32_t is_autoreturn_;
    uint32_t target_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Robot_AI_Model final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Robot_AI_Model) */ {
 public:
  inline Robot_AI_Model() : Robot_AI_Model(nullptr) {}
  ~Robot_AI_Model() override;
  explicit PROTOBUF_CONSTEXPR Robot_AI_Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_AI_Model(const Robot_AI_Model& from);
  Robot_AI_Model(Robot_AI_Model&& from) noexcept
    : Robot_AI_Model() {
    *this = ::std::move(from);
  }

  inline Robot_AI_Model& operator=(const Robot_AI_Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_AI_Model& operator=(Robot_AI_Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_AI_Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_AI_Model* internal_default_instance() {
    return reinterpret_cast<const Robot_AI_Model*>(
               &_Robot_AI_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Robot_AI_Model& a, Robot_AI_Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_AI_Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_AI_Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_AI_Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_AI_Model>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_AI_Model& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Robot_AI_Model& from) {
    Robot_AI_Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_AI_Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Robot_AI_Model";
  }
  protected:
  explicit Robot_AI_Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterPosFieldNumber = 4,
    kStartPosFieldNumber = 5,
    kEndPosFieldNumber = 6,
    kErrorCodeFieldNumber = 1,
    kIdxTroopFieldNumber = 2,
    kAiTypeFieldNumber = 3,
    kAlterRadiusFieldNumber = 7,
    kIsClockwiseFieldNumber = 8,
  };
  // .pb.map.HEX center_pos = 4;
  bool has_center_pos() const;
  private:
  bool _internal_has_center_pos() const;
  public:
  void clear_center_pos();
  const ::pb::map::HEX& center_pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_center_pos();
  ::pb::map::HEX* mutable_center_pos();
  void set_allocated_center_pos(::pb::map::HEX* center_pos);
  private:
  const ::pb::map::HEX& _internal_center_pos() const;
  ::pb::map::HEX* _internal_mutable_center_pos();
  public:
  void unsafe_arena_set_allocated_center_pos(
      ::pb::map::HEX* center_pos);
  ::pb::map::HEX* unsafe_arena_release_center_pos();

  // .pb.map.HEX start_pos = 5;
  bool has_start_pos() const;
  private:
  bool _internal_has_start_pos() const;
  public:
  void clear_start_pos();
  const ::pb::map::HEX& start_pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_start_pos();
  ::pb::map::HEX* mutable_start_pos();
  void set_allocated_start_pos(::pb::map::HEX* start_pos);
  private:
  const ::pb::map::HEX& _internal_start_pos() const;
  ::pb::map::HEX* _internal_mutable_start_pos();
  public:
  void unsafe_arena_set_allocated_start_pos(
      ::pb::map::HEX* start_pos);
  ::pb::map::HEX* unsafe_arena_release_start_pos();

  // .pb.map.HEX end_pos = 6;
  bool has_end_pos() const;
  private:
  bool _internal_has_end_pos() const;
  public:
  void clear_end_pos();
  const ::pb::map::HEX& end_pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_end_pos();
  ::pb::map::HEX* mutable_end_pos();
  void set_allocated_end_pos(::pb::map::HEX* end_pos);
  private:
  const ::pb::map::HEX& _internal_end_pos() const;
  ::pb::map::HEX* _internal_mutable_end_pos();
  public:
  void unsafe_arena_set_allocated_end_pos(
      ::pb::map::HEX* end_pos);
  ::pb::map::HEX* unsafe_arena_release_end_pos();

  // uint32 error_code = 1;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // uint32 idx_troop = 2;
  void clear_idx_troop();
  uint32_t idx_troop() const;
  void set_idx_troop(uint32_t value);
  private:
  uint32_t _internal_idx_troop() const;
  void _internal_set_idx_troop(uint32_t value);
  public:

  // .pb.map.E_AIBehavior_Type ai_type = 3;
  void clear_ai_type();
  ::pb::map::E_AIBehavior_Type ai_type() const;
  void set_ai_type(::pb::map::E_AIBehavior_Type value);
  private:
  ::pb::map::E_AIBehavior_Type _internal_ai_type() const;
  void _internal_set_ai_type(::pb::map::E_AIBehavior_Type value);
  public:

  // int32 alter_radius = 7;
  void clear_alter_radius();
  int32_t alter_radius() const;
  void set_alter_radius(int32_t value);
  private:
  int32_t _internal_alter_radius() const;
  void _internal_set_alter_radius(int32_t value);
  public:

  // bool is_clockwise = 8;
  void clear_is_clockwise();
  bool is_clockwise() const;
  void set_is_clockwise(bool value);
  private:
  bool _internal_is_clockwise() const;
  void _internal_set_is_clockwise(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Robot_AI_Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* center_pos_;
    ::pb::map::HEX* start_pos_;
    ::pb::map::HEX* end_pos_;
    uint32_t error_code_;
    uint32_t idx_troop_;
    int ai_type_;
    int32_t alter_radius_;
    bool is_clockwise_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Troop_Path_Query final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Troop_Path_Query) */ {
 public:
  inline Troop_Path_Query() : Troop_Path_Query(nullptr) {}
  ~Troop_Path_Query() override;
  explicit PROTOBUF_CONSTEXPR Troop_Path_Query(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Troop_Path_Query(const Troop_Path_Query& from);
  Troop_Path_Query(Troop_Path_Query&& from) noexcept
    : Troop_Path_Query() {
    *this = ::std::move(from);
  }

  inline Troop_Path_Query& operator=(const Troop_Path_Query& from) {
    CopyFrom(from);
    return *this;
  }
  inline Troop_Path_Query& operator=(Troop_Path_Query&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Troop_Path_Query& default_instance() {
    return *internal_default_instance();
  }
  static inline const Troop_Path_Query* internal_default_instance() {
    return reinterpret_cast<const Troop_Path_Query*>(
               &_Troop_Path_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Troop_Path_Query& a, Troop_Path_Query& b) {
    a.Swap(&b);
  }
  inline void Swap(Troop_Path_Query* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Troop_Path_Query* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Troop_Path_Query* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Troop_Path_Query>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Troop_Path_Query& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Troop_Path_Query& from) {
    Troop_Path_Query::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Troop_Path_Query* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Troop_Path_Query";
  }
  protected:
  explicit Troop_Path_Query(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndPosFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
    kIdxTroopFieldNumber = 3,
    kSubCmdFieldNumber = 4,
  };
  // .pb.map.HEX end_pos = 2;
  bool has_end_pos() const;
  private:
  bool _internal_has_end_pos() const;
  public:
  void clear_end_pos();
  const ::pb::map::HEX& end_pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_end_pos();
  ::pb::map::HEX* mutable_end_pos();
  void set_allocated_end_pos(::pb::map::HEX* end_pos);
  private:
  const ::pb::map::HEX& _internal_end_pos() const;
  ::pb::map::HEX* _internal_mutable_end_pos();
  public:
  void unsafe_arena_set_allocated_end_pos(
      ::pb::map::HEX* end_pos);
  ::pb::map::HEX* unsafe_arena_release_end_pos();

  // uint32 error_code = 1;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // uint32 idx_troop = 3;
  void clear_idx_troop();
  uint32_t idx_troop() const;
  void set_idx_troop(uint32_t value);
  private:
  uint32_t _internal_idx_troop() const;
  void _internal_set_idx_troop(uint32_t value);
  public:

  // .pb.map.E_Map_CMD sub_cmd = 4;
  void clear_sub_cmd();
  ::pb::map::E_Map_CMD sub_cmd() const;
  void set_sub_cmd(::pb::map::E_Map_CMD value);
  private:
  ::pb::map::E_Map_CMD _internal_sub_cmd() const;
  void _internal_set_sub_cmd(::pb::map::E_Map_CMD value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Troop_Path_Query)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* end_pos_;
    uint32_t error_code_;
    uint32_t idx_troop_;
    int sub_cmd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Obstacle_Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Obstacle_Path) */ {
 public:
  inline Obstacle_Path() : Obstacle_Path(nullptr) {}
  ~Obstacle_Path() override;
  explicit PROTOBUF_CONSTEXPR Obstacle_Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Obstacle_Path(const Obstacle_Path& from);
  Obstacle_Path(Obstacle_Path&& from) noexcept
    : Obstacle_Path() {
    *this = ::std::move(from);
  }

  inline Obstacle_Path& operator=(const Obstacle_Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Obstacle_Path& operator=(Obstacle_Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Obstacle_Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Obstacle_Path* internal_default_instance() {
    return reinterpret_cast<const Obstacle_Path*>(
               &_Obstacle_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Obstacle_Path& a, Obstacle_Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Obstacle_Path* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Obstacle_Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Obstacle_Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Obstacle_Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Obstacle_Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Obstacle_Path& from) {
    Obstacle_Path::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Obstacle_Path* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Obstacle_Path";
  }
  protected:
  explicit Obstacle_Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecStartobsFieldNumber = 3,
    kVecEndobsFieldNumber = 4,
    kObstaclePtFieldNumber = 2,
    kTroopIdFieldNumber = 1,
  };
  // repeated .pb.map.HEX vec_startobs = 3;
  int vec_startobs_size() const;
  private:
  int _internal_vec_startobs_size() const;
  public:
  void clear_vec_startobs();
  ::pb::map::HEX* mutable_vec_startobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >*
      mutable_vec_startobs();
  private:
  const ::pb::map::HEX& _internal_vec_startobs(int index) const;
  ::pb::map::HEX* _internal_add_vec_startobs();
  public:
  const ::pb::map::HEX& vec_startobs(int index) const;
  ::pb::map::HEX* add_vec_startobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >&
      vec_startobs() const;

  // repeated .pb.map.HEX vec_endobs = 4;
  int vec_endobs_size() const;
  private:
  int _internal_vec_endobs_size() const;
  public:
  void clear_vec_endobs();
  ::pb::map::HEX* mutable_vec_endobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >*
      mutable_vec_endobs();
  private:
  const ::pb::map::HEX& _internal_vec_endobs(int index) const;
  ::pb::map::HEX* _internal_add_vec_endobs();
  public:
  const ::pb::map::HEX& vec_endobs(int index) const;
  ::pb::map::HEX* add_vec_endobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >&
      vec_endobs() const;

  // .pb.map.HEX obstacle_pt = 2;
  bool has_obstacle_pt() const;
  private:
  bool _internal_has_obstacle_pt() const;
  public:
  void clear_obstacle_pt();
  const ::pb::map::HEX& obstacle_pt() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_obstacle_pt();
  ::pb::map::HEX* mutable_obstacle_pt();
  void set_allocated_obstacle_pt(::pb::map::HEX* obstacle_pt);
  private:
  const ::pb::map::HEX& _internal_obstacle_pt() const;
  ::pb::map::HEX* _internal_mutable_obstacle_pt();
  public:
  void unsafe_arena_set_allocated_obstacle_pt(
      ::pb::map::HEX* obstacle_pt);
  ::pb::map::HEX* unsafe_arena_release_obstacle_pt();

  // int32 troop_id = 1;
  void clear_troop_id();
  int32_t troop_id() const;
  void set_troop_id(int32_t value);
  private:
  int32_t _internal_troop_id() const;
  void _internal_set_troop_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Obstacle_Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX > vec_startobs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX > vec_endobs_;
    ::pb::map::HEX* obstacle_pt_;
    int32_t troop_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class March_Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.March_Path) */ {
 public:
  inline March_Path() : March_Path(nullptr) {}
  ~March_Path() override;
  explicit PROTOBUF_CONSTEXPR March_Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  March_Path(const March_Path& from);
  March_Path(March_Path&& from) noexcept
    : March_Path() {
    *this = ::std::move(from);
  }

  inline March_Path& operator=(const March_Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline March_Path& operator=(March_Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const March_Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const March_Path* internal_default_instance() {
    return reinterpret_cast<const March_Path*>(
               &_March_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(March_Path& a, March_Path& b) {
    a.Swap(&b);
  }
  inline void Swap(March_Path* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(March_Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  March_Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<March_Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const March_Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const March_Path& from) {
    March_Path::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(March_Path* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.March_Path";
  }
  protected:
  explicit March_Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecPathFieldNumber = 7,
    kNameFieldNumber = 4,
    kTroopIdFieldNumber = 1,
    kHeroIdFieldNumber = 2,
    kSoldierIdFieldNumber = 3,
    kIdxTroopFieldNumber = 5,
    kEndTimeFieldNumber = 8,
    kSpeedFieldNumber = 6,
  };
  // repeated .pb.map.HEX vec_path = 7;
  int vec_path_size() const;
  private:
  int _internal_vec_path_size() const;
  public:
  void clear_vec_path();
  ::pb::map::HEX* mutable_vec_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >*
      mutable_vec_path();
  private:
  const ::pb::map::HEX& _internal_vec_path(int index) const;
  ::pb::map::HEX* _internal_add_vec_path();
  public:
  const ::pb::map::HEX& vec_path(int index) const;
  ::pb::map::HEX* add_vec_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >&
      vec_path() const;

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 troop_id = 1;
  void clear_troop_id();
  int32_t troop_id() const;
  void set_troop_id(int32_t value);
  private:
  int32_t _internal_troop_id() const;
  void _internal_set_troop_id(int32_t value);
  public:

  // uint32 hero_id = 2;
  void clear_hero_id();
  uint32_t hero_id() const;
  void set_hero_id(uint32_t value);
  private:
  uint32_t _internal_hero_id() const;
  void _internal_set_hero_id(uint32_t value);
  public:

  // uint32 soldier_id = 3;
  void clear_soldier_id();
  uint32_t soldier_id() const;
  void set_soldier_id(uint32_t value);
  private:
  uint32_t _internal_soldier_id() const;
  void _internal_set_soldier_id(uint32_t value);
  public:

  // uint32 idx_troop = 5;
  void clear_idx_troop();
  uint32_t idx_troop() const;
  void set_idx_troop(uint32_t value);
  private:
  uint32_t _internal_idx_troop() const;
  void _internal_set_idx_troop(uint32_t value);
  public:

  // int64 end_time = 8;
  void clear_end_time();
  int64_t end_time() const;
  void set_end_time(int64_t value);
  private:
  int64_t _internal_end_time() const;
  void _internal_set_end_time(int64_t value);
  public:

  // uint32 speed = 6;
  void clear_speed();
  uint32_t speed() const;
  void set_speed(uint32_t value);
  private:
  uint32_t _internal_speed() const;
  void _internal_set_speed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.March_Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX > vec_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t troop_id_;
    uint32_t hero_id_;
    uint32_t soldier_id_;
    uint32_t idx_troop_;
    int64_t end_time_;
    uint32_t speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Ranking final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Ranking) */ {
 public:
  inline Ranking() : Ranking(nullptr) {}
  ~Ranking() override;
  explicit PROTOBUF_CONSTEXPR Ranking(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ranking(const Ranking& from);
  Ranking(Ranking&& from) noexcept
    : Ranking() {
    *this = ::std::move(from);
  }

  inline Ranking& operator=(const Ranking& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ranking& operator=(Ranking&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ranking& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ranking* internal_default_instance() {
    return reinterpret_cast<const Ranking*>(
               &_Ranking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Ranking& a, Ranking& b) {
    a.Swap(&b);
  }
  inline void Swap(Ranking* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ranking* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ranking* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ranking>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ranking& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ranking& from) {
    Ranking::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ranking* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Ranking";
  }
  protected:
  explicit Ranking(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string user_name = 1;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // uint32 value = 2;
  void clear_value();
  uint32_t value() const;
  void set_value(uint32_t value);
  private:
  uint32_t _internal_value() const;
  void _internal_set_value(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Ranking)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    uint32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Map_Building final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Map_Building) */ {
 public:
  inline Map_Building() : Map_Building(nullptr) {}
  ~Map_Building() override;
  explicit PROTOBUF_CONSTEXPR Map_Building(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_Building(const Map_Building& from);
  Map_Building(Map_Building&& from) noexcept
    : Map_Building() {
    *this = ::std::move(from);
  }

  inline Map_Building& operator=(const Map_Building& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_Building& operator=(Map_Building&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_Building& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_Building* internal_default_instance() {
    return reinterpret_cast<const Map_Building*>(
               &_Map_Building_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Map_Building& a, Map_Building& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_Building* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_Building* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_Building* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_Building>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_Building& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Map_Building& from) {
    Map_Building::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_Building* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Map_Building";
  }
  protected:
  explicit Map_Building(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstKillTopThreeFieldNumber = 12,
    kFirstSiegeTopThreeFieldNumber = 13,
    kNameFieldNumber = 16,
    kPosFieldNumber = 3,
    kOwnerIdFieldNumber = 1,
    kSkinIdFieldNumber = 2,
    kTypeFieldNumber = 4,
    kIdFieldNumber = 5,
    kLifeFieldNumber = 6,
    kLifeMaxFieldNumber = 7,
    kTroopNumFieldNumber = 8,
    kResetTimeFieldNumber = 9,
    kAvoidBattleTimeFieldNumber = 10,
    kCloseCityTimeFieldNumber = 11,
    kGuildidFieldNumber = 14,
    kLevelFieldNumber = 15,
    kBuildingeyeFieldNumber = 17,
    kProtectFlagFieldNumber = 18,
  };
  // repeated .pb.map.Ranking first_kill_top_three = 12;
  int first_kill_top_three_size() const;
  private:
  int _internal_first_kill_top_three_size() const;
  public:
  void clear_first_kill_top_three();
  ::pb::map::Ranking* mutable_first_kill_top_three(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Ranking >*
      mutable_first_kill_top_three();
  private:
  const ::pb::map::Ranking& _internal_first_kill_top_three(int index) const;
  ::pb::map::Ranking* _internal_add_first_kill_top_three();
  public:
  const ::pb::map::Ranking& first_kill_top_three(int index) const;
  ::pb::map::Ranking* add_first_kill_top_three();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Ranking >&
      first_kill_top_three() const;

  // repeated .pb.map.Ranking first_siege_top_three = 13;
  int first_siege_top_three_size() const;
  private:
  int _internal_first_siege_top_three_size() const;
  public:
  void clear_first_siege_top_three();
  ::pb::map::Ranking* mutable_first_siege_top_three(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Ranking >*
      mutable_first_siege_top_three();
  private:
  const ::pb::map::Ranking& _internal_first_siege_top_three(int index) const;
  ::pb::map::Ranking* _internal_add_first_siege_top_three();
  public:
  const ::pb::map::Ranking& first_siege_top_three(int index) const;
  ::pb::map::Ranking* add_first_siege_top_three();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Ranking >&
      first_siege_top_three() const;

  // string name = 16;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .pb.map.HEX pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // int64 owner_id = 1;
  void clear_owner_id();
  int64_t owner_id() const;
  void set_owner_id(int64_t value);
  private:
  int64_t _internal_owner_id() const;
  void _internal_set_owner_id(int64_t value);
  public:

  // uint32 skin_id = 2;
  void clear_skin_id();
  uint32_t skin_id() const;
  void set_skin_id(uint32_t value);
  private:
  uint32_t _internal_skin_id() const;
  void _internal_set_skin_id(uint32_t value);
  public:

  // uint32 type = 4;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // int32 id = 5;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // uint32 life = 6;
  void clear_life();
  uint32_t life() const;
  void set_life(uint32_t value);
  private:
  uint32_t _internal_life() const;
  void _internal_set_life(uint32_t value);
  public:

  // uint32 life_max = 7;
  void clear_life_max();
  uint32_t life_max() const;
  void set_life_max(uint32_t value);
  private:
  uint32_t _internal_life_max() const;
  void _internal_set_life_max(uint32_t value);
  public:

  // uint32 troop_num = 8;
  void clear_troop_num();
  uint32_t troop_num() const;
  void set_troop_num(uint32_t value);
  private:
  uint32_t _internal_troop_num() const;
  void _internal_set_troop_num(uint32_t value);
  public:

  // int64 reset_time = 9;
  void clear_reset_time();
  int64_t reset_time() const;
  void set_reset_time(int64_t value);
  private:
  int64_t _internal_reset_time() const;
  void _internal_set_reset_time(int64_t value);
  public:

  // int64 avoid_battle_time = 10;
  void clear_avoid_battle_time();
  int64_t avoid_battle_time() const;
  void set_avoid_battle_time(int64_t value);
  private:
  int64_t _internal_avoid_battle_time() const;
  void _internal_set_avoid_battle_time(int64_t value);
  public:

  // int64 close_city_time = 11;
  void clear_close_city_time();
  int64_t close_city_time() const;
  void set_close_city_time(int64_t value);
  private:
  int64_t _internal_close_city_time() const;
  void _internal_set_close_city_time(int64_t value);
  public:

  // uint32 guildid = 14;
  void clear_guildid();
  uint32_t guildid() const;
  void set_guildid(uint32_t value);
  private:
  uint32_t _internal_guildid() const;
  void _internal_set_guildid(uint32_t value);
  public:

  // uint32 level = 15;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // uint32 buildingeye = 17;
  void clear_buildingeye();
  uint32_t buildingeye() const;
  void set_buildingeye(uint32_t value);
  private:
  uint32_t _internal_buildingeye() const;
  void _internal_set_buildingeye(uint32_t value);
  public:

  // uint32 protect_flag = 18;
  void clear_protect_flag();
  uint32_t protect_flag() const;
  void set_protect_flag(uint32_t value);
  private:
  uint32_t _internal_protect_flag() const;
  void _internal_set_protect_flag(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Map_Building)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Ranking > first_kill_top_three_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Ranking > first_siege_top_three_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::pb::map::HEX* pos_;
    int64_t owner_id_;
    uint32_t skin_id_;
    uint32_t type_;
    int32_t id_;
    uint32_t life_;
    uint32_t life_max_;
    uint32_t troop_num_;
    int64_t reset_time_;
    int64_t avoid_battle_time_;
    int64_t close_city_time_;
    uint32_t guildid_;
    uint32_t level_;
    uint32_t buildingeye_;
    uint32_t protect_flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Map_Troop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Map_Troop) */ {
 public:
  inline Map_Troop() : Map_Troop(nullptr) {}
  ~Map_Troop() override;
  explicit PROTOBUF_CONSTEXPR Map_Troop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_Troop(const Map_Troop& from);
  Map_Troop(Map_Troop&& from) noexcept
    : Map_Troop() {
    *this = ::std::move(from);
  }

  inline Map_Troop& operator=(const Map_Troop& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_Troop& operator=(Map_Troop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_Troop& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_Troop* internal_default_instance() {
    return reinterpret_cast<const Map_Troop*>(
               &_Map_Troop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Map_Troop& a, Map_Troop& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_Troop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_Troop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_Troop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_Troop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_Troop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Map_Troop& from) {
    Map_Troop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_Troop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Map_Troop";
  }
  protected:
  explicit Map_Troop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecPathFieldNumber = 9,
    kPosFieldNumber = 4,
    kOwnerIdFieldNumber = 2,
    kTroopIdFieldNumber = 1,
    kSoldierIdFieldNumber = 3,
    kStatusFieldNumber = 5,
    kIdxCurpathFieldNumber = 6,
    kTimeFieldNumber = 7,
    kSpeedFieldNumber = 8,
    kEndTimeFieldNumber = 10,
    kMoraleFieldNumber = 11,
    kProtectFlagFieldNumber = 12,
    kDstTroopIdFieldNumber = 13,
  };
  // repeated .pb.map.HEX vec_path = 9;
  int vec_path_size() const;
  private:
  int _internal_vec_path_size() const;
  public:
  void clear_vec_path();
  ::pb::map::HEX* mutable_vec_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >*
      mutable_vec_path();
  private:
  const ::pb::map::HEX& _internal_vec_path(int index) const;
  ::pb::map::HEX* _internal_add_vec_path();
  public:
  const ::pb::map::HEX& vec_path(int index) const;
  ::pb::map::HEX* add_vec_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >&
      vec_path() const;

  // .pb.map.HEX pos = 4;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // int64 owner_id = 2;
  void clear_owner_id();
  int64_t owner_id() const;
  void set_owner_id(int64_t value);
  private:
  int64_t _internal_owner_id() const;
  void _internal_set_owner_id(int64_t value);
  public:

  // int32 troop_id = 1;
  void clear_troop_id();
  int32_t troop_id() const;
  void set_troop_id(int32_t value);
  private:
  int32_t _internal_troop_id() const;
  void _internal_set_troop_id(int32_t value);
  public:

  // uint32 soldier_id = 3;
  void clear_soldier_id();
  uint32_t soldier_id() const;
  void set_soldier_id(uint32_t value);
  private:
  uint32_t _internal_soldier_id() const;
  void _internal_set_soldier_id(uint32_t value);
  public:

  // uint32 status = 5;
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // uint32 idx_curpath = 6;
  void clear_idx_curpath();
  uint32_t idx_curpath() const;
  void set_idx_curpath(uint32_t value);
  private:
  uint32_t _internal_idx_curpath() const;
  void _internal_set_idx_curpath(uint32_t value);
  public:

  // uint32 time = 7;
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // uint32 speed = 8;
  void clear_speed();
  uint32_t speed() const;
  void set_speed(uint32_t value);
  private:
  uint32_t _internal_speed() const;
  void _internal_set_speed(uint32_t value);
  public:

  // int64 end_time = 10;
  void clear_end_time();
  int64_t end_time() const;
  void set_end_time(int64_t value);
  private:
  int64_t _internal_end_time() const;
  void _internal_set_end_time(int64_t value);
  public:

  // uint32 morale = 11;
  void clear_morale();
  uint32_t morale() const;
  void set_morale(uint32_t value);
  private:
  uint32_t _internal_morale() const;
  void _internal_set_morale(uint32_t value);
  public:

  // uint32 protect_flag = 12;
  void clear_protect_flag();
  uint32_t protect_flag() const;
  void set_protect_flag(uint32_t value);
  private:
  uint32_t _internal_protect_flag() const;
  void _internal_set_protect_flag(uint32_t value);
  public:

  // int32 dst_troop_id = 13;
  void clear_dst_troop_id();
  int32_t dst_troop_id() const;
  void set_dst_troop_id(int32_t value);
  private:
  int32_t _internal_dst_troop_id() const;
  void _internal_set_dst_troop_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Map_Troop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX > vec_path_;
    ::pb::map::HEX* pos_;
    int64_t owner_id_;
    int32_t troop_id_;
    uint32_t soldier_id_;
    uint32_t status_;
    uint32_t idx_curpath_;
    uint32_t time_;
    uint32_t speed_;
    int64_t end_time_;
    uint32_t morale_;
    uint32_t protect_flag_;
    int32_t dst_troop_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Map_Field final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Map_Field) */ {
 public:
  inline Map_Field() : Map_Field(nullptr) {}
  ~Map_Field() override;
  explicit PROTOBUF_CONSTEXPR Map_Field(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_Field(const Map_Field& from);
  Map_Field(Map_Field&& from) noexcept
    : Map_Field() {
    *this = ::std::move(from);
  }

  inline Map_Field& operator=(const Map_Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_Field& operator=(Map_Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_Field* internal_default_instance() {
    return reinterpret_cast<const Map_Field*>(
               &_Map_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Map_Field& a, Map_Field& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_Field* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_Field* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_Field>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_Field& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Map_Field& from) {
    Map_Field::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_Field* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Map_Field";
  }
  protected:
  explicit Map_Field(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 2,
    kOwnerIdFieldNumber = 1,
    kFieldIdFieldNumber = 3,
    kTypeFieldNumber = 4,
    kStatusFieldNumber = 5,
    kFinishTimeFieldNumber = 6,
    kProtectFlagFieldNumber = 7,
  };
  // .pb.map.HEX pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // int64 owner_id = 1;
  void clear_owner_id();
  int64_t owner_id() const;
  void set_owner_id(int64_t value);
  private:
  int64_t _internal_owner_id() const;
  void _internal_set_owner_id(int64_t value);
  public:

  // int32 field_id = 3;
  void clear_field_id();
  int32_t field_id() const;
  void set_field_id(int32_t value);
  private:
  int32_t _internal_field_id() const;
  void _internal_set_field_id(int32_t value);
  public:

  // uint32 type = 4;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 Status = 5;
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // uint32 FinishTime = 6;
  void clear_finishtime();
  uint32_t finishtime() const;
  void set_finishtime(uint32_t value);
  private:
  uint32_t _internal_finishtime() const;
  void _internal_set_finishtime(uint32_t value);
  public:

  // uint32 protect_flag = 7;
  void clear_protect_flag();
  uint32_t protect_flag() const;
  void set_protect_flag(uint32_t value);
  private:
  uint32_t _internal_protect_flag() const;
  void _internal_set_protect_flag(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Map_Field)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* pos_;
    int64_t owner_id_;
    int32_t field_id_;
    uint32_t type_;
    uint32_t status_;
    uint32_t finishtime_;
    uint32_t protect_flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Map_RecoverField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Map_RecoverField) */ {
 public:
  inline Map_RecoverField() : Map_RecoverField(nullptr) {}
  ~Map_RecoverField() override;
  explicit PROTOBUF_CONSTEXPR Map_RecoverField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_RecoverField(const Map_RecoverField& from);
  Map_RecoverField(Map_RecoverField&& from) noexcept
    : Map_RecoverField() {
    *this = ::std::move(from);
  }

  inline Map_RecoverField& operator=(const Map_RecoverField& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_RecoverField& operator=(Map_RecoverField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_RecoverField& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_RecoverField* internal_default_instance() {
    return reinterpret_cast<const Map_RecoverField*>(
               &_Map_RecoverField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Map_RecoverField& a, Map_RecoverField& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_RecoverField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_RecoverField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_RecoverField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_RecoverField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_RecoverField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Map_RecoverField& from) {
    Map_RecoverField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_RecoverField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Map_RecoverField";
  }
  protected:
  explicit Map_RecoverField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kAtkUserIdFieldNumber = 2,
    kEndTimeFieldNumber = 3,
  };
  // .pb.map.HEX pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // int64 atk_user_id = 2;
  void clear_atk_user_id();
  int64_t atk_user_id() const;
  void set_atk_user_id(int64_t value);
  private:
  int64_t _internal_atk_user_id() const;
  void _internal_set_atk_user_id(int64_t value);
  public:

  // int64 end_time = 3;
  void clear_end_time();
  int64_t end_time() const;
  void set_end_time(int64_t value);
  private:
  int64_t _internal_end_time() const;
  void _internal_set_end_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Map_RecoverField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* pos_;
    int64_t atk_user_id_;
    int64_t end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Map_WildNpcTroop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Map_WildNpcTroop) */ {
 public:
  inline Map_WildNpcTroop() : Map_WildNpcTroop(nullptr) {}
  ~Map_WildNpcTroop() override;
  explicit PROTOBUF_CONSTEXPR Map_WildNpcTroop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_WildNpcTroop(const Map_WildNpcTroop& from);
  Map_WildNpcTroop(Map_WildNpcTroop&& from) noexcept
    : Map_WildNpcTroop() {
    *this = ::std::move(from);
  }

  inline Map_WildNpcTroop& operator=(const Map_WildNpcTroop& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_WildNpcTroop& operator=(Map_WildNpcTroop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_WildNpcTroop& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_WildNpcTroop* internal_default_instance() {
    return reinterpret_cast<const Map_WildNpcTroop*>(
               &_Map_WildNpcTroop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Map_WildNpcTroop& a, Map_WildNpcTroop& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_WildNpcTroop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_WildNpcTroop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_WildNpcTroop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_WildNpcTroop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_WildNpcTroop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Map_WildNpcTroop& from) {
    Map_WildNpcTroop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_WildNpcTroop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Map_WildNpcTroop";
  }
  protected:
  explicit Map_WildNpcTroop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 2,
    kIdFieldNumber = 1,
    kWildNpcIdFieldNumber = 3,
    kDisappearTimeFieldNumber = 4,
    kStatusFieldNumber = 5,
  };
  // .pb.map.HEX pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // int32 wild_npc_id = 3;
  void clear_wild_npc_id();
  int32_t wild_npc_id() const;
  void set_wild_npc_id(int32_t value);
  private:
  int32_t _internal_wild_npc_id() const;
  void _internal_set_wild_npc_id(int32_t value);
  public:

  // int64 disappear_time = 4;
  void clear_disappear_time();
  int64_t disappear_time() const;
  void set_disappear_time(int64_t value);
  private:
  int64_t _internal_disappear_time() const;
  void _internal_set_disappear_time(int64_t value);
  public:

  // int32 status = 5;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Map_WildNpcTroop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* pos_;
    uint32_t id_;
    int32_t wild_npc_id_;
    int64_t disappear_time_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Map_WildBuilding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Map_WildBuilding) */ {
 public:
  inline Map_WildBuilding() : Map_WildBuilding(nullptr) {}
  ~Map_WildBuilding() override;
  explicit PROTOBUF_CONSTEXPR Map_WildBuilding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_WildBuilding(const Map_WildBuilding& from);
  Map_WildBuilding(Map_WildBuilding&& from) noexcept
    : Map_WildBuilding() {
    *this = ::std::move(from);
  }

  inline Map_WildBuilding& operator=(const Map_WildBuilding& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_WildBuilding& operator=(Map_WildBuilding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_WildBuilding& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_WildBuilding* internal_default_instance() {
    return reinterpret_cast<const Map_WildBuilding*>(
               &_Map_WildBuilding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Map_WildBuilding& a, Map_WildBuilding& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_WildBuilding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_WildBuilding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_WildBuilding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_WildBuilding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_WildBuilding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Map_WildBuilding& from) {
    Map_WildBuilding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_WildBuilding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Map_WildBuilding";
  }
  protected:
  explicit Map_WildBuilding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 2,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 3,
    kLevelFieldNumber = 4,
    kTroopNumFieldNumber = 5,
    kLifeFieldNumber = 6,
    kLifeMaxFieldNumber = 7,
    kDisappearTimeFieldNumber = 8,
  };
  // .pb.map.HEX pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 type = 3;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 level = 4;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // uint32 troop_num = 5;
  void clear_troop_num();
  uint32_t troop_num() const;
  void set_troop_num(uint32_t value);
  private:
  uint32_t _internal_troop_num() const;
  void _internal_set_troop_num(uint32_t value);
  public:

  // uint32 life = 6;
  void clear_life();
  uint32_t life() const;
  void set_life(uint32_t value);
  private:
  uint32_t _internal_life() const;
  void _internal_set_life(uint32_t value);
  public:

  // uint32 life_max = 7;
  void clear_life_max();
  uint32_t life_max() const;
  void set_life_max(uint32_t value);
  private:
  uint32_t _internal_life_max() const;
  void _internal_set_life_max(uint32_t value);
  public:

  // int32 disappear_time = 8;
  void clear_disappear_time();
  int32_t disappear_time() const;
  void set_disappear_time(int32_t value);
  private:
  int32_t _internal_disappear_time() const;
  void _internal_set_disappear_time(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Map_WildBuilding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* pos_;
    uint32_t id_;
    uint32_t type_;
    uint32_t level_;
    uint32_t troop_num_;
    uint32_t life_;
    uint32_t life_max_;
    int32_t disappear_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class MapUserData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.MapUserData) */ {
 public:
  inline MapUserData() : MapUserData(nullptr) {}
  ~MapUserData() override;
  explicit PROTOBUF_CONSTEXPR MapUserData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapUserData(const MapUserData& from);
  MapUserData(MapUserData&& from) noexcept
    : MapUserData() {
    *this = ::std::move(from);
  }

  inline MapUserData& operator=(const MapUserData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapUserData& operator=(MapUserData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapUserData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapUserData* internal_default_instance() {
    return reinterpret_cast<const MapUserData*>(
               &_MapUserData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MapUserData& a, MapUserData& b) {
    a.Swap(&b);
  }
  inline void Swap(MapUserData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapUserData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapUserData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapUserData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapUserData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapUserData& from) {
    MapUserData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapUserData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.MapUserData";
  }
  protected:
  explicit MapUserData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kUserIdFieldNumber = 1,
    kGuildIdFieldNumber = 3,
    kCaptureIdFieldNumber = 4,
    kGuildJobFieldNumber = 5,
    kCivilizationTypeFieldNumber = 6,
  };
  // string user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // int64 user_id = 1;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // int32 guild_id = 3;
  void clear_guild_id();
  int32_t guild_id() const;
  void set_guild_id(int32_t value);
  private:
  int32_t _internal_guild_id() const;
  void _internal_set_guild_id(int32_t value);
  public:

  // int32 capture_id = 4;
  void clear_capture_id();
  int32_t capture_id() const;
  void set_capture_id(int32_t value);
  private:
  int32_t _internal_capture_id() const;
  void _internal_set_capture_id(int32_t value);
  public:

  // int32 guild_job = 5;
  void clear_guild_job();
  int32_t guild_job() const;
  void set_guild_job(int32_t value);
  private:
  int32_t _internal_guild_job() const;
  void _internal_set_guild_job(int32_t value);
  public:

  // int32 civilization_type = 6;
  void clear_civilization_type();
  int32_t civilization_type() const;
  void set_civilization_type(int32_t value);
  private:
  int32_t _internal_civilization_type() const;
  void _internal_set_civilization_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.MapUserData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    int64_t user_id_;
    int32_t guild_id_;
    int32_t capture_id_;
    int32_t guild_job_;
    int32_t civilization_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Map_Objs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Map_Objs) */ {
 public:
  inline Map_Objs() : Map_Objs(nullptr) {}
  ~Map_Objs() override;
  explicit PROTOBUF_CONSTEXPR Map_Objs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_Objs(const Map_Objs& from);
  Map_Objs(Map_Objs&& from) noexcept
    : Map_Objs() {
    *this = ::std::move(from);
  }

  inline Map_Objs& operator=(const Map_Objs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_Objs& operator=(Map_Objs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_Objs& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_Objs* internal_default_instance() {
    return reinterpret_cast<const Map_Objs*>(
               &_Map_Objs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Map_Objs& a, Map_Objs& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_Objs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_Objs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_Objs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_Objs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_Objs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Map_Objs& from) {
    Map_Objs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_Objs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Map_Objs";
  }
  protected:
  explicit Map_Objs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecBuildingsFieldNumber = 1,
    kVecTroopsFieldNumber = 2,
    kVecFieldsFieldNumber = 3,
    kVecRecoverfieldFieldNumber = 4,
    kVecWildNpcTroopFieldNumber = 5,
    kVecWildBuildingFieldNumber = 6,
    kVecUsersFieldNumber = 7,
  };
  // repeated .pb.map.Map_Building vec_buildings = 1;
  int vec_buildings_size() const;
  private:
  int _internal_vec_buildings_size() const;
  public:
  void clear_vec_buildings();
  ::pb::map::Map_Building* mutable_vec_buildings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Building >*
      mutable_vec_buildings();
  private:
  const ::pb::map::Map_Building& _internal_vec_buildings(int index) const;
  ::pb::map::Map_Building* _internal_add_vec_buildings();
  public:
  const ::pb::map::Map_Building& vec_buildings(int index) const;
  ::pb::map::Map_Building* add_vec_buildings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Building >&
      vec_buildings() const;

  // repeated .pb.map.Map_Troop vec_troops = 2;
  int vec_troops_size() const;
  private:
  int _internal_vec_troops_size() const;
  public:
  void clear_vec_troops();
  ::pb::map::Map_Troop* mutable_vec_troops(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Troop >*
      mutable_vec_troops();
  private:
  const ::pb::map::Map_Troop& _internal_vec_troops(int index) const;
  ::pb::map::Map_Troop* _internal_add_vec_troops();
  public:
  const ::pb::map::Map_Troop& vec_troops(int index) const;
  ::pb::map::Map_Troop* add_vec_troops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Troop >&
      vec_troops() const;

  // repeated .pb.map.Map_Field vec_fields = 3;
  int vec_fields_size() const;
  private:
  int _internal_vec_fields_size() const;
  public:
  void clear_vec_fields();
  ::pb::map::Map_Field* mutable_vec_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Field >*
      mutable_vec_fields();
  private:
  const ::pb::map::Map_Field& _internal_vec_fields(int index) const;
  ::pb::map::Map_Field* _internal_add_vec_fields();
  public:
  const ::pb::map::Map_Field& vec_fields(int index) const;
  ::pb::map::Map_Field* add_vec_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Field >&
      vec_fields() const;

  // repeated .pb.map.Map_RecoverField vec_recoverfield = 4;
  int vec_recoverfield_size() const;
  private:
  int _internal_vec_recoverfield_size() const;
  public:
  void clear_vec_recoverfield();
  ::pb::map::Map_RecoverField* mutable_vec_recoverfield(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_RecoverField >*
      mutable_vec_recoverfield();
  private:
  const ::pb::map::Map_RecoverField& _internal_vec_recoverfield(int index) const;
  ::pb::map::Map_RecoverField* _internal_add_vec_recoverfield();
  public:
  const ::pb::map::Map_RecoverField& vec_recoverfield(int index) const;
  ::pb::map::Map_RecoverField* add_vec_recoverfield();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_RecoverField >&
      vec_recoverfield() const;

  // repeated .pb.map.Map_WildNpcTroop vec_wild_npc_troop = 5;
  int vec_wild_npc_troop_size() const;
  private:
  int _internal_vec_wild_npc_troop_size() const;
  public:
  void clear_vec_wild_npc_troop();
  ::pb::map::Map_WildNpcTroop* mutable_vec_wild_npc_troop(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildNpcTroop >*
      mutable_vec_wild_npc_troop();
  private:
  const ::pb::map::Map_WildNpcTroop& _internal_vec_wild_npc_troop(int index) const;
  ::pb::map::Map_WildNpcTroop* _internal_add_vec_wild_npc_troop();
  public:
  const ::pb::map::Map_WildNpcTroop& vec_wild_npc_troop(int index) const;
  ::pb::map::Map_WildNpcTroop* add_vec_wild_npc_troop();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildNpcTroop >&
      vec_wild_npc_troop() const;

  // repeated .pb.map.Map_WildBuilding vec_wild_building = 6;
  int vec_wild_building_size() const;
  private:
  int _internal_vec_wild_building_size() const;
  public:
  void clear_vec_wild_building();
  ::pb::map::Map_WildBuilding* mutable_vec_wild_building(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildBuilding >*
      mutable_vec_wild_building();
  private:
  const ::pb::map::Map_WildBuilding& _internal_vec_wild_building(int index) const;
  ::pb::map::Map_WildBuilding* _internal_add_vec_wild_building();
  public:
  const ::pb::map::Map_WildBuilding& vec_wild_building(int index) const;
  ::pb::map::Map_WildBuilding* add_vec_wild_building();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildBuilding >&
      vec_wild_building() const;

  // repeated .pb.map.MapUserData vec_users = 7;
  int vec_users_size() const;
  private:
  int _internal_vec_users_size() const;
  public:
  void clear_vec_users();
  ::pb::map::MapUserData* mutable_vec_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::MapUserData >*
      mutable_vec_users();
  private:
  const ::pb::map::MapUserData& _internal_vec_users(int index) const;
  ::pb::map::MapUserData* _internal_add_vec_users();
  public:
  const ::pb::map::MapUserData& vec_users(int index) const;
  ::pb::map::MapUserData* add_vec_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::MapUserData >&
      vec_users() const;

  // @@protoc_insertion_point(class_scope:pb.map.Map_Objs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Building > vec_buildings_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Troop > vec_troops_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Field > vec_fields_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_RecoverField > vec_recoverfield_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildNpcTroop > vec_wild_npc_troop_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildBuilding > vec_wild_building_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::MapUserData > vec_users_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class PrivateNpc_Troop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.PrivateNpc_Troop) */ {
 public:
  inline PrivateNpc_Troop() : PrivateNpc_Troop(nullptr) {}
  ~PrivateNpc_Troop() override;
  explicit PROTOBUF_CONSTEXPR PrivateNpc_Troop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateNpc_Troop(const PrivateNpc_Troop& from);
  PrivateNpc_Troop(PrivateNpc_Troop&& from) noexcept
    : PrivateNpc_Troop() {
    *this = ::std::move(from);
  }

  inline PrivateNpc_Troop& operator=(const PrivateNpc_Troop& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateNpc_Troop& operator=(PrivateNpc_Troop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivateNpc_Troop& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateNpc_Troop* internal_default_instance() {
    return reinterpret_cast<const PrivateNpc_Troop*>(
               &_PrivateNpc_Troop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PrivateNpc_Troop& a, PrivateNpc_Troop& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateNpc_Troop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateNpc_Troop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrivateNpc_Troop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrivateNpc_Troop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivateNpc_Troop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrivateNpc_Troop& from) {
    PrivateNpc_Troop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivateNpc_Troop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.PrivateNpc_Troop";
  }
  protected:
  explicit PrivateNpc_Troop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 3,
    kIdFieldNumber = 1,
    kIdTemplateFieldNumber = 2,
  };
  // .pb.map.HEX pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 id_template = 2;
  void clear_id_template();
  uint32_t id_template() const;
  void set_id_template(uint32_t value);
  private:
  uint32_t _internal_id_template() const;
  void _internal_set_id_template(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.PrivateNpc_Troop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* pos_;
    uint32_t id_;
    uint32_t id_template_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Private_Map_Objs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Private_Map_Objs) */ {
 public:
  inline Private_Map_Objs() : Private_Map_Objs(nullptr) {}
  ~Private_Map_Objs() override;
  explicit PROTOBUF_CONSTEXPR Private_Map_Objs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Private_Map_Objs(const Private_Map_Objs& from);
  Private_Map_Objs(Private_Map_Objs&& from) noexcept
    : Private_Map_Objs() {
    *this = ::std::move(from);
  }

  inline Private_Map_Objs& operator=(const Private_Map_Objs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Private_Map_Objs& operator=(Private_Map_Objs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Private_Map_Objs& default_instance() {
    return *internal_default_instance();
  }
  static inline const Private_Map_Objs* internal_default_instance() {
    return reinterpret_cast<const Private_Map_Objs*>(
               &_Private_Map_Objs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Private_Map_Objs& a, Private_Map_Objs& b) {
    a.Swap(&b);
  }
  inline void Swap(Private_Map_Objs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Private_Map_Objs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Private_Map_Objs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Private_Map_Objs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Private_Map_Objs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Private_Map_Objs& from) {
    Private_Map_Objs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Private_Map_Objs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Private_Map_Objs";
  }
  protected:
  explicit Private_Map_Objs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecTroopFieldNumber = 1,
    kVecWildNpcTroopFieldNumber = 2,
  };
  // repeated .pb.map.PrivateNpc_Troop vec_troop = 1;
  int vec_troop_size() const;
  private:
  int _internal_vec_troop_size() const;
  public:
  void clear_vec_troop();
  ::pb::map::PrivateNpc_Troop* mutable_vec_troop(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::PrivateNpc_Troop >*
      mutable_vec_troop();
  private:
  const ::pb::map::PrivateNpc_Troop& _internal_vec_troop(int index) const;
  ::pb::map::PrivateNpc_Troop* _internal_add_vec_troop();
  public:
  const ::pb::map::PrivateNpc_Troop& vec_troop(int index) const;
  ::pb::map::PrivateNpc_Troop* add_vec_troop();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::PrivateNpc_Troop >&
      vec_troop() const;

  // repeated .pb.map.Map_WildNpcTroop vec_wild_npc_troop = 2;
  int vec_wild_npc_troop_size() const;
  private:
  int _internal_vec_wild_npc_troop_size() const;
  public:
  void clear_vec_wild_npc_troop();
  ::pb::map::Map_WildNpcTroop* mutable_vec_wild_npc_troop(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildNpcTroop >*
      mutable_vec_wild_npc_troop();
  private:
  const ::pb::map::Map_WildNpcTroop& _internal_vec_wild_npc_troop(int index) const;
  ::pb::map::Map_WildNpcTroop* _internal_add_vec_wild_npc_troop();
  public:
  const ::pb::map::Map_WildNpcTroop& vec_wild_npc_troop(int index) const;
  ::pb::map::Map_WildNpcTroop* add_vec_wild_npc_troop();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildNpcTroop >&
      vec_wild_npc_troop() const;

  // @@protoc_insertion_point(class_scope:pb.map.Private_Map_Objs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::PrivateNpc_Troop > vec_troop_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildNpcTroop > vec_wild_npc_troop_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Collect_Map_OP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Collect_Map_OP) */ {
 public:
  inline Collect_Map_OP() : Collect_Map_OP(nullptr) {}
  ~Collect_Map_OP() override;
  explicit PROTOBUF_CONSTEXPR Collect_Map_OP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Collect_Map_OP(const Collect_Map_OP& from);
  Collect_Map_OP(Collect_Map_OP&& from) noexcept
    : Collect_Map_OP() {
    *this = ::std::move(from);
  }

  inline Collect_Map_OP& operator=(const Collect_Map_OP& from) {
    CopyFrom(from);
    return *this;
  }
  inline Collect_Map_OP& operator=(Collect_Map_OP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Collect_Map_OP& default_instance() {
    return *internal_default_instance();
  }
  static inline const Collect_Map_OP* internal_default_instance() {
    return reinterpret_cast<const Collect_Map_OP*>(
               &_Collect_Map_OP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Collect_Map_OP& a, Collect_Map_OP& b) {
    a.Swap(&b);
  }
  inline void Swap(Collect_Map_OP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Collect_Map_OP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Collect_Map_OP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Collect_Map_OP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Collect_Map_OP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Collect_Map_OP& from) {
    Collect_Map_OP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Collect_Map_OP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Collect_Map_OP";
  }
  protected:
  explicit Collect_Map_OP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kEndPosFieldNumber = 2,
    kIdxFieldNumber = 4,
    kErrCodeFieldNumber = 1,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .pb.map.HEX end_pos = 2;
  bool has_end_pos() const;
  private:
  bool _internal_has_end_pos() const;
  public:
  void clear_end_pos();
  const ::pb::map::HEX& end_pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_end_pos();
  ::pb::map::HEX* mutable_end_pos();
  void set_allocated_end_pos(::pb::map::HEX* end_pos);
  private:
  const ::pb::map::HEX& _internal_end_pos() const;
  ::pb::map::HEX* _internal_mutable_end_pos();
  public:
  void unsafe_arena_set_allocated_end_pos(
      ::pb::map::HEX* end_pos);
  ::pb::map::HEX* unsafe_arena_release_end_pos();

  // int64 idx = 4;
  void clear_idx();
  int64_t idx() const;
  void set_idx(int64_t value);
  private:
  int64_t _internal_idx() const;
  void _internal_set_idx(int64_t value);
  public:

  // uint32 errCode = 1;
  void clear_errcode();
  uint32_t errcode() const;
  void set_errcode(uint32_t value);
  private:
  uint32_t _internal_errcode() const;
  void _internal_set_errcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Collect_Map_OP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::pb::map::HEX* end_pos_;
    int64_t idx_;
    uint32_t errcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Move_City final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Move_City) */ {
 public:
  inline Move_City() : Move_City(nullptr) {}
  ~Move_City() override;
  explicit PROTOBUF_CONSTEXPR Move_City(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Move_City(const Move_City& from);
  Move_City(Move_City&& from) noexcept
    : Move_City() {
    *this = ::std::move(from);
  }

  inline Move_City& operator=(const Move_City& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move_City& operator=(Move_City&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Move_City& default_instance() {
    return *internal_default_instance();
  }
  static inline const Move_City* internal_default_instance() {
    return reinterpret_cast<const Move_City*>(
               &_Move_City_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Move_City& a, Move_City& b) {
    a.Swap(&b);
  }
  inline void Swap(Move_City* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move_City* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Move_City* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Move_City>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Move_City& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Move_City& from) {
    Move_City::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Move_City* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Move_City";
  }
  protected:
  explicit Move_City(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMovePosFieldNumber = 3,
    kErrorCodeFieldNumber = 1,
    kIdxFieldNumber = 2,
  };
  // .pb.map.HEX move_pos = 3;
  bool has_move_pos() const;
  private:
  bool _internal_has_move_pos() const;
  public:
  void clear_move_pos();
  const ::pb::map::HEX& move_pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_move_pos();
  ::pb::map::HEX* mutable_move_pos();
  void set_allocated_move_pos(::pb::map::HEX* move_pos);
  private:
  const ::pb::map::HEX& _internal_move_pos() const;
  ::pb::map::HEX* _internal_mutable_move_pos();
  public:
  void unsafe_arena_set_allocated_move_pos(
      ::pb::map::HEX* move_pos);
  ::pb::map::HEX* unsafe_arena_release_move_pos();

  // uint32 error_code = 1;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // uint32 idx = 2;
  void clear_idx();
  uint32_t idx() const;
  void set_idx(uint32_t value);
  private:
  uint32_t _internal_idx() const;
  void _internal_set_idx(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Move_City)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* move_pos_;
    uint32_t error_code_;
    uint32_t idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Resurgence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Resurgence) */ {
 public:
  inline Resurgence() : Resurgence(nullptr) {}
  ~Resurgence() override;
  explicit PROTOBUF_CONSTEXPR Resurgence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Resurgence(const Resurgence& from);
  Resurgence(Resurgence&& from) noexcept
    : Resurgence() {
    *this = ::std::move(from);
  }

  inline Resurgence& operator=(const Resurgence& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resurgence& operator=(Resurgence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resurgence& default_instance() {
    return *internal_default_instance();
  }
  static inline const Resurgence* internal_default_instance() {
    return reinterpret_cast<const Resurgence*>(
               &_Resurgence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Resurgence& a, Resurgence& b) {
    a.Swap(&b);
  }
  inline void Swap(Resurgence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resurgence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Resurgence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Resurgence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Resurgence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Resurgence& from) {
    Resurgence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resurgence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Resurgence";
  }
  protected:
  explicit Resurgence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // .pb.map.HEX pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // uint32 error_code = 1;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Resurgence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* pos_;
    uint32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Migrate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Migrate) */ {
 public:
  inline Migrate() : Migrate(nullptr) {}
  ~Migrate() override;
  explicit PROTOBUF_CONSTEXPR Migrate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Migrate(const Migrate& from);
  Migrate(Migrate&& from) noexcept
    : Migrate() {
    *this = ::std::move(from);
  }

  inline Migrate& operator=(const Migrate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Migrate& operator=(Migrate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Migrate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Migrate* internal_default_instance() {
    return reinterpret_cast<const Migrate*>(
               &_Migrate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Migrate& a, Migrate& b) {
    a.Swap(&b);
  }
  inline void Swap(Migrate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Migrate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Migrate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Migrate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Migrate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Migrate& from) {
    Migrate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Migrate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Migrate";
  }
  protected:
  explicit Migrate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 3,
    kErrorCodeFieldNumber = 1,
    kCountryIdFieldNumber = 2,
  };
  // .pb.map.HEX pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // uint32 error_code = 1;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // int32 country_id = 2;
  void clear_country_id();
  int32_t country_id() const;
  void set_country_id(int32_t value);
  private:
  int32_t _internal_country_id() const;
  void _internal_set_country_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Migrate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* pos_;
    uint32_t error_code_;
    int32_t country_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Req_Scout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Req_Scout) */ {
 public:
  inline Req_Scout() : Req_Scout(nullptr) {}
  ~Req_Scout() override;
  explicit PROTOBUF_CONSTEXPR Req_Scout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Req_Scout(const Req_Scout& from);
  Req_Scout(Req_Scout&& from) noexcept
    : Req_Scout() {
    *this = ::std::move(from);
  }

  inline Req_Scout& operator=(const Req_Scout& from) {
    CopyFrom(from);
    return *this;
  }
  inline Req_Scout& operator=(Req_Scout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Req_Scout& default_instance() {
    return *internal_default_instance();
  }
  static inline const Req_Scout* internal_default_instance() {
    return reinterpret_cast<const Req_Scout*>(
               &_Req_Scout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Req_Scout& a, Req_Scout& b) {
    a.Swap(&b);
  }
  inline void Swap(Req_Scout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Req_Scout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Req_Scout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Req_Scout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Req_Scout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Req_Scout& from) {
    Req_Scout::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Req_Scout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Req_Scout";
  }
  protected:
  explicit Req_Scout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // .pb.map.HEX pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // uint32 error_code = 1;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Req_Scout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* pos_;
    uint32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class TroopScout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.TroopScout) */ {
 public:
  inline TroopScout() : TroopScout(nullptr) {}
  ~TroopScout() override;
  explicit PROTOBUF_CONSTEXPR TroopScout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TroopScout(const TroopScout& from);
  TroopScout(TroopScout&& from) noexcept
    : TroopScout() {
    *this = ::std::move(from);
  }

  inline TroopScout& operator=(const TroopScout& from) {
    CopyFrom(from);
    return *this;
  }
  inline TroopScout& operator=(TroopScout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TroopScout& default_instance() {
    return *internal_default_instance();
  }
  static inline const TroopScout* internal_default_instance() {
    return reinterpret_cast<const TroopScout*>(
               &_TroopScout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TroopScout& a, TroopScout& b) {
    a.Swap(&b);
  }
  inline void Swap(TroopScout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TroopScout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TroopScout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TroopScout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TroopScout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TroopScout& from) {
    TroopScout::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TroopScout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.TroopScout";
  }
  protected:
  explicit TroopScout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqNoFieldNumber = 1,
    kTroopIdFieldNumber = 2,
    kForce1FieldNumber = 3,
    kForce2FieldNumber = 4,
    kForce3FieldNumber = 5,
  };
  // int32 seq_no = 1;
  void clear_seq_no();
  int32_t seq_no() const;
  void set_seq_no(int32_t value);
  private:
  int32_t _internal_seq_no() const;
  void _internal_set_seq_no(int32_t value);
  public:

  // int32 troop_id = 2;
  void clear_troop_id();
  int32_t troop_id() const;
  void set_troop_id(int32_t value);
  private:
  int32_t _internal_troop_id() const;
  void _internal_set_troop_id(int32_t value);
  public:

  // int32 force1 = 3;
  void clear_force1();
  int32_t force1() const;
  void set_force1(int32_t value);
  private:
  int32_t _internal_force1() const;
  void _internal_set_force1(int32_t value);
  public:

  // int32 force2 = 4;
  void clear_force2();
  int32_t force2() const;
  void set_force2(int32_t value);
  private:
  int32_t _internal_force2() const;
  void _internal_set_force2(int32_t value);
  public:

  // int32 force3 = 5;
  void clear_force3();
  int32_t force3() const;
  void set_force3(int32_t value);
  private:
  int32_t _internal_force3() const;
  void _internal_set_force3(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.TroopScout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t seq_no_;
    int32_t troop_id_;
    int32_t force1_;
    int32_t force2_;
    int32_t force3_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class FieldScout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.FieldScout) */ {
 public:
  inline FieldScout() : FieldScout(nullptr) {}
  ~FieldScout() override;
  explicit PROTOBUF_CONSTEXPR FieldScout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldScout(const FieldScout& from);
  FieldScout(FieldScout&& from) noexcept
    : FieldScout() {
    *this = ::std::move(from);
  }

  inline FieldScout& operator=(const FieldScout& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldScout& operator=(FieldScout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldScout& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldScout* internal_default_instance() {
    return reinterpret_cast<const FieldScout*>(
               &_FieldScout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(FieldScout& a, FieldScout& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldScout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldScout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldScout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldScout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldScout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FieldScout& from) {
    FieldScout::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldScout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.FieldScout";
  }
  protected:
  explicit FieldScout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScoutInfoFieldNumber = 2,
    kPosFieldNumber = 1,
    kScoutTimeFieldNumber = 3,
    kScoutEndTimeFieldNumber = 4,
  };
  // repeated .pb.map.TroopScout scout_info = 2;
  int scout_info_size() const;
  private:
  int _internal_scout_info_size() const;
  public:
  void clear_scout_info();
  ::pb::map::TroopScout* mutable_scout_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::TroopScout >*
      mutable_scout_info();
  private:
  const ::pb::map::TroopScout& _internal_scout_info(int index) const;
  ::pb::map::TroopScout* _internal_add_scout_info();
  public:
  const ::pb::map::TroopScout& scout_info(int index) const;
  ::pb::map::TroopScout* add_scout_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::TroopScout >&
      scout_info() const;

  // .pb.map.HEX pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // int64 scout_time = 3;
  void clear_scout_time();
  int64_t scout_time() const;
  void set_scout_time(int64_t value);
  private:
  int64_t _internal_scout_time() const;
  void _internal_set_scout_time(int64_t value);
  public:

  // int64 scout_end_time = 4;
  void clear_scout_end_time();
  int64_t scout_end_time() const;
  void set_scout_end_time(int64_t value);
  private:
  int64_t _internal_scout_end_time() const;
  void _internal_set_scout_end_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.FieldScout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::TroopScout > scout_info_;
    ::pb::map::HEX* pos_;
    int64_t scout_time_;
    int64_t scout_end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Rep_Scout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Rep_Scout) */ {
 public:
  inline Rep_Scout() : Rep_Scout(nullptr) {}
  ~Rep_Scout() override;
  explicit PROTOBUF_CONSTEXPR Rep_Scout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rep_Scout(const Rep_Scout& from);
  Rep_Scout(Rep_Scout&& from) noexcept
    : Rep_Scout() {
    *this = ::std::move(from);
  }

  inline Rep_Scout& operator=(const Rep_Scout& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rep_Scout& operator=(Rep_Scout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rep_Scout& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rep_Scout* internal_default_instance() {
    return reinterpret_cast<const Rep_Scout*>(
               &_Rep_Scout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Rep_Scout& a, Rep_Scout& b) {
    a.Swap(&b);
  }
  inline void Swap(Rep_Scout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rep_Scout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rep_Scout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rep_Scout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rep_Scout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rep_Scout& from) {
    Rep_Scout::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rep_Scout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Rep_Scout";
  }
  protected:
  explicit Rep_Scout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldScoutFieldNumber = 1,
    kNextScoutTimeFieldNumber = 2,
  };
  // repeated .pb.map.FieldScout field_scout = 1;
  int field_scout_size() const;
  private:
  int _internal_field_scout_size() const;
  public:
  void clear_field_scout();
  ::pb::map::FieldScout* mutable_field_scout(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::FieldScout >*
      mutable_field_scout();
  private:
  const ::pb::map::FieldScout& _internal_field_scout(int index) const;
  ::pb::map::FieldScout* _internal_add_field_scout();
  public:
  const ::pb::map::FieldScout& field_scout(int index) const;
  ::pb::map::FieldScout* add_field_scout();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::FieldScout >&
      field_scout() const;

  // uint64 next_scout_time = 2;
  void clear_next_scout_time();
  uint64_t next_scout_time() const;
  void set_next_scout_time(uint64_t value);
  private:
  uint64_t _internal_next_scout_time() const;
  void _internal_set_next_scout_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Rep_Scout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::FieldScout > field_scout_;
    uint64_t next_scout_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Rep_DeleteScout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Rep_DeleteScout) */ {
 public:
  inline Rep_DeleteScout() : Rep_DeleteScout(nullptr) {}
  ~Rep_DeleteScout() override;
  explicit PROTOBUF_CONSTEXPR Rep_DeleteScout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rep_DeleteScout(const Rep_DeleteScout& from);
  Rep_DeleteScout(Rep_DeleteScout&& from) noexcept
    : Rep_DeleteScout() {
    *this = ::std::move(from);
  }

  inline Rep_DeleteScout& operator=(const Rep_DeleteScout& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rep_DeleteScout& operator=(Rep_DeleteScout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rep_DeleteScout& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rep_DeleteScout* internal_default_instance() {
    return reinterpret_cast<const Rep_DeleteScout*>(
               &_Rep_DeleteScout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Rep_DeleteScout& a, Rep_DeleteScout& b) {
    a.Swap(&b);
  }
  inline void Swap(Rep_DeleteScout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rep_DeleteScout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rep_DeleteScout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rep_DeleteScout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rep_DeleteScout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rep_DeleteScout& from) {
    Rep_DeleteScout::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rep_DeleteScout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Rep_DeleteScout";
  }
  protected:
  explicit Rep_DeleteScout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecPosFieldNumber = 1,
  };
  // repeated uint32 vec_pos = 1;
  int vec_pos_size() const;
  private:
  int _internal_vec_pos_size() const;
  public:
  void clear_vec_pos();
  private:
  uint32_t _internal_vec_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_vec_pos() const;
  void _internal_add_vec_pos(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_vec_pos();
  public:
  uint32_t vec_pos(int index) const;
  void set_vec_pos(int index, uint32_t value);
  void add_vec_pos(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      vec_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_vec_pos();

  // @@protoc_insertion_point(class_scope:pb.map.Rep_DeleteScout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > vec_pos_;
    mutable std::atomic<int> _vec_pos_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Rep_ClearScout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Rep_ClearScout) */ {
 public:
  inline Rep_ClearScout() : Rep_ClearScout(nullptr) {}
  ~Rep_ClearScout() override;
  explicit PROTOBUF_CONSTEXPR Rep_ClearScout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rep_ClearScout(const Rep_ClearScout& from);
  Rep_ClearScout(Rep_ClearScout&& from) noexcept
    : Rep_ClearScout() {
    *this = ::std::move(from);
  }

  inline Rep_ClearScout& operator=(const Rep_ClearScout& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rep_ClearScout& operator=(Rep_ClearScout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rep_ClearScout& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rep_ClearScout* internal_default_instance() {
    return reinterpret_cast<const Rep_ClearScout*>(
               &_Rep_ClearScout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Rep_ClearScout& a, Rep_ClearScout& b) {
    a.Swap(&b);
  }
  inline void Swap(Rep_ClearScout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rep_ClearScout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rep_ClearScout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rep_ClearScout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rep_ClearScout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rep_ClearScout& from) {
    Rep_ClearScout::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rep_ClearScout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Rep_ClearScout";
  }
  protected:
  explicit Rep_ClearScout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdFieldNumber = 1,
  };
  // .pb.map.E_Map_CMD cmd = 1;
  void clear_cmd();
  ::pb::map::E_Map_CMD cmd() const;
  void set_cmd(::pb::map::E_Map_CMD value);
  private:
  ::pb::map::E_Map_CMD _internal_cmd() const;
  void _internal_set_cmd(::pb::map::E_Map_CMD value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Rep_ClearScout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int cmd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class CombatantUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.CombatantUser) */ {
 public:
  inline CombatantUser() : CombatantUser(nullptr) {}
  ~CombatantUser() override;
  explicit PROTOBUF_CONSTEXPR CombatantUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CombatantUser(const CombatantUser& from);
  CombatantUser(CombatantUser&& from) noexcept
    : CombatantUser() {
    *this = ::std::move(from);
  }

  inline CombatantUser& operator=(const CombatantUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatantUser& operator=(CombatantUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatantUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const CombatantUser* internal_default_instance() {
    return reinterpret_cast<const CombatantUser*>(
               &_CombatantUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CombatantUser& a, CombatantUser& b) {
    a.Swap(&b);
  }
  inline void Swap(CombatantUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatantUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatantUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CombatantUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CombatantUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CombatantUser& from) {
    CombatantUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CombatantUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.CombatantUser";
  }
  protected:
  explicit CombatantUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kUserIdFieldNumber = 1,
    kHonorFieldNumber = 3,
    kOccupyFieldNumber = 4,
  };
  // string user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // int64 user_id = 1;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // int32 honor = 3;
  void clear_honor();
  int32_t honor() const;
  void set_honor(int32_t value);
  private:
  int32_t _internal_honor() const;
  void _internal_set_honor(int32_t value);
  public:

  // int32 occupy = 4;
  void clear_occupy();
  int32_t occupy() const;
  void set_occupy(int32_t value);
  private:
  int32_t _internal_occupy() const;
  void _internal_set_occupy(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.CombatantUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    int64_t user_id_;
    int32_t honor_;
    int32_t occupy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class MapCampaign final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.MapCampaign) */ {
 public:
  inline MapCampaign() : MapCampaign(nullptr) {}
  ~MapCampaign() override;
  explicit PROTOBUF_CONSTEXPR MapCampaign(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapCampaign(const MapCampaign& from);
  MapCampaign(MapCampaign&& from) noexcept
    : MapCampaign() {
    *this = ::std::move(from);
  }

  inline MapCampaign& operator=(const MapCampaign& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapCampaign& operator=(MapCampaign&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapCampaign& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapCampaign* internal_default_instance() {
    return reinterpret_cast<const MapCampaign*>(
               &_MapCampaign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(MapCampaign& a, MapCampaign& b) {
    a.Swap(&b);
  }
  inline void Swap(MapCampaign* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapCampaign* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapCampaign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapCampaign>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapCampaign& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapCampaign& from) {
    MapCampaign::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapCampaign* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.MapCampaign";
  }
  protected:
  explicit MapCampaign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCombatantGuildsFieldNumber = 5,
    kPosFieldNumber = 1,
    kHonorTopFieldNumber = 8,
    kOccupyTopFieldNumber = 9,
    kSelfFieldNumber = 10,
    kBuildingIdFieldNumber = 2,
    kCountFieldNumber = 3,
    kStartTimeFieldNumber = 6,
    kEndTimeFieldNumber = 7,
    kScaleFieldNumber = 4,
  };
  // repeated int32 combatant_guilds = 5;
  int combatant_guilds_size() const;
  private:
  int _internal_combatant_guilds_size() const;
  public:
  void clear_combatant_guilds();
  private:
  int32_t _internal_combatant_guilds(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_combatant_guilds() const;
  void _internal_add_combatant_guilds(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_combatant_guilds();
  public:
  int32_t combatant_guilds(int index) const;
  void set_combatant_guilds(int index, int32_t value);
  void add_combatant_guilds(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      combatant_guilds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_combatant_guilds();

  // .pb.map.HEX pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // .pb.map.CombatantUser honor_top = 8;
  bool has_honor_top() const;
  private:
  bool _internal_has_honor_top() const;
  public:
  void clear_honor_top();
  const ::pb::map::CombatantUser& honor_top() const;
  PROTOBUF_NODISCARD ::pb::map::CombatantUser* release_honor_top();
  ::pb::map::CombatantUser* mutable_honor_top();
  void set_allocated_honor_top(::pb::map::CombatantUser* honor_top);
  private:
  const ::pb::map::CombatantUser& _internal_honor_top() const;
  ::pb::map::CombatantUser* _internal_mutable_honor_top();
  public:
  void unsafe_arena_set_allocated_honor_top(
      ::pb::map::CombatantUser* honor_top);
  ::pb::map::CombatantUser* unsafe_arena_release_honor_top();

  // .pb.map.CombatantUser occupy_top = 9;
  bool has_occupy_top() const;
  private:
  bool _internal_has_occupy_top() const;
  public:
  void clear_occupy_top();
  const ::pb::map::CombatantUser& occupy_top() const;
  PROTOBUF_NODISCARD ::pb::map::CombatantUser* release_occupy_top();
  ::pb::map::CombatantUser* mutable_occupy_top();
  void set_allocated_occupy_top(::pb::map::CombatantUser* occupy_top);
  private:
  const ::pb::map::CombatantUser& _internal_occupy_top() const;
  ::pb::map::CombatantUser* _internal_mutable_occupy_top();
  public:
  void unsafe_arena_set_allocated_occupy_top(
      ::pb::map::CombatantUser* occupy_top);
  ::pb::map::CombatantUser* unsafe_arena_release_occupy_top();

  // .pb.map.CombatantUser self = 10;
  bool has_self() const;
  private:
  bool _internal_has_self() const;
  public:
  void clear_self();
  const ::pb::map::CombatantUser& self() const;
  PROTOBUF_NODISCARD ::pb::map::CombatantUser* release_self();
  ::pb::map::CombatantUser* mutable_self();
  void set_allocated_self(::pb::map::CombatantUser* self);
  private:
  const ::pb::map::CombatantUser& _internal_self() const;
  ::pb::map::CombatantUser* _internal_mutable_self();
  public:
  void unsafe_arena_set_allocated_self(
      ::pb::map::CombatantUser* self);
  ::pb::map::CombatantUser* unsafe_arena_release_self();

  // int32 building_id = 2;
  void clear_building_id();
  int32_t building_id() const;
  void set_building_id(int32_t value);
  private:
  int32_t _internal_building_id() const;
  void _internal_set_building_id(int32_t value);
  public:

  // int32 count = 3;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // int64 start_time = 6;
  void clear_start_time();
  int64_t start_time() const;
  void set_start_time(int64_t value);
  private:
  int64_t _internal_start_time() const;
  void _internal_set_start_time(int64_t value);
  public:

  // int64 end_time = 7;
  void clear_end_time();
  int64_t end_time() const;
  void set_end_time(int64_t value);
  private:
  int64_t _internal_end_time() const;
  void _internal_set_end_time(int64_t value);
  public:

  // .pb.map.E_MapCampaignScale scale = 4;
  void clear_scale();
  ::pb::map::E_MapCampaignScale scale() const;
  void set_scale(::pb::map::E_MapCampaignScale value);
  private:
  ::pb::map::E_MapCampaignScale _internal_scale() const;
  void _internal_set_scale(::pb::map::E_MapCampaignScale value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.MapCampaign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > combatant_guilds_;
    mutable std::atomic<int> _combatant_guilds_cached_byte_size_;
    ::pb::map::HEX* pos_;
    ::pb::map::CombatantUser* honor_top_;
    ::pb::map::CombatantUser* occupy_top_;
    ::pb::map::CombatantUser* self_;
    int32_t building_id_;
    int32_t count_;
    int64_t start_time_;
    int64_t end_time_;
    int scale_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class MapCampaignResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.MapCampaignResp) */ {
 public:
  inline MapCampaignResp() : MapCampaignResp(nullptr) {}
  ~MapCampaignResp() override;
  explicit PROTOBUF_CONSTEXPR MapCampaignResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapCampaignResp(const MapCampaignResp& from);
  MapCampaignResp(MapCampaignResp&& from) noexcept
    : MapCampaignResp() {
    *this = ::std::move(from);
  }

  inline MapCampaignResp& operator=(const MapCampaignResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapCampaignResp& operator=(MapCampaignResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapCampaignResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapCampaignResp* internal_default_instance() {
    return reinterpret_cast<const MapCampaignResp*>(
               &_MapCampaignResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(MapCampaignResp& a, MapCampaignResp& b) {
    a.Swap(&b);
  }
  inline void Swap(MapCampaignResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapCampaignResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapCampaignResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapCampaignResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapCampaignResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapCampaignResp& from) {
    MapCampaignResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapCampaignResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.MapCampaignResp";
  }
  protected:
  explicit MapCampaignResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCampaignsFieldNumber = 1,
  };
  // repeated .pb.map.MapCampaign campaigns = 1;
  int campaigns_size() const;
  private:
  int _internal_campaigns_size() const;
  public:
  void clear_campaigns();
  ::pb::map::MapCampaign* mutable_campaigns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::MapCampaign >*
      mutable_campaigns();
  private:
  const ::pb::map::MapCampaign& _internal_campaigns(int index) const;
  ::pb::map::MapCampaign* _internal_add_campaigns();
  public:
  const ::pb::map::MapCampaign& campaigns(int index) const;
  ::pb::map::MapCampaign* add_campaigns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::MapCampaign >&
      campaigns() const;

  // @@protoc_insertion_point(class_scope:pb.map.MapCampaignResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::MapCampaign > campaigns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Country final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Country) */ {
 public:
  inline Country() : Country(nullptr) {}
  ~Country() override;
  explicit PROTOBUF_CONSTEXPR Country(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Country(const Country& from);
  Country(Country&& from) noexcept
    : Country() {
    *this = ::std::move(from);
  }

  inline Country& operator=(const Country& from) {
    CopyFrom(from);
    return *this;
  }
  inline Country& operator=(Country&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Country& default_instance() {
    return *internal_default_instance();
  }
  static inline const Country* internal_default_instance() {
    return reinterpret_cast<const Country*>(
               &_Country_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Country& a, Country& b) {
    a.Swap(&b);
  }
  inline void Swap(Country* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Country* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Country* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Country>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Country& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Country& from) {
    Country::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Country* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Country";
  }
  protected:
  explicit Country(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountryIdFieldNumber = 1,
    kNumFieldNumber = 2,
    kOpenFieldNumber = 3,
  };
  // int32 country_id = 1;
  void clear_country_id();
  int32_t country_id() const;
  void set_country_id(int32_t value);
  private:
  int32_t _internal_country_id() const;
  void _internal_set_country_id(int32_t value);
  public:

  // int32 num = 2;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // int32 open = 3;
  void clear_open();
  int32_t open() const;
  void set_open(int32_t value);
  private:
  int32_t _internal_open() const;
  void _internal_set_open(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Country)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t country_id_;
    int32_t num_;
    int32_t open_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Country_Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Country_Info) */ {
 public:
  inline Country_Info() : Country_Info(nullptr) {}
  ~Country_Info() override;
  explicit PROTOBUF_CONSTEXPR Country_Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Country_Info(const Country_Info& from);
  Country_Info(Country_Info&& from) noexcept
    : Country_Info() {
    *this = ::std::move(from);
  }

  inline Country_Info& operator=(const Country_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Country_Info& operator=(Country_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Country_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Country_Info* internal_default_instance() {
    return reinterpret_cast<const Country_Info*>(
               &_Country_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Country_Info& a, Country_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Country_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Country_Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Country_Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Country_Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Country_Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Country_Info& from) {
    Country_Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Country_Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Country_Info";
  }
  protected:
  explicit Country_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountriesFieldNumber = 1,
  };
  // repeated .pb.map.Country countries = 1;
  int countries_size() const;
  private:
  int _internal_countries_size() const;
  public:
  void clear_countries();
  ::pb::map::Country* mutable_countries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Country >*
      mutable_countries();
  private:
  const ::pb::map::Country& _internal_countries(int index) const;
  ::pb::map::Country* _internal_add_countries();
  public:
  const ::pb::map::Country& countries(int index) const;
  ::pb::map::Country* add_countries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Country >&
      countries() const;

  // @@protoc_insertion_point(class_scope:pb.map.Country_Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Country > countries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Choose_Country final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Choose_Country) */ {
 public:
  inline Choose_Country() : Choose_Country(nullptr) {}
  ~Choose_Country() override;
  explicit PROTOBUF_CONSTEXPR Choose_Country(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Choose_Country(const Choose_Country& from);
  Choose_Country(Choose_Country&& from) noexcept
    : Choose_Country() {
    *this = ::std::move(from);
  }

  inline Choose_Country& operator=(const Choose_Country& from) {
    CopyFrom(from);
    return *this;
  }
  inline Choose_Country& operator=(Choose_Country&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Choose_Country& default_instance() {
    return *internal_default_instance();
  }
  static inline const Choose_Country* internal_default_instance() {
    return reinterpret_cast<const Choose_Country*>(
               &_Choose_Country_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Choose_Country& a, Choose_Country& b) {
    a.Swap(&b);
  }
  inline void Swap(Choose_Country* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Choose_Country* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Choose_Country* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Choose_Country>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Choose_Country& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Choose_Country& from) {
    Choose_Country::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Choose_Country* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Choose_Country";
  }
  protected:
  explicit Choose_Country(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kCountryIdFieldNumber = 2,
  };
  // uint32 error_code = 1;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // int32 country_id = 2;
  void clear_country_id();
  int32_t country_id() const;
  void set_country_id(int32_t value);
  private:
  int32_t _internal_country_id() const;
  void _internal_set_country_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Choose_Country)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t error_code_;
    int32_t country_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class CampaignScale final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.CampaignScale) */ {
 public:
  inline CampaignScale() : CampaignScale(nullptr) {}
  ~CampaignScale() override;
  explicit PROTOBUF_CONSTEXPR CampaignScale(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CampaignScale(const CampaignScale& from);
  CampaignScale(CampaignScale&& from) noexcept
    : CampaignScale() {
    *this = ::std::move(from);
  }

  inline CampaignScale& operator=(const CampaignScale& from) {
    CopyFrom(from);
    return *this;
  }
  inline CampaignScale& operator=(CampaignScale&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CampaignScale& default_instance() {
    return *internal_default_instance();
  }
  static inline const CampaignScale* internal_default_instance() {
    return reinterpret_cast<const CampaignScale*>(
               &_CampaignScale_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CampaignScale& a, CampaignScale& b) {
    a.Swap(&b);
  }
  inline void Swap(CampaignScale* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CampaignScale* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CampaignScale* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CampaignScale>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CampaignScale& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CampaignScale& from) {
    CampaignScale::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CampaignScale* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.CampaignScale";
  }
  protected:
  explicit CampaignScale(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kScaleFieldNumber = 2,
    kFinishFieldNumber = 3,
  };
  // .pb.map.HEX pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pb::map::HEX& pos() const;
  PROTOBUF_NODISCARD ::pb::map::HEX* release_pos();
  ::pb::map::HEX* mutable_pos();
  void set_allocated_pos(::pb::map::HEX* pos);
  private:
  const ::pb::map::HEX& _internal_pos() const;
  ::pb::map::HEX* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pb::map::HEX* pos);
  ::pb::map::HEX* unsafe_arena_release_pos();

  // int32 scale = 2;
  void clear_scale();
  int32_t scale() const;
  void set_scale(int32_t value);
  private:
  int32_t _internal_scale() const;
  void _internal_set_scale(int32_t value);
  public:

  // bool finish = 3;
  void clear_finish();
  bool finish() const;
  void set_finish(bool value);
  private:
  bool _internal_finish() const;
  void _internal_set_finish(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.CampaignScale)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::map::HEX* pos_;
    int32_t scale_;
    bool finish_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Req_SearchMapObj final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Req_SearchMapObj) */ {
 public:
  inline Req_SearchMapObj() : Req_SearchMapObj(nullptr) {}
  ~Req_SearchMapObj() override;
  explicit PROTOBUF_CONSTEXPR Req_SearchMapObj(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Req_SearchMapObj(const Req_SearchMapObj& from);
  Req_SearchMapObj(Req_SearchMapObj&& from) noexcept
    : Req_SearchMapObj() {
    *this = ::std::move(from);
  }

  inline Req_SearchMapObj& operator=(const Req_SearchMapObj& from) {
    CopyFrom(from);
    return *this;
  }
  inline Req_SearchMapObj& operator=(Req_SearchMapObj&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Req_SearchMapObj& default_instance() {
    return *internal_default_instance();
  }
  static inline const Req_SearchMapObj* internal_default_instance() {
    return reinterpret_cast<const Req_SearchMapObj*>(
               &_Req_SearchMapObj_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Req_SearchMapObj& a, Req_SearchMapObj& b) {
    a.Swap(&b);
  }
  inline void Swap(Req_SearchMapObj* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Req_SearchMapObj* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Req_SearchMapObj* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Req_SearchMapObj>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Req_SearchMapObj& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Req_SearchMapObj& from) {
    Req_SearchMapObj::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Req_SearchMapObj* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Req_SearchMapObj";
  }
  protected:
  explicit Req_SearchMapObj(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kRFieldNumber = 2,
    kExhaleFieldNumber = 3,
    kObjKindFieldNumber = 4,
    kObjTypeFieldNumber = 5,
    kObjLevelMinFieldNumber = 6,
    kObjLevelMaxFieldNumber = 7,
    kObjBelongFieldNumber = 8,
  };
  // int32 q = 1;
  void clear_q();
  int32_t q() const;
  void set_q(int32_t value);
  private:
  int32_t _internal_q() const;
  void _internal_set_q(int32_t value);
  public:

  // int32 r = 2;
  void clear_r();
  int32_t r() const;
  void set_r(int32_t value);
  private:
  int32_t _internal_r() const;
  void _internal_set_r(int32_t value);
  public:

  // int32 exhale = 3;
  void clear_exhale();
  int32_t exhale() const;
  void set_exhale(int32_t value);
  private:
  int32_t _internal_exhale() const;
  void _internal_set_exhale(int32_t value);
  public:

  // int32 obj_kind = 4;
  void clear_obj_kind();
  int32_t obj_kind() const;
  void set_obj_kind(int32_t value);
  private:
  int32_t _internal_obj_kind() const;
  void _internal_set_obj_kind(int32_t value);
  public:

  // int32 obj_type = 5;
  void clear_obj_type();
  int32_t obj_type() const;
  void set_obj_type(int32_t value);
  private:
  int32_t _internal_obj_type() const;
  void _internal_set_obj_type(int32_t value);
  public:

  // int32 obj_level_min = 6;
  void clear_obj_level_min();
  int32_t obj_level_min() const;
  void set_obj_level_min(int32_t value);
  private:
  int32_t _internal_obj_level_min() const;
  void _internal_set_obj_level_min(int32_t value);
  public:

  // int32 obj_level_max = 7;
  void clear_obj_level_max();
  int32_t obj_level_max() const;
  void set_obj_level_max(int32_t value);
  private:
  int32_t _internal_obj_level_max() const;
  void _internal_set_obj_level_max(int32_t value);
  public:

  // int32 obj_belong = 8;
  void clear_obj_belong();
  int32_t obj_belong() const;
  void set_obj_belong(int32_t value);
  private:
  int32_t _internal_obj_belong() const;
  void _internal_set_obj_belong(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Req_SearchMapObj)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t q_;
    int32_t r_;
    int32_t exhale_;
    int32_t obj_kind_;
    int32_t obj_type_;
    int32_t obj_level_min_;
    int32_t obj_level_max_;
    int32_t obj_belong_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Rep_SearchMapObj final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Rep_SearchMapObj) */ {
 public:
  inline Rep_SearchMapObj() : Rep_SearchMapObj(nullptr) {}
  ~Rep_SearchMapObj() override;
  explicit PROTOBUF_CONSTEXPR Rep_SearchMapObj(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rep_SearchMapObj(const Rep_SearchMapObj& from);
  Rep_SearchMapObj(Rep_SearchMapObj&& from) noexcept
    : Rep_SearchMapObj() {
    *this = ::std::move(from);
  }

  inline Rep_SearchMapObj& operator=(const Rep_SearchMapObj& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rep_SearchMapObj& operator=(Rep_SearchMapObj&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rep_SearchMapObj& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rep_SearchMapObj* internal_default_instance() {
    return reinterpret_cast<const Rep_SearchMapObj*>(
               &_Rep_SearchMapObj_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Rep_SearchMapObj& a, Rep_SearchMapObj& b) {
    a.Swap(&b);
  }
  inline void Swap(Rep_SearchMapObj* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rep_SearchMapObj* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rep_SearchMapObj* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rep_SearchMapObj>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rep_SearchMapObj& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rep_SearchMapObj& from) {
    Rep_SearchMapObj::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rep_SearchMapObj* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Rep_SearchMapObj";
  }
  protected:
  explicit Rep_SearchMapObj(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLstHexFieldNumber = 3,
    kErrorCodeFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // repeated .pb.map.HEX lst_hex = 3;
  int lst_hex_size() const;
  private:
  int _internal_lst_hex_size() const;
  public:
  void clear_lst_hex();
  ::pb::map::HEX* mutable_lst_hex(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >*
      mutable_lst_hex();
  private:
  const ::pb::map::HEX& _internal_lst_hex(int index) const;
  ::pb::map::HEX* _internal_add_lst_hex();
  public:
  const ::pb::map::HEX& lst_hex(int index) const;
  ::pb::map::HEX* add_lst_hex();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >&
      lst_hex() const;

  // uint32 error_code = 1;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // int32 result = 2;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Rep_SearchMapObj)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX > lst_hex_;
    uint32_t error_code_;
    int32_t result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class TimerTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.TimerTask) */ {
 public:
  inline TimerTask() : TimerTask(nullptr) {}
  ~TimerTask() override;
  explicit PROTOBUF_CONSTEXPR TimerTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimerTask(const TimerTask& from);
  TimerTask(TimerTask&& from) noexcept
    : TimerTask() {
    *this = ::std::move(from);
  }

  inline TimerTask& operator=(const TimerTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimerTask& operator=(TimerTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimerTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimerTask* internal_default_instance() {
    return reinterpret_cast<const TimerTask*>(
               &_TimerTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(TimerTask& a, TimerTask& b) {
    a.Swap(&b);
  }
  inline void Swap(TimerTask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimerTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimerTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimerTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimerTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimerTask& from) {
    TimerTask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimerTask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.TimerTask";
  }
  protected:
  explicit TimerTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPbParamFieldNumber = 7,
    kIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kEndTimeFieldNumber = 4,
    kIdLinkFieldNumber = 5,
    kParamFieldNumber = 6,
    kTypeFieldNumber = 3,
  };
  // bytes pb_param = 7;
  void clear_pb_param();
  const std::string& pb_param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pb_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pb_param();
  PROTOBUF_NODISCARD std::string* release_pb_param();
  void set_allocated_pb_param(std::string* pb_param);
  private:
  const std::string& _internal_pb_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pb_param(const std::string& value);
  std::string* _internal_mutable_pb_param();
  public:

  // int64 id = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // int64 user_id = 2;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // int64 end_time = 4;
  void clear_end_time();
  int64_t end_time() const;
  void set_end_time(int64_t value);
  private:
  int64_t _internal_end_time() const;
  void _internal_set_end_time(int64_t value);
  public:

  // int64 id_link = 5;
  void clear_id_link();
  int64_t id_link() const;
  void set_id_link(int64_t value);
  private:
  int64_t _internal_id_link() const;
  void _internal_set_id_link(int64_t value);
  public:

  // int64 param = 6;
  void clear_param();
  int64_t param() const;
  void set_param(int64_t value);
  private:
  int64_t _internal_param() const;
  void _internal_set_param(int64_t value);
  public:

  // uint32 type = 3;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.TimerTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pb_param_;
    int64_t id_;
    int64_t user_id_;
    int64_t end_time_;
    int64_t id_link_;
    int64_t param_;
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Rep_Timer_list final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Rep_Timer_list) */ {
 public:
  inline Rep_Timer_list() : Rep_Timer_list(nullptr) {}
  ~Rep_Timer_list() override;
  explicit PROTOBUF_CONSTEXPR Rep_Timer_list(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rep_Timer_list(const Rep_Timer_list& from);
  Rep_Timer_list(Rep_Timer_list&& from) noexcept
    : Rep_Timer_list() {
    *this = ::std::move(from);
  }

  inline Rep_Timer_list& operator=(const Rep_Timer_list& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rep_Timer_list& operator=(Rep_Timer_list&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rep_Timer_list& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rep_Timer_list* internal_default_instance() {
    return reinterpret_cast<const Rep_Timer_list*>(
               &_Rep_Timer_list_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Rep_Timer_list& a, Rep_Timer_list& b) {
    a.Swap(&b);
  }
  inline void Swap(Rep_Timer_list* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rep_Timer_list* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rep_Timer_list* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rep_Timer_list>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rep_Timer_list& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rep_Timer_list& from) {
    Rep_Timer_list::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rep_Timer_list* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Rep_Timer_list";
  }
  protected:
  explicit Rep_Timer_list(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLstFieldNumber = 1,
  };
  // repeated .pb.map.TimerTask lst = 1;
  int lst_size() const;
  private:
  int _internal_lst_size() const;
  public:
  void clear_lst();
  ::pb::map::TimerTask* mutable_lst(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::TimerTask >*
      mutable_lst();
  private:
  const ::pb::map::TimerTask& _internal_lst(int index) const;
  ::pb::map::TimerTask* _internal_add_lst();
  public:
  const ::pb::map::TimerTask& lst(int index) const;
  ::pb::map::TimerTask* add_lst();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::TimerTask >&
      lst() const;

  // @@protoc_insertion_point(class_scope:pb.map.Rep_Timer_list)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::TimerTask > lst_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Req_ChgMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Req_ChgMap) */ {
 public:
  inline Req_ChgMap() : Req_ChgMap(nullptr) {}
  ~Req_ChgMap() override;
  explicit PROTOBUF_CONSTEXPR Req_ChgMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Req_ChgMap(const Req_ChgMap& from);
  Req_ChgMap(Req_ChgMap&& from) noexcept
    : Req_ChgMap() {
    *this = ::std::move(from);
  }

  inline Req_ChgMap& operator=(const Req_ChgMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Req_ChgMap& operator=(Req_ChgMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Req_ChgMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const Req_ChgMap* internal_default_instance() {
    return reinterpret_cast<const Req_ChgMap*>(
               &_Req_ChgMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(Req_ChgMap& a, Req_ChgMap& b) {
    a.Swap(&b);
  }
  inline void Swap(Req_ChgMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Req_ChgMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Req_ChgMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Req_ChgMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Req_ChgMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Req_ChgMap& from) {
    Req_ChgMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Req_ChgMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Req_ChgMap";
  }
  protected:
  explicit Req_ChgMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kMapTypeFieldNumber = 2,
  };
  // uint32 error_code = 1;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // uint32 mapType = 2;
  void clear_maptype();
  uint32_t maptype() const;
  void set_maptype(uint32_t value);
  private:
  uint32_t _internal_maptype() const;
  void _internal_set_maptype(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.map.Req_ChgMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t error_code_;
    uint32_t maptype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// -------------------------------------------------------------------

class Req_Map_Chk_View final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.map.Req_Map_Chk_View) */ {
 public:
  inline Req_Map_Chk_View() : Req_Map_Chk_View(nullptr) {}
  ~Req_Map_Chk_View() override;
  explicit PROTOBUF_CONSTEXPR Req_Map_Chk_View(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Req_Map_Chk_View(const Req_Map_Chk_View& from);
  Req_Map_Chk_View(Req_Map_Chk_View&& from) noexcept
    : Req_Map_Chk_View() {
    *this = ::std::move(from);
  }

  inline Req_Map_Chk_View& operator=(const Req_Map_Chk_View& from) {
    CopyFrom(from);
    return *this;
  }
  inline Req_Map_Chk_View& operator=(Req_Map_Chk_View&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Req_Map_Chk_View& default_instance() {
    return *internal_default_instance();
  }
  static inline const Req_Map_Chk_View* internal_default_instance() {
    return reinterpret_cast<const Req_Map_Chk_View*>(
               &_Req_Map_Chk_View_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(Req_Map_Chk_View& a, Req_Map_Chk_View& b) {
    a.Swap(&b);
  }
  inline void Swap(Req_Map_Chk_View* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Req_Map_Chk_View* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Req_Map_Chk_View* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Req_Map_Chk_View>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Req_Map_Chk_View& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Req_Map_Chk_View& from) {
    Req_Map_Chk_View::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Req_Map_Chk_View* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.map.Req_Map_Chk_View";
  }
  protected:
  explicit Req_Map_Chk_View(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecChkTroopLstFieldNumber = 1,
    kVecChkBuildingsLstFieldNumber = 2,
  };
  // repeated int64 vec_chk_troop_lst = 1;
  int vec_chk_troop_lst_size() const;
  private:
  int _internal_vec_chk_troop_lst_size() const;
  public:
  void clear_vec_chk_troop_lst();
  private:
  int64_t _internal_vec_chk_troop_lst(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_vec_chk_troop_lst() const;
  void _internal_add_vec_chk_troop_lst(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_vec_chk_troop_lst();
  public:
  int64_t vec_chk_troop_lst(int index) const;
  void set_vec_chk_troop_lst(int index, int64_t value);
  void add_vec_chk_troop_lst(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      vec_chk_troop_lst() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_vec_chk_troop_lst();

  // repeated int64 vec_chk_buildings_lst = 2;
  int vec_chk_buildings_lst_size() const;
  private:
  int _internal_vec_chk_buildings_lst_size() const;
  public:
  void clear_vec_chk_buildings_lst();
  private:
  int64_t _internal_vec_chk_buildings_lst(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_vec_chk_buildings_lst() const;
  void _internal_add_vec_chk_buildings_lst(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_vec_chk_buildings_lst();
  public:
  int64_t vec_chk_buildings_lst(int index) const;
  void set_vec_chk_buildings_lst(int index, int64_t value);
  void add_vec_chk_buildings_lst(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      vec_chk_buildings_lst() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_vec_chk_buildings_lst();

  // @@protoc_insertion_point(class_scope:pb.map.Req_Map_Chk_View)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > vec_chk_troop_lst_;
    mutable std::atomic<int> _vec_chk_troop_lst_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > vec_chk_buildings_lst_;
    mutable std::atomic<int> _vec_chk_buildings_lst_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_map_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Base_Operate

// .pb.map.E_Map_CMD cmd = 1;
inline void Base_Operate::clear_cmd() {
  _impl_.cmd_ = 0;
}
inline ::pb::map::E_Map_CMD Base_Operate::_internal_cmd() const {
  return static_cast< ::pb::map::E_Map_CMD >(_impl_.cmd_);
}
inline ::pb::map::E_Map_CMD Base_Operate::cmd() const {
  // @@protoc_insertion_point(field_get:pb.map.Base_Operate.cmd)
  return _internal_cmd();
}
inline void Base_Operate::_internal_set_cmd(::pb::map::E_Map_CMD value) {
  
  _impl_.cmd_ = value;
}
inline void Base_Operate::set_cmd(::pb::map::E_Map_CMD value) {
  _internal_set_cmd(value);
  // @@protoc_insertion_point(field_set:pb.map.Base_Operate.cmd)
}

// uint32 error_code = 2;
inline void Base_Operate::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t Base_Operate::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t Base_Operate::error_code() const {
  // @@protoc_insertion_point(field_get:pb.map.Base_Operate.error_code)
  return _internal_error_code();
}
inline void Base_Operate::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Base_Operate::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pb.map.Base_Operate.error_code)
}

// -------------------------------------------------------------------

// HEX

// int32 q = 1;
inline void HEX::clear_q() {
  _impl_.q_ = 0;
}
inline int32_t HEX::_internal_q() const {
  return _impl_.q_;
}
inline int32_t HEX::q() const {
  // @@protoc_insertion_point(field_get:pb.map.HEX.q)
  return _internal_q();
}
inline void HEX::_internal_set_q(int32_t value) {
  
  _impl_.q_ = value;
}
inline void HEX::set_q(int32_t value) {
  _internal_set_q(value);
  // @@protoc_insertion_point(field_set:pb.map.HEX.q)
}

// int32 r = 2;
inline void HEX::clear_r() {
  _impl_.r_ = 0;
}
inline int32_t HEX::_internal_r() const {
  return _impl_.r_;
}
inline int32_t HEX::r() const {
  // @@protoc_insertion_point(field_get:pb.map.HEX.r)
  return _internal_r();
}
inline void HEX::_internal_set_r(int32_t value) {
  
  _impl_.r_ = value;
}
inline void HEX::set_r(int32_t value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:pb.map.HEX.r)
}

// -------------------------------------------------------------------

// Resp_MapOperate

// int64 troop_id = 1;
inline void Resp_MapOperate::clear_troop_id() {
  _impl_.troop_id_ = int64_t{0};
}
inline int64_t Resp_MapOperate::_internal_troop_id() const {
  return _impl_.troop_id_;
}
inline int64_t Resp_MapOperate::troop_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Resp_MapOperate.troop_id)
  return _internal_troop_id();
}
inline void Resp_MapOperate::_internal_set_troop_id(int64_t value) {
  
  _impl_.troop_id_ = value;
}
inline void Resp_MapOperate::set_troop_id(int64_t value) {
  _internal_set_troop_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Resp_MapOperate.troop_id)
}

// .pb.map.E_Map_CMD op = 2;
inline void Resp_MapOperate::clear_op() {
  _impl_.op_ = 0;
}
inline ::pb::map::E_Map_CMD Resp_MapOperate::_internal_op() const {
  return static_cast< ::pb::map::E_Map_CMD >(_impl_.op_);
}
inline ::pb::map::E_Map_CMD Resp_MapOperate::op() const {
  // @@protoc_insertion_point(field_get:pb.map.Resp_MapOperate.op)
  return _internal_op();
}
inline void Resp_MapOperate::_internal_set_op(::pb::map::E_Map_CMD value) {
  
  _impl_.op_ = value;
}
inline void Resp_MapOperate::set_op(::pb::map::E_Map_CMD value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:pb.map.Resp_MapOperate.op)
}

// -------------------------------------------------------------------

// Building

// uint32 idx = 1;
inline void Building::clear_idx() {
  _impl_.idx_ = 0u;
}
inline uint32_t Building::_internal_idx() const {
  return _impl_.idx_;
}
inline uint32_t Building::idx() const {
  // @@protoc_insertion_point(field_get:pb.map.Building.idx)
  return _internal_idx();
}
inline void Building::_internal_set_idx(uint32_t value) {
  
  _impl_.idx_ = value;
}
inline void Building::set_idx(uint32_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:pb.map.Building.idx)
}

// uint32 type = 2;
inline void Building::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t Building::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t Building::type() const {
  // @@protoc_insertion_point(field_get:pb.map.Building.type)
  return _internal_type();
}
inline void Building::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void Building::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.map.Building.type)
}

// uint32 level = 3;
inline void Building::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t Building::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t Building::level() const {
  // @@protoc_insertion_point(field_get:pb.map.Building.level)
  return _internal_level();
}
inline void Building::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void Building::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:pb.map.Building.level)
}

// .pb.map.HEX pos = 4;
inline bool Building::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Building::has_pos() const {
  return _internal_has_pos();
}
inline void Building::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& Building::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Building::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Building.pos)
  return _internal_pos();
}
inline void Building::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Building.pos)
}
inline ::pb::map::HEX* Building::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Building::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Building.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Building::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* Building::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Building.pos)
  return _msg;
}
inline void Building::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Building.pos)
}

// -------------------------------------------------------------------

// Troop_Map_OP

// uint32 error_code = 1;
inline void Troop_Map_OP::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t Troop_Map_OP::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t Troop_Map_OP::error_code() const {
  // @@protoc_insertion_point(field_get:pb.map.Troop_Map_OP.error_code)
  return _internal_error_code();
}
inline void Troop_Map_OP::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Troop_Map_OP::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pb.map.Troop_Map_OP.error_code)
}

// .pb.map.HEX end_pos = 2;
inline bool Troop_Map_OP::_internal_has_end_pos() const {
  return this != internal_default_instance() && _impl_.end_pos_ != nullptr;
}
inline bool Troop_Map_OP::has_end_pos() const {
  return _internal_has_end_pos();
}
inline void Troop_Map_OP::clear_end_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.end_pos_ != nullptr) {
    delete _impl_.end_pos_;
  }
  _impl_.end_pos_ = nullptr;
}
inline const ::pb::map::HEX& Troop_Map_OP::_internal_end_pos() const {
  const ::pb::map::HEX* p = _impl_.end_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Troop_Map_OP::end_pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Troop_Map_OP.end_pos)
  return _internal_end_pos();
}
inline void Troop_Map_OP::unsafe_arena_set_allocated_end_pos(
    ::pb::map::HEX* end_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_pos_);
  }
  _impl_.end_pos_ = end_pos;
  if (end_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Troop_Map_OP.end_pos)
}
inline ::pb::map::HEX* Troop_Map_OP::release_end_pos() {
  
  ::pb::map::HEX* temp = _impl_.end_pos_;
  _impl_.end_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Troop_Map_OP::unsafe_arena_release_end_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Troop_Map_OP.end_pos)
  
  ::pb::map::HEX* temp = _impl_.end_pos_;
  _impl_.end_pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Troop_Map_OP::_internal_mutable_end_pos() {
  
  if (_impl_.end_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.end_pos_ = p;
  }
  return _impl_.end_pos_;
}
inline ::pb::map::HEX* Troop_Map_OP::mutable_end_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_end_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Troop_Map_OP.end_pos)
  return _msg;
}
inline void Troop_Map_OP::set_allocated_end_pos(::pb::map::HEX* end_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.end_pos_;
  }
  if (end_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end_pos);
    if (message_arena != submessage_arena) {
      end_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_pos_ = end_pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Troop_Map_OP.end_pos)
}

// uint32 idx_troop = 3;
inline void Troop_Map_OP::clear_idx_troop() {
  _impl_.idx_troop_ = 0u;
}
inline uint32_t Troop_Map_OP::_internal_idx_troop() const {
  return _impl_.idx_troop_;
}
inline uint32_t Troop_Map_OP::idx_troop() const {
  // @@protoc_insertion_point(field_get:pb.map.Troop_Map_OP.idx_troop)
  return _internal_idx_troop();
}
inline void Troop_Map_OP::_internal_set_idx_troop(uint32_t value) {
  
  _impl_.idx_troop_ = value;
}
inline void Troop_Map_OP::set_idx_troop(uint32_t value) {
  _internal_set_idx_troop(value);
  // @@protoc_insertion_point(field_set:pb.map.Troop_Map_OP.idx_troop)
}

// uint32 count = 4;
inline void Troop_Map_OP::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t Troop_Map_OP::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t Troop_Map_OP::count() const {
  // @@protoc_insertion_point(field_get:pb.map.Troop_Map_OP.count)
  return _internal_count();
}
inline void Troop_Map_OP::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void Troop_Map_OP::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:pb.map.Troop_Map_OP.count)
}

// uint32 is_autoreturn = 5;
inline void Troop_Map_OP::clear_is_autoreturn() {
  _impl_.is_autoreturn_ = 0u;
}
inline uint32_t Troop_Map_OP::_internal_is_autoreturn() const {
  return _impl_.is_autoreturn_;
}
inline uint32_t Troop_Map_OP::is_autoreturn() const {
  // @@protoc_insertion_point(field_get:pb.map.Troop_Map_OP.is_autoreturn)
  return _internal_is_autoreturn();
}
inline void Troop_Map_OP::_internal_set_is_autoreturn(uint32_t value) {
  
  _impl_.is_autoreturn_ = value;
}
inline void Troop_Map_OP::set_is_autoreturn(uint32_t value) {
  _internal_set_is_autoreturn(value);
  // @@protoc_insertion_point(field_set:pb.map.Troop_Map_OP.is_autoreturn)
}

// uint32 target_type = 6;
inline void Troop_Map_OP::clear_target_type() {
  _impl_.target_type_ = 0u;
}
inline uint32_t Troop_Map_OP::_internal_target_type() const {
  return _impl_.target_type_;
}
inline uint32_t Troop_Map_OP::target_type() const {
  // @@protoc_insertion_point(field_get:pb.map.Troop_Map_OP.target_type)
  return _internal_target_type();
}
inline void Troop_Map_OP::_internal_set_target_type(uint32_t value) {
  
  _impl_.target_type_ = value;
}
inline void Troop_Map_OP::set_target_type(uint32_t value) {
  _internal_set_target_type(value);
  // @@protoc_insertion_point(field_set:pb.map.Troop_Map_OP.target_type)
}

// -------------------------------------------------------------------

// Robot_AI_Model

// uint32 error_code = 1;
inline void Robot_AI_Model::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t Robot_AI_Model::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t Robot_AI_Model::error_code() const {
  // @@protoc_insertion_point(field_get:pb.map.Robot_AI_Model.error_code)
  return _internal_error_code();
}
inline void Robot_AI_Model::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Robot_AI_Model::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pb.map.Robot_AI_Model.error_code)
}

// uint32 idx_troop = 2;
inline void Robot_AI_Model::clear_idx_troop() {
  _impl_.idx_troop_ = 0u;
}
inline uint32_t Robot_AI_Model::_internal_idx_troop() const {
  return _impl_.idx_troop_;
}
inline uint32_t Robot_AI_Model::idx_troop() const {
  // @@protoc_insertion_point(field_get:pb.map.Robot_AI_Model.idx_troop)
  return _internal_idx_troop();
}
inline void Robot_AI_Model::_internal_set_idx_troop(uint32_t value) {
  
  _impl_.idx_troop_ = value;
}
inline void Robot_AI_Model::set_idx_troop(uint32_t value) {
  _internal_set_idx_troop(value);
  // @@protoc_insertion_point(field_set:pb.map.Robot_AI_Model.idx_troop)
}

// .pb.map.E_AIBehavior_Type ai_type = 3;
inline void Robot_AI_Model::clear_ai_type() {
  _impl_.ai_type_ = 0;
}
inline ::pb::map::E_AIBehavior_Type Robot_AI_Model::_internal_ai_type() const {
  return static_cast< ::pb::map::E_AIBehavior_Type >(_impl_.ai_type_);
}
inline ::pb::map::E_AIBehavior_Type Robot_AI_Model::ai_type() const {
  // @@protoc_insertion_point(field_get:pb.map.Robot_AI_Model.ai_type)
  return _internal_ai_type();
}
inline void Robot_AI_Model::_internal_set_ai_type(::pb::map::E_AIBehavior_Type value) {
  
  _impl_.ai_type_ = value;
}
inline void Robot_AI_Model::set_ai_type(::pb::map::E_AIBehavior_Type value) {
  _internal_set_ai_type(value);
  // @@protoc_insertion_point(field_set:pb.map.Robot_AI_Model.ai_type)
}

// .pb.map.HEX center_pos = 4;
inline bool Robot_AI_Model::_internal_has_center_pos() const {
  return this != internal_default_instance() && _impl_.center_pos_ != nullptr;
}
inline bool Robot_AI_Model::has_center_pos() const {
  return _internal_has_center_pos();
}
inline void Robot_AI_Model::clear_center_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.center_pos_ != nullptr) {
    delete _impl_.center_pos_;
  }
  _impl_.center_pos_ = nullptr;
}
inline const ::pb::map::HEX& Robot_AI_Model::_internal_center_pos() const {
  const ::pb::map::HEX* p = _impl_.center_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Robot_AI_Model::center_pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Robot_AI_Model.center_pos)
  return _internal_center_pos();
}
inline void Robot_AI_Model::unsafe_arena_set_allocated_center_pos(
    ::pb::map::HEX* center_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.center_pos_);
  }
  _impl_.center_pos_ = center_pos;
  if (center_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Robot_AI_Model.center_pos)
}
inline ::pb::map::HEX* Robot_AI_Model::release_center_pos() {
  
  ::pb::map::HEX* temp = _impl_.center_pos_;
  _impl_.center_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Robot_AI_Model::unsafe_arena_release_center_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Robot_AI_Model.center_pos)
  
  ::pb::map::HEX* temp = _impl_.center_pos_;
  _impl_.center_pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Robot_AI_Model::_internal_mutable_center_pos() {
  
  if (_impl_.center_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.center_pos_ = p;
  }
  return _impl_.center_pos_;
}
inline ::pb::map::HEX* Robot_AI_Model::mutable_center_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_center_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Robot_AI_Model.center_pos)
  return _msg;
}
inline void Robot_AI_Model::set_allocated_center_pos(::pb::map::HEX* center_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.center_pos_;
  }
  if (center_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(center_pos);
    if (message_arena != submessage_arena) {
      center_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.center_pos_ = center_pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Robot_AI_Model.center_pos)
}

// .pb.map.HEX start_pos = 5;
inline bool Robot_AI_Model::_internal_has_start_pos() const {
  return this != internal_default_instance() && _impl_.start_pos_ != nullptr;
}
inline bool Robot_AI_Model::has_start_pos() const {
  return _internal_has_start_pos();
}
inline void Robot_AI_Model::clear_start_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.start_pos_ != nullptr) {
    delete _impl_.start_pos_;
  }
  _impl_.start_pos_ = nullptr;
}
inline const ::pb::map::HEX& Robot_AI_Model::_internal_start_pos() const {
  const ::pb::map::HEX* p = _impl_.start_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Robot_AI_Model::start_pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Robot_AI_Model.start_pos)
  return _internal_start_pos();
}
inline void Robot_AI_Model::unsafe_arena_set_allocated_start_pos(
    ::pb::map::HEX* start_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_pos_);
  }
  _impl_.start_pos_ = start_pos;
  if (start_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Robot_AI_Model.start_pos)
}
inline ::pb::map::HEX* Robot_AI_Model::release_start_pos() {
  
  ::pb::map::HEX* temp = _impl_.start_pos_;
  _impl_.start_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Robot_AI_Model::unsafe_arena_release_start_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Robot_AI_Model.start_pos)
  
  ::pb::map::HEX* temp = _impl_.start_pos_;
  _impl_.start_pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Robot_AI_Model::_internal_mutable_start_pos() {
  
  if (_impl_.start_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.start_pos_ = p;
  }
  return _impl_.start_pos_;
}
inline ::pb::map::HEX* Robot_AI_Model::mutable_start_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_start_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Robot_AI_Model.start_pos)
  return _msg;
}
inline void Robot_AI_Model::set_allocated_start_pos(::pb::map::HEX* start_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_pos_;
  }
  if (start_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start_pos);
    if (message_arena != submessage_arena) {
      start_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_pos_ = start_pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Robot_AI_Model.start_pos)
}

// .pb.map.HEX end_pos = 6;
inline bool Robot_AI_Model::_internal_has_end_pos() const {
  return this != internal_default_instance() && _impl_.end_pos_ != nullptr;
}
inline bool Robot_AI_Model::has_end_pos() const {
  return _internal_has_end_pos();
}
inline void Robot_AI_Model::clear_end_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.end_pos_ != nullptr) {
    delete _impl_.end_pos_;
  }
  _impl_.end_pos_ = nullptr;
}
inline const ::pb::map::HEX& Robot_AI_Model::_internal_end_pos() const {
  const ::pb::map::HEX* p = _impl_.end_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Robot_AI_Model::end_pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Robot_AI_Model.end_pos)
  return _internal_end_pos();
}
inline void Robot_AI_Model::unsafe_arena_set_allocated_end_pos(
    ::pb::map::HEX* end_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_pos_);
  }
  _impl_.end_pos_ = end_pos;
  if (end_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Robot_AI_Model.end_pos)
}
inline ::pb::map::HEX* Robot_AI_Model::release_end_pos() {
  
  ::pb::map::HEX* temp = _impl_.end_pos_;
  _impl_.end_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Robot_AI_Model::unsafe_arena_release_end_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Robot_AI_Model.end_pos)
  
  ::pb::map::HEX* temp = _impl_.end_pos_;
  _impl_.end_pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Robot_AI_Model::_internal_mutable_end_pos() {
  
  if (_impl_.end_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.end_pos_ = p;
  }
  return _impl_.end_pos_;
}
inline ::pb::map::HEX* Robot_AI_Model::mutable_end_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_end_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Robot_AI_Model.end_pos)
  return _msg;
}
inline void Robot_AI_Model::set_allocated_end_pos(::pb::map::HEX* end_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.end_pos_;
  }
  if (end_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end_pos);
    if (message_arena != submessage_arena) {
      end_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_pos_ = end_pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Robot_AI_Model.end_pos)
}

// int32 alter_radius = 7;
inline void Robot_AI_Model::clear_alter_radius() {
  _impl_.alter_radius_ = 0;
}
inline int32_t Robot_AI_Model::_internal_alter_radius() const {
  return _impl_.alter_radius_;
}
inline int32_t Robot_AI_Model::alter_radius() const {
  // @@protoc_insertion_point(field_get:pb.map.Robot_AI_Model.alter_radius)
  return _internal_alter_radius();
}
inline void Robot_AI_Model::_internal_set_alter_radius(int32_t value) {
  
  _impl_.alter_radius_ = value;
}
inline void Robot_AI_Model::set_alter_radius(int32_t value) {
  _internal_set_alter_radius(value);
  // @@protoc_insertion_point(field_set:pb.map.Robot_AI_Model.alter_radius)
}

// bool is_clockwise = 8;
inline void Robot_AI_Model::clear_is_clockwise() {
  _impl_.is_clockwise_ = false;
}
inline bool Robot_AI_Model::_internal_is_clockwise() const {
  return _impl_.is_clockwise_;
}
inline bool Robot_AI_Model::is_clockwise() const {
  // @@protoc_insertion_point(field_get:pb.map.Robot_AI_Model.is_clockwise)
  return _internal_is_clockwise();
}
inline void Robot_AI_Model::_internal_set_is_clockwise(bool value) {
  
  _impl_.is_clockwise_ = value;
}
inline void Robot_AI_Model::set_is_clockwise(bool value) {
  _internal_set_is_clockwise(value);
  // @@protoc_insertion_point(field_set:pb.map.Robot_AI_Model.is_clockwise)
}

// -------------------------------------------------------------------

// Troop_Path_Query

// uint32 error_code = 1;
inline void Troop_Path_Query::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t Troop_Path_Query::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t Troop_Path_Query::error_code() const {
  // @@protoc_insertion_point(field_get:pb.map.Troop_Path_Query.error_code)
  return _internal_error_code();
}
inline void Troop_Path_Query::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Troop_Path_Query::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pb.map.Troop_Path_Query.error_code)
}

// .pb.map.HEX end_pos = 2;
inline bool Troop_Path_Query::_internal_has_end_pos() const {
  return this != internal_default_instance() && _impl_.end_pos_ != nullptr;
}
inline bool Troop_Path_Query::has_end_pos() const {
  return _internal_has_end_pos();
}
inline void Troop_Path_Query::clear_end_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.end_pos_ != nullptr) {
    delete _impl_.end_pos_;
  }
  _impl_.end_pos_ = nullptr;
}
inline const ::pb::map::HEX& Troop_Path_Query::_internal_end_pos() const {
  const ::pb::map::HEX* p = _impl_.end_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Troop_Path_Query::end_pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Troop_Path_Query.end_pos)
  return _internal_end_pos();
}
inline void Troop_Path_Query::unsafe_arena_set_allocated_end_pos(
    ::pb::map::HEX* end_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_pos_);
  }
  _impl_.end_pos_ = end_pos;
  if (end_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Troop_Path_Query.end_pos)
}
inline ::pb::map::HEX* Troop_Path_Query::release_end_pos() {
  
  ::pb::map::HEX* temp = _impl_.end_pos_;
  _impl_.end_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Troop_Path_Query::unsafe_arena_release_end_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Troop_Path_Query.end_pos)
  
  ::pb::map::HEX* temp = _impl_.end_pos_;
  _impl_.end_pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Troop_Path_Query::_internal_mutable_end_pos() {
  
  if (_impl_.end_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.end_pos_ = p;
  }
  return _impl_.end_pos_;
}
inline ::pb::map::HEX* Troop_Path_Query::mutable_end_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_end_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Troop_Path_Query.end_pos)
  return _msg;
}
inline void Troop_Path_Query::set_allocated_end_pos(::pb::map::HEX* end_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.end_pos_;
  }
  if (end_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end_pos);
    if (message_arena != submessage_arena) {
      end_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_pos_ = end_pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Troop_Path_Query.end_pos)
}

// uint32 idx_troop = 3;
inline void Troop_Path_Query::clear_idx_troop() {
  _impl_.idx_troop_ = 0u;
}
inline uint32_t Troop_Path_Query::_internal_idx_troop() const {
  return _impl_.idx_troop_;
}
inline uint32_t Troop_Path_Query::idx_troop() const {
  // @@protoc_insertion_point(field_get:pb.map.Troop_Path_Query.idx_troop)
  return _internal_idx_troop();
}
inline void Troop_Path_Query::_internal_set_idx_troop(uint32_t value) {
  
  _impl_.idx_troop_ = value;
}
inline void Troop_Path_Query::set_idx_troop(uint32_t value) {
  _internal_set_idx_troop(value);
  // @@protoc_insertion_point(field_set:pb.map.Troop_Path_Query.idx_troop)
}

// .pb.map.E_Map_CMD sub_cmd = 4;
inline void Troop_Path_Query::clear_sub_cmd() {
  _impl_.sub_cmd_ = 0;
}
inline ::pb::map::E_Map_CMD Troop_Path_Query::_internal_sub_cmd() const {
  return static_cast< ::pb::map::E_Map_CMD >(_impl_.sub_cmd_);
}
inline ::pb::map::E_Map_CMD Troop_Path_Query::sub_cmd() const {
  // @@protoc_insertion_point(field_get:pb.map.Troop_Path_Query.sub_cmd)
  return _internal_sub_cmd();
}
inline void Troop_Path_Query::_internal_set_sub_cmd(::pb::map::E_Map_CMD value) {
  
  _impl_.sub_cmd_ = value;
}
inline void Troop_Path_Query::set_sub_cmd(::pb::map::E_Map_CMD value) {
  _internal_set_sub_cmd(value);
  // @@protoc_insertion_point(field_set:pb.map.Troop_Path_Query.sub_cmd)
}

// -------------------------------------------------------------------

// Obstacle_Path

// int32 troop_id = 1;
inline void Obstacle_Path::clear_troop_id() {
  _impl_.troop_id_ = 0;
}
inline int32_t Obstacle_Path::_internal_troop_id() const {
  return _impl_.troop_id_;
}
inline int32_t Obstacle_Path::troop_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Obstacle_Path.troop_id)
  return _internal_troop_id();
}
inline void Obstacle_Path::_internal_set_troop_id(int32_t value) {
  
  _impl_.troop_id_ = value;
}
inline void Obstacle_Path::set_troop_id(int32_t value) {
  _internal_set_troop_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Obstacle_Path.troop_id)
}

// .pb.map.HEX obstacle_pt = 2;
inline bool Obstacle_Path::_internal_has_obstacle_pt() const {
  return this != internal_default_instance() && _impl_.obstacle_pt_ != nullptr;
}
inline bool Obstacle_Path::has_obstacle_pt() const {
  return _internal_has_obstacle_pt();
}
inline void Obstacle_Path::clear_obstacle_pt() {
  if (GetArenaForAllocation() == nullptr && _impl_.obstacle_pt_ != nullptr) {
    delete _impl_.obstacle_pt_;
  }
  _impl_.obstacle_pt_ = nullptr;
}
inline const ::pb::map::HEX& Obstacle_Path::_internal_obstacle_pt() const {
  const ::pb::map::HEX* p = _impl_.obstacle_pt_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Obstacle_Path::obstacle_pt() const {
  // @@protoc_insertion_point(field_get:pb.map.Obstacle_Path.obstacle_pt)
  return _internal_obstacle_pt();
}
inline void Obstacle_Path::unsafe_arena_set_allocated_obstacle_pt(
    ::pb::map::HEX* obstacle_pt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obstacle_pt_);
  }
  _impl_.obstacle_pt_ = obstacle_pt;
  if (obstacle_pt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Obstacle_Path.obstacle_pt)
}
inline ::pb::map::HEX* Obstacle_Path::release_obstacle_pt() {
  
  ::pb::map::HEX* temp = _impl_.obstacle_pt_;
  _impl_.obstacle_pt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Obstacle_Path::unsafe_arena_release_obstacle_pt() {
  // @@protoc_insertion_point(field_release:pb.map.Obstacle_Path.obstacle_pt)
  
  ::pb::map::HEX* temp = _impl_.obstacle_pt_;
  _impl_.obstacle_pt_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Obstacle_Path::_internal_mutable_obstacle_pt() {
  
  if (_impl_.obstacle_pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.obstacle_pt_ = p;
  }
  return _impl_.obstacle_pt_;
}
inline ::pb::map::HEX* Obstacle_Path::mutable_obstacle_pt() {
  ::pb::map::HEX* _msg = _internal_mutable_obstacle_pt();
  // @@protoc_insertion_point(field_mutable:pb.map.Obstacle_Path.obstacle_pt)
  return _msg;
}
inline void Obstacle_Path::set_allocated_obstacle_pt(::pb::map::HEX* obstacle_pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.obstacle_pt_;
  }
  if (obstacle_pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(obstacle_pt);
    if (message_arena != submessage_arena) {
      obstacle_pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obstacle_pt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.obstacle_pt_ = obstacle_pt;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Obstacle_Path.obstacle_pt)
}

// repeated .pb.map.HEX vec_startobs = 3;
inline int Obstacle_Path::_internal_vec_startobs_size() const {
  return _impl_.vec_startobs_.size();
}
inline int Obstacle_Path::vec_startobs_size() const {
  return _internal_vec_startobs_size();
}
inline void Obstacle_Path::clear_vec_startobs() {
  _impl_.vec_startobs_.Clear();
}
inline ::pb::map::HEX* Obstacle_Path::mutable_vec_startobs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Obstacle_Path.vec_startobs)
  return _impl_.vec_startobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >*
Obstacle_Path::mutable_vec_startobs() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Obstacle_Path.vec_startobs)
  return &_impl_.vec_startobs_;
}
inline const ::pb::map::HEX& Obstacle_Path::_internal_vec_startobs(int index) const {
  return _impl_.vec_startobs_.Get(index);
}
inline const ::pb::map::HEX& Obstacle_Path::vec_startobs(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Obstacle_Path.vec_startobs)
  return _internal_vec_startobs(index);
}
inline ::pb::map::HEX* Obstacle_Path::_internal_add_vec_startobs() {
  return _impl_.vec_startobs_.Add();
}
inline ::pb::map::HEX* Obstacle_Path::add_vec_startobs() {
  ::pb::map::HEX* _add = _internal_add_vec_startobs();
  // @@protoc_insertion_point(field_add:pb.map.Obstacle_Path.vec_startobs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >&
Obstacle_Path::vec_startobs() const {
  // @@protoc_insertion_point(field_list:pb.map.Obstacle_Path.vec_startobs)
  return _impl_.vec_startobs_;
}

// repeated .pb.map.HEX vec_endobs = 4;
inline int Obstacle_Path::_internal_vec_endobs_size() const {
  return _impl_.vec_endobs_.size();
}
inline int Obstacle_Path::vec_endobs_size() const {
  return _internal_vec_endobs_size();
}
inline void Obstacle_Path::clear_vec_endobs() {
  _impl_.vec_endobs_.Clear();
}
inline ::pb::map::HEX* Obstacle_Path::mutable_vec_endobs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Obstacle_Path.vec_endobs)
  return _impl_.vec_endobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >*
Obstacle_Path::mutable_vec_endobs() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Obstacle_Path.vec_endobs)
  return &_impl_.vec_endobs_;
}
inline const ::pb::map::HEX& Obstacle_Path::_internal_vec_endobs(int index) const {
  return _impl_.vec_endobs_.Get(index);
}
inline const ::pb::map::HEX& Obstacle_Path::vec_endobs(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Obstacle_Path.vec_endobs)
  return _internal_vec_endobs(index);
}
inline ::pb::map::HEX* Obstacle_Path::_internal_add_vec_endobs() {
  return _impl_.vec_endobs_.Add();
}
inline ::pb::map::HEX* Obstacle_Path::add_vec_endobs() {
  ::pb::map::HEX* _add = _internal_add_vec_endobs();
  // @@protoc_insertion_point(field_add:pb.map.Obstacle_Path.vec_endobs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >&
Obstacle_Path::vec_endobs() const {
  // @@protoc_insertion_point(field_list:pb.map.Obstacle_Path.vec_endobs)
  return _impl_.vec_endobs_;
}

// -------------------------------------------------------------------

// March_Path

// int32 troop_id = 1;
inline void March_Path::clear_troop_id() {
  _impl_.troop_id_ = 0;
}
inline int32_t March_Path::_internal_troop_id() const {
  return _impl_.troop_id_;
}
inline int32_t March_Path::troop_id() const {
  // @@protoc_insertion_point(field_get:pb.map.March_Path.troop_id)
  return _internal_troop_id();
}
inline void March_Path::_internal_set_troop_id(int32_t value) {
  
  _impl_.troop_id_ = value;
}
inline void March_Path::set_troop_id(int32_t value) {
  _internal_set_troop_id(value);
  // @@protoc_insertion_point(field_set:pb.map.March_Path.troop_id)
}

// uint32 hero_id = 2;
inline void March_Path::clear_hero_id() {
  _impl_.hero_id_ = 0u;
}
inline uint32_t March_Path::_internal_hero_id() const {
  return _impl_.hero_id_;
}
inline uint32_t March_Path::hero_id() const {
  // @@protoc_insertion_point(field_get:pb.map.March_Path.hero_id)
  return _internal_hero_id();
}
inline void March_Path::_internal_set_hero_id(uint32_t value) {
  
  _impl_.hero_id_ = value;
}
inline void March_Path::set_hero_id(uint32_t value) {
  _internal_set_hero_id(value);
  // @@protoc_insertion_point(field_set:pb.map.March_Path.hero_id)
}

// uint32 soldier_id = 3;
inline void March_Path::clear_soldier_id() {
  _impl_.soldier_id_ = 0u;
}
inline uint32_t March_Path::_internal_soldier_id() const {
  return _impl_.soldier_id_;
}
inline uint32_t March_Path::soldier_id() const {
  // @@protoc_insertion_point(field_get:pb.map.March_Path.soldier_id)
  return _internal_soldier_id();
}
inline void March_Path::_internal_set_soldier_id(uint32_t value) {
  
  _impl_.soldier_id_ = value;
}
inline void March_Path::set_soldier_id(uint32_t value) {
  _internal_set_soldier_id(value);
  // @@protoc_insertion_point(field_set:pb.map.March_Path.soldier_id)
}

// string name = 4;
inline void March_Path::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& March_Path::name() const {
  // @@protoc_insertion_point(field_get:pb.map.March_Path.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void March_Path::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.map.March_Path.name)
}
inline std::string* March_Path::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pb.map.March_Path.name)
  return _s;
}
inline const std::string& March_Path::_internal_name() const {
  return _impl_.name_.Get();
}
inline void March_Path::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* March_Path::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* March_Path::release_name() {
  // @@protoc_insertion_point(field_release:pb.map.March_Path.name)
  return _impl_.name_.Release();
}
inline void March_Path::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.map.March_Path.name)
}

// uint32 idx_troop = 5;
inline void March_Path::clear_idx_troop() {
  _impl_.idx_troop_ = 0u;
}
inline uint32_t March_Path::_internal_idx_troop() const {
  return _impl_.idx_troop_;
}
inline uint32_t March_Path::idx_troop() const {
  // @@protoc_insertion_point(field_get:pb.map.March_Path.idx_troop)
  return _internal_idx_troop();
}
inline void March_Path::_internal_set_idx_troop(uint32_t value) {
  
  _impl_.idx_troop_ = value;
}
inline void March_Path::set_idx_troop(uint32_t value) {
  _internal_set_idx_troop(value);
  // @@protoc_insertion_point(field_set:pb.map.March_Path.idx_troop)
}

// uint32 speed = 6;
inline void March_Path::clear_speed() {
  _impl_.speed_ = 0u;
}
inline uint32_t March_Path::_internal_speed() const {
  return _impl_.speed_;
}
inline uint32_t March_Path::speed() const {
  // @@protoc_insertion_point(field_get:pb.map.March_Path.speed)
  return _internal_speed();
}
inline void March_Path::_internal_set_speed(uint32_t value) {
  
  _impl_.speed_ = value;
}
inline void March_Path::set_speed(uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:pb.map.March_Path.speed)
}

// repeated .pb.map.HEX vec_path = 7;
inline int March_Path::_internal_vec_path_size() const {
  return _impl_.vec_path_.size();
}
inline int March_Path::vec_path_size() const {
  return _internal_vec_path_size();
}
inline void March_Path::clear_vec_path() {
  _impl_.vec_path_.Clear();
}
inline ::pb::map::HEX* March_Path::mutable_vec_path(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.March_Path.vec_path)
  return _impl_.vec_path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >*
March_Path::mutable_vec_path() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.March_Path.vec_path)
  return &_impl_.vec_path_;
}
inline const ::pb::map::HEX& March_Path::_internal_vec_path(int index) const {
  return _impl_.vec_path_.Get(index);
}
inline const ::pb::map::HEX& March_Path::vec_path(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.March_Path.vec_path)
  return _internal_vec_path(index);
}
inline ::pb::map::HEX* March_Path::_internal_add_vec_path() {
  return _impl_.vec_path_.Add();
}
inline ::pb::map::HEX* March_Path::add_vec_path() {
  ::pb::map::HEX* _add = _internal_add_vec_path();
  // @@protoc_insertion_point(field_add:pb.map.March_Path.vec_path)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >&
March_Path::vec_path() const {
  // @@protoc_insertion_point(field_list:pb.map.March_Path.vec_path)
  return _impl_.vec_path_;
}

// int64 end_time = 8;
inline void March_Path::clear_end_time() {
  _impl_.end_time_ = int64_t{0};
}
inline int64_t March_Path::_internal_end_time() const {
  return _impl_.end_time_;
}
inline int64_t March_Path::end_time() const {
  // @@protoc_insertion_point(field_get:pb.map.March_Path.end_time)
  return _internal_end_time();
}
inline void March_Path::_internal_set_end_time(int64_t value) {
  
  _impl_.end_time_ = value;
}
inline void March_Path::set_end_time(int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:pb.map.March_Path.end_time)
}

// -------------------------------------------------------------------

// Ranking

// string user_name = 1;
inline void Ranking::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& Ranking::user_name() const {
  // @@protoc_insertion_point(field_get:pb.map.Ranking.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ranking::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.map.Ranking.user_name)
}
inline std::string* Ranking::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:pb.map.Ranking.user_name)
  return _s;
}
inline const std::string& Ranking::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void Ranking::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Ranking::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Ranking::release_user_name() {
  // @@protoc_insertion_point(field_release:pb.map.Ranking.user_name)
  return _impl_.user_name_.Release();
}
inline void Ranking::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.map.Ranking.user_name)
}

// uint32 value = 2;
inline void Ranking::clear_value() {
  _impl_.value_ = 0u;
}
inline uint32_t Ranking::_internal_value() const {
  return _impl_.value_;
}
inline uint32_t Ranking::value() const {
  // @@protoc_insertion_point(field_get:pb.map.Ranking.value)
  return _internal_value();
}
inline void Ranking::_internal_set_value(uint32_t value) {
  
  _impl_.value_ = value;
}
inline void Ranking::set_value(uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:pb.map.Ranking.value)
}

// -------------------------------------------------------------------

// Map_Building

// int64 owner_id = 1;
inline void Map_Building::clear_owner_id() {
  _impl_.owner_id_ = int64_t{0};
}
inline int64_t Map_Building::_internal_owner_id() const {
  return _impl_.owner_id_;
}
inline int64_t Map_Building::owner_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.owner_id)
  return _internal_owner_id();
}
inline void Map_Building::_internal_set_owner_id(int64_t value) {
  
  _impl_.owner_id_ = value;
}
inline void Map_Building::set_owner_id(int64_t value) {
  _internal_set_owner_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.owner_id)
}

// uint32 skin_id = 2;
inline void Map_Building::clear_skin_id() {
  _impl_.skin_id_ = 0u;
}
inline uint32_t Map_Building::_internal_skin_id() const {
  return _impl_.skin_id_;
}
inline uint32_t Map_Building::skin_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.skin_id)
  return _internal_skin_id();
}
inline void Map_Building::_internal_set_skin_id(uint32_t value) {
  
  _impl_.skin_id_ = value;
}
inline void Map_Building::set_skin_id(uint32_t value) {
  _internal_set_skin_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.skin_id)
}

// .pb.map.HEX pos = 3;
inline bool Map_Building::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Map_Building::has_pos() const {
  return _internal_has_pos();
}
inline void Map_Building::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& Map_Building::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Map_Building::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.pos)
  return _internal_pos();
}
inline void Map_Building::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Map_Building.pos)
}
inline ::pb::map::HEX* Map_Building::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Map_Building::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Map_Building.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Map_Building::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* Map_Building::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Building.pos)
  return _msg;
}
inline void Map_Building::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Map_Building.pos)
}

// uint32 type = 4;
inline void Map_Building::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t Map_Building::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t Map_Building::type() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.type)
  return _internal_type();
}
inline void Map_Building::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void Map_Building::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.type)
}

// int32 id = 5;
inline void Map_Building::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Map_Building::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Map_Building::id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.id)
  return _internal_id();
}
inline void Map_Building::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Map_Building::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.id)
}

// uint32 life = 6;
inline void Map_Building::clear_life() {
  _impl_.life_ = 0u;
}
inline uint32_t Map_Building::_internal_life() const {
  return _impl_.life_;
}
inline uint32_t Map_Building::life() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.life)
  return _internal_life();
}
inline void Map_Building::_internal_set_life(uint32_t value) {
  
  _impl_.life_ = value;
}
inline void Map_Building::set_life(uint32_t value) {
  _internal_set_life(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.life)
}

// uint32 life_max = 7;
inline void Map_Building::clear_life_max() {
  _impl_.life_max_ = 0u;
}
inline uint32_t Map_Building::_internal_life_max() const {
  return _impl_.life_max_;
}
inline uint32_t Map_Building::life_max() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.life_max)
  return _internal_life_max();
}
inline void Map_Building::_internal_set_life_max(uint32_t value) {
  
  _impl_.life_max_ = value;
}
inline void Map_Building::set_life_max(uint32_t value) {
  _internal_set_life_max(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.life_max)
}

// uint32 troop_num = 8;
inline void Map_Building::clear_troop_num() {
  _impl_.troop_num_ = 0u;
}
inline uint32_t Map_Building::_internal_troop_num() const {
  return _impl_.troop_num_;
}
inline uint32_t Map_Building::troop_num() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.troop_num)
  return _internal_troop_num();
}
inline void Map_Building::_internal_set_troop_num(uint32_t value) {
  
  _impl_.troop_num_ = value;
}
inline void Map_Building::set_troop_num(uint32_t value) {
  _internal_set_troop_num(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.troop_num)
}

// int64 reset_time = 9;
inline void Map_Building::clear_reset_time() {
  _impl_.reset_time_ = int64_t{0};
}
inline int64_t Map_Building::_internal_reset_time() const {
  return _impl_.reset_time_;
}
inline int64_t Map_Building::reset_time() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.reset_time)
  return _internal_reset_time();
}
inline void Map_Building::_internal_set_reset_time(int64_t value) {
  
  _impl_.reset_time_ = value;
}
inline void Map_Building::set_reset_time(int64_t value) {
  _internal_set_reset_time(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.reset_time)
}

// int64 avoid_battle_time = 10;
inline void Map_Building::clear_avoid_battle_time() {
  _impl_.avoid_battle_time_ = int64_t{0};
}
inline int64_t Map_Building::_internal_avoid_battle_time() const {
  return _impl_.avoid_battle_time_;
}
inline int64_t Map_Building::avoid_battle_time() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.avoid_battle_time)
  return _internal_avoid_battle_time();
}
inline void Map_Building::_internal_set_avoid_battle_time(int64_t value) {
  
  _impl_.avoid_battle_time_ = value;
}
inline void Map_Building::set_avoid_battle_time(int64_t value) {
  _internal_set_avoid_battle_time(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.avoid_battle_time)
}

// int64 close_city_time = 11;
inline void Map_Building::clear_close_city_time() {
  _impl_.close_city_time_ = int64_t{0};
}
inline int64_t Map_Building::_internal_close_city_time() const {
  return _impl_.close_city_time_;
}
inline int64_t Map_Building::close_city_time() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.close_city_time)
  return _internal_close_city_time();
}
inline void Map_Building::_internal_set_close_city_time(int64_t value) {
  
  _impl_.close_city_time_ = value;
}
inline void Map_Building::set_close_city_time(int64_t value) {
  _internal_set_close_city_time(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.close_city_time)
}

// repeated .pb.map.Ranking first_kill_top_three = 12;
inline int Map_Building::_internal_first_kill_top_three_size() const {
  return _impl_.first_kill_top_three_.size();
}
inline int Map_Building::first_kill_top_three_size() const {
  return _internal_first_kill_top_three_size();
}
inline void Map_Building::clear_first_kill_top_three() {
  _impl_.first_kill_top_three_.Clear();
}
inline ::pb::map::Ranking* Map_Building::mutable_first_kill_top_three(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Building.first_kill_top_three)
  return _impl_.first_kill_top_three_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Ranking >*
Map_Building::mutable_first_kill_top_three() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Map_Building.first_kill_top_three)
  return &_impl_.first_kill_top_three_;
}
inline const ::pb::map::Ranking& Map_Building::_internal_first_kill_top_three(int index) const {
  return _impl_.first_kill_top_three_.Get(index);
}
inline const ::pb::map::Ranking& Map_Building::first_kill_top_three(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.first_kill_top_three)
  return _internal_first_kill_top_three(index);
}
inline ::pb::map::Ranking* Map_Building::_internal_add_first_kill_top_three() {
  return _impl_.first_kill_top_three_.Add();
}
inline ::pb::map::Ranking* Map_Building::add_first_kill_top_three() {
  ::pb::map::Ranking* _add = _internal_add_first_kill_top_three();
  // @@protoc_insertion_point(field_add:pb.map.Map_Building.first_kill_top_three)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Ranking >&
Map_Building::first_kill_top_three() const {
  // @@protoc_insertion_point(field_list:pb.map.Map_Building.first_kill_top_three)
  return _impl_.first_kill_top_three_;
}

// repeated .pb.map.Ranking first_siege_top_three = 13;
inline int Map_Building::_internal_first_siege_top_three_size() const {
  return _impl_.first_siege_top_three_.size();
}
inline int Map_Building::first_siege_top_three_size() const {
  return _internal_first_siege_top_three_size();
}
inline void Map_Building::clear_first_siege_top_three() {
  _impl_.first_siege_top_three_.Clear();
}
inline ::pb::map::Ranking* Map_Building::mutable_first_siege_top_three(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Building.first_siege_top_three)
  return _impl_.first_siege_top_three_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Ranking >*
Map_Building::mutable_first_siege_top_three() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Map_Building.first_siege_top_three)
  return &_impl_.first_siege_top_three_;
}
inline const ::pb::map::Ranking& Map_Building::_internal_first_siege_top_three(int index) const {
  return _impl_.first_siege_top_three_.Get(index);
}
inline const ::pb::map::Ranking& Map_Building::first_siege_top_three(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.first_siege_top_three)
  return _internal_first_siege_top_three(index);
}
inline ::pb::map::Ranking* Map_Building::_internal_add_first_siege_top_three() {
  return _impl_.first_siege_top_three_.Add();
}
inline ::pb::map::Ranking* Map_Building::add_first_siege_top_three() {
  ::pb::map::Ranking* _add = _internal_add_first_siege_top_three();
  // @@protoc_insertion_point(field_add:pb.map.Map_Building.first_siege_top_three)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Ranking >&
Map_Building::first_siege_top_three() const {
  // @@protoc_insertion_point(field_list:pb.map.Map_Building.first_siege_top_three)
  return _impl_.first_siege_top_three_;
}

// uint32 guildid = 14;
inline void Map_Building::clear_guildid() {
  _impl_.guildid_ = 0u;
}
inline uint32_t Map_Building::_internal_guildid() const {
  return _impl_.guildid_;
}
inline uint32_t Map_Building::guildid() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.guildid)
  return _internal_guildid();
}
inline void Map_Building::_internal_set_guildid(uint32_t value) {
  
  _impl_.guildid_ = value;
}
inline void Map_Building::set_guildid(uint32_t value) {
  _internal_set_guildid(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.guildid)
}

// uint32 level = 15;
inline void Map_Building::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t Map_Building::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t Map_Building::level() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.level)
  return _internal_level();
}
inline void Map_Building::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void Map_Building::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.level)
}

// string name = 16;
inline void Map_Building::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Map_Building::name() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Map_Building::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.name)
}
inline std::string* Map_Building::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Building.name)
  return _s;
}
inline const std::string& Map_Building::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Map_Building::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Map_Building::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Map_Building::release_name() {
  // @@protoc_insertion_point(field_release:pb.map.Map_Building.name)
  return _impl_.name_.Release();
}
inline void Map_Building::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.map.Map_Building.name)
}

// uint32 buildingeye = 17;
inline void Map_Building::clear_buildingeye() {
  _impl_.buildingeye_ = 0u;
}
inline uint32_t Map_Building::_internal_buildingeye() const {
  return _impl_.buildingeye_;
}
inline uint32_t Map_Building::buildingeye() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.buildingeye)
  return _internal_buildingeye();
}
inline void Map_Building::_internal_set_buildingeye(uint32_t value) {
  
  _impl_.buildingeye_ = value;
}
inline void Map_Building::set_buildingeye(uint32_t value) {
  _internal_set_buildingeye(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.buildingeye)
}

// uint32 protect_flag = 18;
inline void Map_Building::clear_protect_flag() {
  _impl_.protect_flag_ = 0u;
}
inline uint32_t Map_Building::_internal_protect_flag() const {
  return _impl_.protect_flag_;
}
inline uint32_t Map_Building::protect_flag() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Building.protect_flag)
  return _internal_protect_flag();
}
inline void Map_Building::_internal_set_protect_flag(uint32_t value) {
  
  _impl_.protect_flag_ = value;
}
inline void Map_Building::set_protect_flag(uint32_t value) {
  _internal_set_protect_flag(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Building.protect_flag)
}

// -------------------------------------------------------------------

// Map_Troop

// int32 troop_id = 1;
inline void Map_Troop::clear_troop_id() {
  _impl_.troop_id_ = 0;
}
inline int32_t Map_Troop::_internal_troop_id() const {
  return _impl_.troop_id_;
}
inline int32_t Map_Troop::troop_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.troop_id)
  return _internal_troop_id();
}
inline void Map_Troop::_internal_set_troop_id(int32_t value) {
  
  _impl_.troop_id_ = value;
}
inline void Map_Troop::set_troop_id(int32_t value) {
  _internal_set_troop_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Troop.troop_id)
}

// int64 owner_id = 2;
inline void Map_Troop::clear_owner_id() {
  _impl_.owner_id_ = int64_t{0};
}
inline int64_t Map_Troop::_internal_owner_id() const {
  return _impl_.owner_id_;
}
inline int64_t Map_Troop::owner_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.owner_id)
  return _internal_owner_id();
}
inline void Map_Troop::_internal_set_owner_id(int64_t value) {
  
  _impl_.owner_id_ = value;
}
inline void Map_Troop::set_owner_id(int64_t value) {
  _internal_set_owner_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Troop.owner_id)
}

// uint32 soldier_id = 3;
inline void Map_Troop::clear_soldier_id() {
  _impl_.soldier_id_ = 0u;
}
inline uint32_t Map_Troop::_internal_soldier_id() const {
  return _impl_.soldier_id_;
}
inline uint32_t Map_Troop::soldier_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.soldier_id)
  return _internal_soldier_id();
}
inline void Map_Troop::_internal_set_soldier_id(uint32_t value) {
  
  _impl_.soldier_id_ = value;
}
inline void Map_Troop::set_soldier_id(uint32_t value) {
  _internal_set_soldier_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Troop.soldier_id)
}

// .pb.map.HEX pos = 4;
inline bool Map_Troop::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Map_Troop::has_pos() const {
  return _internal_has_pos();
}
inline void Map_Troop::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& Map_Troop::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Map_Troop::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.pos)
  return _internal_pos();
}
inline void Map_Troop::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Map_Troop.pos)
}
inline ::pb::map::HEX* Map_Troop::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Map_Troop::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Map_Troop.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Map_Troop::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* Map_Troop::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Troop.pos)
  return _msg;
}
inline void Map_Troop::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Map_Troop.pos)
}

// uint32 status = 5;
inline void Map_Troop::clear_status() {
  _impl_.status_ = 0u;
}
inline uint32_t Map_Troop::_internal_status() const {
  return _impl_.status_;
}
inline uint32_t Map_Troop::status() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.status)
  return _internal_status();
}
inline void Map_Troop::_internal_set_status(uint32_t value) {
  
  _impl_.status_ = value;
}
inline void Map_Troop::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Troop.status)
}

// uint32 idx_curpath = 6;
inline void Map_Troop::clear_idx_curpath() {
  _impl_.idx_curpath_ = 0u;
}
inline uint32_t Map_Troop::_internal_idx_curpath() const {
  return _impl_.idx_curpath_;
}
inline uint32_t Map_Troop::idx_curpath() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.idx_curpath)
  return _internal_idx_curpath();
}
inline void Map_Troop::_internal_set_idx_curpath(uint32_t value) {
  
  _impl_.idx_curpath_ = value;
}
inline void Map_Troop::set_idx_curpath(uint32_t value) {
  _internal_set_idx_curpath(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Troop.idx_curpath)
}

// uint32 time = 7;
inline void Map_Troop::clear_time() {
  _impl_.time_ = 0u;
}
inline uint32_t Map_Troop::_internal_time() const {
  return _impl_.time_;
}
inline uint32_t Map_Troop::time() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.time)
  return _internal_time();
}
inline void Map_Troop::_internal_set_time(uint32_t value) {
  
  _impl_.time_ = value;
}
inline void Map_Troop::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Troop.time)
}

// uint32 speed = 8;
inline void Map_Troop::clear_speed() {
  _impl_.speed_ = 0u;
}
inline uint32_t Map_Troop::_internal_speed() const {
  return _impl_.speed_;
}
inline uint32_t Map_Troop::speed() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.speed)
  return _internal_speed();
}
inline void Map_Troop::_internal_set_speed(uint32_t value) {
  
  _impl_.speed_ = value;
}
inline void Map_Troop::set_speed(uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Troop.speed)
}

// repeated .pb.map.HEX vec_path = 9;
inline int Map_Troop::_internal_vec_path_size() const {
  return _impl_.vec_path_.size();
}
inline int Map_Troop::vec_path_size() const {
  return _internal_vec_path_size();
}
inline void Map_Troop::clear_vec_path() {
  _impl_.vec_path_.Clear();
}
inline ::pb::map::HEX* Map_Troop::mutable_vec_path(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Troop.vec_path)
  return _impl_.vec_path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >*
Map_Troop::mutable_vec_path() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Map_Troop.vec_path)
  return &_impl_.vec_path_;
}
inline const ::pb::map::HEX& Map_Troop::_internal_vec_path(int index) const {
  return _impl_.vec_path_.Get(index);
}
inline const ::pb::map::HEX& Map_Troop::vec_path(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.vec_path)
  return _internal_vec_path(index);
}
inline ::pb::map::HEX* Map_Troop::_internal_add_vec_path() {
  return _impl_.vec_path_.Add();
}
inline ::pb::map::HEX* Map_Troop::add_vec_path() {
  ::pb::map::HEX* _add = _internal_add_vec_path();
  // @@protoc_insertion_point(field_add:pb.map.Map_Troop.vec_path)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >&
Map_Troop::vec_path() const {
  // @@protoc_insertion_point(field_list:pb.map.Map_Troop.vec_path)
  return _impl_.vec_path_;
}

// int64 end_time = 10;
inline void Map_Troop::clear_end_time() {
  _impl_.end_time_ = int64_t{0};
}
inline int64_t Map_Troop::_internal_end_time() const {
  return _impl_.end_time_;
}
inline int64_t Map_Troop::end_time() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.end_time)
  return _internal_end_time();
}
inline void Map_Troop::_internal_set_end_time(int64_t value) {
  
  _impl_.end_time_ = value;
}
inline void Map_Troop::set_end_time(int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Troop.end_time)
}

// uint32 morale = 11;
inline void Map_Troop::clear_morale() {
  _impl_.morale_ = 0u;
}
inline uint32_t Map_Troop::_internal_morale() const {
  return _impl_.morale_;
}
inline uint32_t Map_Troop::morale() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.morale)
  return _internal_morale();
}
inline void Map_Troop::_internal_set_morale(uint32_t value) {
  
  _impl_.morale_ = value;
}
inline void Map_Troop::set_morale(uint32_t value) {
  _internal_set_morale(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Troop.morale)
}

// uint32 protect_flag = 12;
inline void Map_Troop::clear_protect_flag() {
  _impl_.protect_flag_ = 0u;
}
inline uint32_t Map_Troop::_internal_protect_flag() const {
  return _impl_.protect_flag_;
}
inline uint32_t Map_Troop::protect_flag() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.protect_flag)
  return _internal_protect_flag();
}
inline void Map_Troop::_internal_set_protect_flag(uint32_t value) {
  
  _impl_.protect_flag_ = value;
}
inline void Map_Troop::set_protect_flag(uint32_t value) {
  _internal_set_protect_flag(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Troop.protect_flag)
}

// int32 dst_troop_id = 13;
inline void Map_Troop::clear_dst_troop_id() {
  _impl_.dst_troop_id_ = 0;
}
inline int32_t Map_Troop::_internal_dst_troop_id() const {
  return _impl_.dst_troop_id_;
}
inline int32_t Map_Troop::dst_troop_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Troop.dst_troop_id)
  return _internal_dst_troop_id();
}
inline void Map_Troop::_internal_set_dst_troop_id(int32_t value) {
  
  _impl_.dst_troop_id_ = value;
}
inline void Map_Troop::set_dst_troop_id(int32_t value) {
  _internal_set_dst_troop_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Troop.dst_troop_id)
}

// -------------------------------------------------------------------

// Map_Field

// int64 owner_id = 1;
inline void Map_Field::clear_owner_id() {
  _impl_.owner_id_ = int64_t{0};
}
inline int64_t Map_Field::_internal_owner_id() const {
  return _impl_.owner_id_;
}
inline int64_t Map_Field::owner_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Field.owner_id)
  return _internal_owner_id();
}
inline void Map_Field::_internal_set_owner_id(int64_t value) {
  
  _impl_.owner_id_ = value;
}
inline void Map_Field::set_owner_id(int64_t value) {
  _internal_set_owner_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Field.owner_id)
}

// .pb.map.HEX pos = 2;
inline bool Map_Field::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Map_Field::has_pos() const {
  return _internal_has_pos();
}
inline void Map_Field::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& Map_Field::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Map_Field::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Field.pos)
  return _internal_pos();
}
inline void Map_Field::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Map_Field.pos)
}
inline ::pb::map::HEX* Map_Field::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Map_Field::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Map_Field.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Map_Field::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* Map_Field::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Field.pos)
  return _msg;
}
inline void Map_Field::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Map_Field.pos)
}

// int32 field_id = 3;
inline void Map_Field::clear_field_id() {
  _impl_.field_id_ = 0;
}
inline int32_t Map_Field::_internal_field_id() const {
  return _impl_.field_id_;
}
inline int32_t Map_Field::field_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Field.field_id)
  return _internal_field_id();
}
inline void Map_Field::_internal_set_field_id(int32_t value) {
  
  _impl_.field_id_ = value;
}
inline void Map_Field::set_field_id(int32_t value) {
  _internal_set_field_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Field.field_id)
}

// uint32 type = 4;
inline void Map_Field::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t Map_Field::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t Map_Field::type() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Field.type)
  return _internal_type();
}
inline void Map_Field::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void Map_Field::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Field.type)
}

// uint32 Status = 5;
inline void Map_Field::clear_status() {
  _impl_.status_ = 0u;
}
inline uint32_t Map_Field::_internal_status() const {
  return _impl_.status_;
}
inline uint32_t Map_Field::status() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Field.Status)
  return _internal_status();
}
inline void Map_Field::_internal_set_status(uint32_t value) {
  
  _impl_.status_ = value;
}
inline void Map_Field::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Field.Status)
}

// uint32 FinishTime = 6;
inline void Map_Field::clear_finishtime() {
  _impl_.finishtime_ = 0u;
}
inline uint32_t Map_Field::_internal_finishtime() const {
  return _impl_.finishtime_;
}
inline uint32_t Map_Field::finishtime() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Field.FinishTime)
  return _internal_finishtime();
}
inline void Map_Field::_internal_set_finishtime(uint32_t value) {
  
  _impl_.finishtime_ = value;
}
inline void Map_Field::set_finishtime(uint32_t value) {
  _internal_set_finishtime(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Field.FinishTime)
}

// uint32 protect_flag = 7;
inline void Map_Field::clear_protect_flag() {
  _impl_.protect_flag_ = 0u;
}
inline uint32_t Map_Field::_internal_protect_flag() const {
  return _impl_.protect_flag_;
}
inline uint32_t Map_Field::protect_flag() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Field.protect_flag)
  return _internal_protect_flag();
}
inline void Map_Field::_internal_set_protect_flag(uint32_t value) {
  
  _impl_.protect_flag_ = value;
}
inline void Map_Field::set_protect_flag(uint32_t value) {
  _internal_set_protect_flag(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_Field.protect_flag)
}

// -------------------------------------------------------------------

// Map_RecoverField

// .pb.map.HEX pos = 1;
inline bool Map_RecoverField::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Map_RecoverField::has_pos() const {
  return _internal_has_pos();
}
inline void Map_RecoverField::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& Map_RecoverField::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Map_RecoverField::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_RecoverField.pos)
  return _internal_pos();
}
inline void Map_RecoverField::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Map_RecoverField.pos)
}
inline ::pb::map::HEX* Map_RecoverField::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Map_RecoverField::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Map_RecoverField.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Map_RecoverField::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* Map_RecoverField::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Map_RecoverField.pos)
  return _msg;
}
inline void Map_RecoverField::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Map_RecoverField.pos)
}

// int64 atk_user_id = 2;
inline void Map_RecoverField::clear_atk_user_id() {
  _impl_.atk_user_id_ = int64_t{0};
}
inline int64_t Map_RecoverField::_internal_atk_user_id() const {
  return _impl_.atk_user_id_;
}
inline int64_t Map_RecoverField::atk_user_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_RecoverField.atk_user_id)
  return _internal_atk_user_id();
}
inline void Map_RecoverField::_internal_set_atk_user_id(int64_t value) {
  
  _impl_.atk_user_id_ = value;
}
inline void Map_RecoverField::set_atk_user_id(int64_t value) {
  _internal_set_atk_user_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_RecoverField.atk_user_id)
}

// int64 end_time = 3;
inline void Map_RecoverField::clear_end_time() {
  _impl_.end_time_ = int64_t{0};
}
inline int64_t Map_RecoverField::_internal_end_time() const {
  return _impl_.end_time_;
}
inline int64_t Map_RecoverField::end_time() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_RecoverField.end_time)
  return _internal_end_time();
}
inline void Map_RecoverField::_internal_set_end_time(int64_t value) {
  
  _impl_.end_time_ = value;
}
inline void Map_RecoverField::set_end_time(int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_RecoverField.end_time)
}

// -------------------------------------------------------------------

// Map_WildNpcTroop

// uint32 id = 1;
inline void Map_WildNpcTroop::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t Map_WildNpcTroop::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t Map_WildNpcTroop::id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildNpcTroop.id)
  return _internal_id();
}
inline void Map_WildNpcTroop::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void Map_WildNpcTroop::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_WildNpcTroop.id)
}

// .pb.map.HEX pos = 2;
inline bool Map_WildNpcTroop::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Map_WildNpcTroop::has_pos() const {
  return _internal_has_pos();
}
inline void Map_WildNpcTroop::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& Map_WildNpcTroop::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Map_WildNpcTroop::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildNpcTroop.pos)
  return _internal_pos();
}
inline void Map_WildNpcTroop::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Map_WildNpcTroop.pos)
}
inline ::pb::map::HEX* Map_WildNpcTroop::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Map_WildNpcTroop::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Map_WildNpcTroop.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Map_WildNpcTroop::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* Map_WildNpcTroop::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Map_WildNpcTroop.pos)
  return _msg;
}
inline void Map_WildNpcTroop::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Map_WildNpcTroop.pos)
}

// int32 wild_npc_id = 3;
inline void Map_WildNpcTroop::clear_wild_npc_id() {
  _impl_.wild_npc_id_ = 0;
}
inline int32_t Map_WildNpcTroop::_internal_wild_npc_id() const {
  return _impl_.wild_npc_id_;
}
inline int32_t Map_WildNpcTroop::wild_npc_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildNpcTroop.wild_npc_id)
  return _internal_wild_npc_id();
}
inline void Map_WildNpcTroop::_internal_set_wild_npc_id(int32_t value) {
  
  _impl_.wild_npc_id_ = value;
}
inline void Map_WildNpcTroop::set_wild_npc_id(int32_t value) {
  _internal_set_wild_npc_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_WildNpcTroop.wild_npc_id)
}

// int64 disappear_time = 4;
inline void Map_WildNpcTroop::clear_disappear_time() {
  _impl_.disappear_time_ = int64_t{0};
}
inline int64_t Map_WildNpcTroop::_internal_disappear_time() const {
  return _impl_.disappear_time_;
}
inline int64_t Map_WildNpcTroop::disappear_time() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildNpcTroop.disappear_time)
  return _internal_disappear_time();
}
inline void Map_WildNpcTroop::_internal_set_disappear_time(int64_t value) {
  
  _impl_.disappear_time_ = value;
}
inline void Map_WildNpcTroop::set_disappear_time(int64_t value) {
  _internal_set_disappear_time(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_WildNpcTroop.disappear_time)
}

// int32 status = 5;
inline void Map_WildNpcTroop::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t Map_WildNpcTroop::_internal_status() const {
  return _impl_.status_;
}
inline int32_t Map_WildNpcTroop::status() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildNpcTroop.status)
  return _internal_status();
}
inline void Map_WildNpcTroop::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void Map_WildNpcTroop::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_WildNpcTroop.status)
}

// -------------------------------------------------------------------

// Map_WildBuilding

// uint32 id = 1;
inline void Map_WildBuilding::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t Map_WildBuilding::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t Map_WildBuilding::id() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildBuilding.id)
  return _internal_id();
}
inline void Map_WildBuilding::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void Map_WildBuilding::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_WildBuilding.id)
}

// .pb.map.HEX pos = 2;
inline bool Map_WildBuilding::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Map_WildBuilding::has_pos() const {
  return _internal_has_pos();
}
inline void Map_WildBuilding::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& Map_WildBuilding::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Map_WildBuilding::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildBuilding.pos)
  return _internal_pos();
}
inline void Map_WildBuilding::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Map_WildBuilding.pos)
}
inline ::pb::map::HEX* Map_WildBuilding::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Map_WildBuilding::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Map_WildBuilding.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Map_WildBuilding::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* Map_WildBuilding::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Map_WildBuilding.pos)
  return _msg;
}
inline void Map_WildBuilding::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Map_WildBuilding.pos)
}

// uint32 type = 3;
inline void Map_WildBuilding::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t Map_WildBuilding::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t Map_WildBuilding::type() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildBuilding.type)
  return _internal_type();
}
inline void Map_WildBuilding::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void Map_WildBuilding::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_WildBuilding.type)
}

// uint32 level = 4;
inline void Map_WildBuilding::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t Map_WildBuilding::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t Map_WildBuilding::level() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildBuilding.level)
  return _internal_level();
}
inline void Map_WildBuilding::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void Map_WildBuilding::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_WildBuilding.level)
}

// uint32 troop_num = 5;
inline void Map_WildBuilding::clear_troop_num() {
  _impl_.troop_num_ = 0u;
}
inline uint32_t Map_WildBuilding::_internal_troop_num() const {
  return _impl_.troop_num_;
}
inline uint32_t Map_WildBuilding::troop_num() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildBuilding.troop_num)
  return _internal_troop_num();
}
inline void Map_WildBuilding::_internal_set_troop_num(uint32_t value) {
  
  _impl_.troop_num_ = value;
}
inline void Map_WildBuilding::set_troop_num(uint32_t value) {
  _internal_set_troop_num(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_WildBuilding.troop_num)
}

// uint32 life = 6;
inline void Map_WildBuilding::clear_life() {
  _impl_.life_ = 0u;
}
inline uint32_t Map_WildBuilding::_internal_life() const {
  return _impl_.life_;
}
inline uint32_t Map_WildBuilding::life() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildBuilding.life)
  return _internal_life();
}
inline void Map_WildBuilding::_internal_set_life(uint32_t value) {
  
  _impl_.life_ = value;
}
inline void Map_WildBuilding::set_life(uint32_t value) {
  _internal_set_life(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_WildBuilding.life)
}

// uint32 life_max = 7;
inline void Map_WildBuilding::clear_life_max() {
  _impl_.life_max_ = 0u;
}
inline uint32_t Map_WildBuilding::_internal_life_max() const {
  return _impl_.life_max_;
}
inline uint32_t Map_WildBuilding::life_max() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildBuilding.life_max)
  return _internal_life_max();
}
inline void Map_WildBuilding::_internal_set_life_max(uint32_t value) {
  
  _impl_.life_max_ = value;
}
inline void Map_WildBuilding::set_life_max(uint32_t value) {
  _internal_set_life_max(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_WildBuilding.life_max)
}

// int32 disappear_time = 8;
inline void Map_WildBuilding::clear_disappear_time() {
  _impl_.disappear_time_ = 0;
}
inline int32_t Map_WildBuilding::_internal_disappear_time() const {
  return _impl_.disappear_time_;
}
inline int32_t Map_WildBuilding::disappear_time() const {
  // @@protoc_insertion_point(field_get:pb.map.Map_WildBuilding.disappear_time)
  return _internal_disappear_time();
}
inline void Map_WildBuilding::_internal_set_disappear_time(int32_t value) {
  
  _impl_.disappear_time_ = value;
}
inline void Map_WildBuilding::set_disappear_time(int32_t value) {
  _internal_set_disappear_time(value);
  // @@protoc_insertion_point(field_set:pb.map.Map_WildBuilding.disappear_time)
}

// -------------------------------------------------------------------

// MapUserData

// int64 user_id = 1;
inline void MapUserData::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t MapUserData::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t MapUserData::user_id() const {
  // @@protoc_insertion_point(field_get:pb.map.MapUserData.user_id)
  return _internal_user_id();
}
inline void MapUserData::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void MapUserData::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:pb.map.MapUserData.user_id)
}

// string user_name = 2;
inline void MapUserData::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& MapUserData::user_name() const {
  // @@protoc_insertion_point(field_get:pb.map.MapUserData.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MapUserData::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.map.MapUserData.user_name)
}
inline std::string* MapUserData::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:pb.map.MapUserData.user_name)
  return _s;
}
inline const std::string& MapUserData::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void MapUserData::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MapUserData::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MapUserData::release_user_name() {
  // @@protoc_insertion_point(field_release:pb.map.MapUserData.user_name)
  return _impl_.user_name_.Release();
}
inline void MapUserData::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.map.MapUserData.user_name)
}

// int32 guild_id = 3;
inline void MapUserData::clear_guild_id() {
  _impl_.guild_id_ = 0;
}
inline int32_t MapUserData::_internal_guild_id() const {
  return _impl_.guild_id_;
}
inline int32_t MapUserData::guild_id() const {
  // @@protoc_insertion_point(field_get:pb.map.MapUserData.guild_id)
  return _internal_guild_id();
}
inline void MapUserData::_internal_set_guild_id(int32_t value) {
  
  _impl_.guild_id_ = value;
}
inline void MapUserData::set_guild_id(int32_t value) {
  _internal_set_guild_id(value);
  // @@protoc_insertion_point(field_set:pb.map.MapUserData.guild_id)
}

// int32 capture_id = 4;
inline void MapUserData::clear_capture_id() {
  _impl_.capture_id_ = 0;
}
inline int32_t MapUserData::_internal_capture_id() const {
  return _impl_.capture_id_;
}
inline int32_t MapUserData::capture_id() const {
  // @@protoc_insertion_point(field_get:pb.map.MapUserData.capture_id)
  return _internal_capture_id();
}
inline void MapUserData::_internal_set_capture_id(int32_t value) {
  
  _impl_.capture_id_ = value;
}
inline void MapUserData::set_capture_id(int32_t value) {
  _internal_set_capture_id(value);
  // @@protoc_insertion_point(field_set:pb.map.MapUserData.capture_id)
}

// int32 guild_job = 5;
inline void MapUserData::clear_guild_job() {
  _impl_.guild_job_ = 0;
}
inline int32_t MapUserData::_internal_guild_job() const {
  return _impl_.guild_job_;
}
inline int32_t MapUserData::guild_job() const {
  // @@protoc_insertion_point(field_get:pb.map.MapUserData.guild_job)
  return _internal_guild_job();
}
inline void MapUserData::_internal_set_guild_job(int32_t value) {
  
  _impl_.guild_job_ = value;
}
inline void MapUserData::set_guild_job(int32_t value) {
  _internal_set_guild_job(value);
  // @@protoc_insertion_point(field_set:pb.map.MapUserData.guild_job)
}

// int32 civilization_type = 6;
inline void MapUserData::clear_civilization_type() {
  _impl_.civilization_type_ = 0;
}
inline int32_t MapUserData::_internal_civilization_type() const {
  return _impl_.civilization_type_;
}
inline int32_t MapUserData::civilization_type() const {
  // @@protoc_insertion_point(field_get:pb.map.MapUserData.civilization_type)
  return _internal_civilization_type();
}
inline void MapUserData::_internal_set_civilization_type(int32_t value) {
  
  _impl_.civilization_type_ = value;
}
inline void MapUserData::set_civilization_type(int32_t value) {
  _internal_set_civilization_type(value);
  // @@protoc_insertion_point(field_set:pb.map.MapUserData.civilization_type)
}

// -------------------------------------------------------------------

// Map_Objs

// repeated .pb.map.Map_Building vec_buildings = 1;
inline int Map_Objs::_internal_vec_buildings_size() const {
  return _impl_.vec_buildings_.size();
}
inline int Map_Objs::vec_buildings_size() const {
  return _internal_vec_buildings_size();
}
inline void Map_Objs::clear_vec_buildings() {
  _impl_.vec_buildings_.Clear();
}
inline ::pb::map::Map_Building* Map_Objs::mutable_vec_buildings(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Objs.vec_buildings)
  return _impl_.vec_buildings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Building >*
Map_Objs::mutable_vec_buildings() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Map_Objs.vec_buildings)
  return &_impl_.vec_buildings_;
}
inline const ::pb::map::Map_Building& Map_Objs::_internal_vec_buildings(int index) const {
  return _impl_.vec_buildings_.Get(index);
}
inline const ::pb::map::Map_Building& Map_Objs::vec_buildings(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Objs.vec_buildings)
  return _internal_vec_buildings(index);
}
inline ::pb::map::Map_Building* Map_Objs::_internal_add_vec_buildings() {
  return _impl_.vec_buildings_.Add();
}
inline ::pb::map::Map_Building* Map_Objs::add_vec_buildings() {
  ::pb::map::Map_Building* _add = _internal_add_vec_buildings();
  // @@protoc_insertion_point(field_add:pb.map.Map_Objs.vec_buildings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Building >&
Map_Objs::vec_buildings() const {
  // @@protoc_insertion_point(field_list:pb.map.Map_Objs.vec_buildings)
  return _impl_.vec_buildings_;
}

// repeated .pb.map.Map_Troop vec_troops = 2;
inline int Map_Objs::_internal_vec_troops_size() const {
  return _impl_.vec_troops_.size();
}
inline int Map_Objs::vec_troops_size() const {
  return _internal_vec_troops_size();
}
inline void Map_Objs::clear_vec_troops() {
  _impl_.vec_troops_.Clear();
}
inline ::pb::map::Map_Troop* Map_Objs::mutable_vec_troops(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Objs.vec_troops)
  return _impl_.vec_troops_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Troop >*
Map_Objs::mutable_vec_troops() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Map_Objs.vec_troops)
  return &_impl_.vec_troops_;
}
inline const ::pb::map::Map_Troop& Map_Objs::_internal_vec_troops(int index) const {
  return _impl_.vec_troops_.Get(index);
}
inline const ::pb::map::Map_Troop& Map_Objs::vec_troops(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Objs.vec_troops)
  return _internal_vec_troops(index);
}
inline ::pb::map::Map_Troop* Map_Objs::_internal_add_vec_troops() {
  return _impl_.vec_troops_.Add();
}
inline ::pb::map::Map_Troop* Map_Objs::add_vec_troops() {
  ::pb::map::Map_Troop* _add = _internal_add_vec_troops();
  // @@protoc_insertion_point(field_add:pb.map.Map_Objs.vec_troops)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Troop >&
Map_Objs::vec_troops() const {
  // @@protoc_insertion_point(field_list:pb.map.Map_Objs.vec_troops)
  return _impl_.vec_troops_;
}

// repeated .pb.map.Map_Field vec_fields = 3;
inline int Map_Objs::_internal_vec_fields_size() const {
  return _impl_.vec_fields_.size();
}
inline int Map_Objs::vec_fields_size() const {
  return _internal_vec_fields_size();
}
inline void Map_Objs::clear_vec_fields() {
  _impl_.vec_fields_.Clear();
}
inline ::pb::map::Map_Field* Map_Objs::mutable_vec_fields(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Objs.vec_fields)
  return _impl_.vec_fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Field >*
Map_Objs::mutable_vec_fields() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Map_Objs.vec_fields)
  return &_impl_.vec_fields_;
}
inline const ::pb::map::Map_Field& Map_Objs::_internal_vec_fields(int index) const {
  return _impl_.vec_fields_.Get(index);
}
inline const ::pb::map::Map_Field& Map_Objs::vec_fields(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Objs.vec_fields)
  return _internal_vec_fields(index);
}
inline ::pb::map::Map_Field* Map_Objs::_internal_add_vec_fields() {
  return _impl_.vec_fields_.Add();
}
inline ::pb::map::Map_Field* Map_Objs::add_vec_fields() {
  ::pb::map::Map_Field* _add = _internal_add_vec_fields();
  // @@protoc_insertion_point(field_add:pb.map.Map_Objs.vec_fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_Field >&
Map_Objs::vec_fields() const {
  // @@protoc_insertion_point(field_list:pb.map.Map_Objs.vec_fields)
  return _impl_.vec_fields_;
}

// repeated .pb.map.Map_RecoverField vec_recoverfield = 4;
inline int Map_Objs::_internal_vec_recoverfield_size() const {
  return _impl_.vec_recoverfield_.size();
}
inline int Map_Objs::vec_recoverfield_size() const {
  return _internal_vec_recoverfield_size();
}
inline void Map_Objs::clear_vec_recoverfield() {
  _impl_.vec_recoverfield_.Clear();
}
inline ::pb::map::Map_RecoverField* Map_Objs::mutable_vec_recoverfield(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Objs.vec_recoverfield)
  return _impl_.vec_recoverfield_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_RecoverField >*
Map_Objs::mutable_vec_recoverfield() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Map_Objs.vec_recoverfield)
  return &_impl_.vec_recoverfield_;
}
inline const ::pb::map::Map_RecoverField& Map_Objs::_internal_vec_recoverfield(int index) const {
  return _impl_.vec_recoverfield_.Get(index);
}
inline const ::pb::map::Map_RecoverField& Map_Objs::vec_recoverfield(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Objs.vec_recoverfield)
  return _internal_vec_recoverfield(index);
}
inline ::pb::map::Map_RecoverField* Map_Objs::_internal_add_vec_recoverfield() {
  return _impl_.vec_recoverfield_.Add();
}
inline ::pb::map::Map_RecoverField* Map_Objs::add_vec_recoverfield() {
  ::pb::map::Map_RecoverField* _add = _internal_add_vec_recoverfield();
  // @@protoc_insertion_point(field_add:pb.map.Map_Objs.vec_recoverfield)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_RecoverField >&
Map_Objs::vec_recoverfield() const {
  // @@protoc_insertion_point(field_list:pb.map.Map_Objs.vec_recoverfield)
  return _impl_.vec_recoverfield_;
}

// repeated .pb.map.Map_WildNpcTroop vec_wild_npc_troop = 5;
inline int Map_Objs::_internal_vec_wild_npc_troop_size() const {
  return _impl_.vec_wild_npc_troop_.size();
}
inline int Map_Objs::vec_wild_npc_troop_size() const {
  return _internal_vec_wild_npc_troop_size();
}
inline void Map_Objs::clear_vec_wild_npc_troop() {
  _impl_.vec_wild_npc_troop_.Clear();
}
inline ::pb::map::Map_WildNpcTroop* Map_Objs::mutable_vec_wild_npc_troop(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Objs.vec_wild_npc_troop)
  return _impl_.vec_wild_npc_troop_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildNpcTroop >*
Map_Objs::mutable_vec_wild_npc_troop() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Map_Objs.vec_wild_npc_troop)
  return &_impl_.vec_wild_npc_troop_;
}
inline const ::pb::map::Map_WildNpcTroop& Map_Objs::_internal_vec_wild_npc_troop(int index) const {
  return _impl_.vec_wild_npc_troop_.Get(index);
}
inline const ::pb::map::Map_WildNpcTroop& Map_Objs::vec_wild_npc_troop(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Objs.vec_wild_npc_troop)
  return _internal_vec_wild_npc_troop(index);
}
inline ::pb::map::Map_WildNpcTroop* Map_Objs::_internal_add_vec_wild_npc_troop() {
  return _impl_.vec_wild_npc_troop_.Add();
}
inline ::pb::map::Map_WildNpcTroop* Map_Objs::add_vec_wild_npc_troop() {
  ::pb::map::Map_WildNpcTroop* _add = _internal_add_vec_wild_npc_troop();
  // @@protoc_insertion_point(field_add:pb.map.Map_Objs.vec_wild_npc_troop)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildNpcTroop >&
Map_Objs::vec_wild_npc_troop() const {
  // @@protoc_insertion_point(field_list:pb.map.Map_Objs.vec_wild_npc_troop)
  return _impl_.vec_wild_npc_troop_;
}

// repeated .pb.map.Map_WildBuilding vec_wild_building = 6;
inline int Map_Objs::_internal_vec_wild_building_size() const {
  return _impl_.vec_wild_building_.size();
}
inline int Map_Objs::vec_wild_building_size() const {
  return _internal_vec_wild_building_size();
}
inline void Map_Objs::clear_vec_wild_building() {
  _impl_.vec_wild_building_.Clear();
}
inline ::pb::map::Map_WildBuilding* Map_Objs::mutable_vec_wild_building(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Objs.vec_wild_building)
  return _impl_.vec_wild_building_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildBuilding >*
Map_Objs::mutable_vec_wild_building() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Map_Objs.vec_wild_building)
  return &_impl_.vec_wild_building_;
}
inline const ::pb::map::Map_WildBuilding& Map_Objs::_internal_vec_wild_building(int index) const {
  return _impl_.vec_wild_building_.Get(index);
}
inline const ::pb::map::Map_WildBuilding& Map_Objs::vec_wild_building(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Objs.vec_wild_building)
  return _internal_vec_wild_building(index);
}
inline ::pb::map::Map_WildBuilding* Map_Objs::_internal_add_vec_wild_building() {
  return _impl_.vec_wild_building_.Add();
}
inline ::pb::map::Map_WildBuilding* Map_Objs::add_vec_wild_building() {
  ::pb::map::Map_WildBuilding* _add = _internal_add_vec_wild_building();
  // @@protoc_insertion_point(field_add:pb.map.Map_Objs.vec_wild_building)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildBuilding >&
Map_Objs::vec_wild_building() const {
  // @@protoc_insertion_point(field_list:pb.map.Map_Objs.vec_wild_building)
  return _impl_.vec_wild_building_;
}

// repeated .pb.map.MapUserData vec_users = 7;
inline int Map_Objs::_internal_vec_users_size() const {
  return _impl_.vec_users_.size();
}
inline int Map_Objs::vec_users_size() const {
  return _internal_vec_users_size();
}
inline void Map_Objs::clear_vec_users() {
  _impl_.vec_users_.Clear();
}
inline ::pb::map::MapUserData* Map_Objs::mutable_vec_users(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Map_Objs.vec_users)
  return _impl_.vec_users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::MapUserData >*
Map_Objs::mutable_vec_users() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Map_Objs.vec_users)
  return &_impl_.vec_users_;
}
inline const ::pb::map::MapUserData& Map_Objs::_internal_vec_users(int index) const {
  return _impl_.vec_users_.Get(index);
}
inline const ::pb::map::MapUserData& Map_Objs::vec_users(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Map_Objs.vec_users)
  return _internal_vec_users(index);
}
inline ::pb::map::MapUserData* Map_Objs::_internal_add_vec_users() {
  return _impl_.vec_users_.Add();
}
inline ::pb::map::MapUserData* Map_Objs::add_vec_users() {
  ::pb::map::MapUserData* _add = _internal_add_vec_users();
  // @@protoc_insertion_point(field_add:pb.map.Map_Objs.vec_users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::MapUserData >&
Map_Objs::vec_users() const {
  // @@protoc_insertion_point(field_list:pb.map.Map_Objs.vec_users)
  return _impl_.vec_users_;
}

// -------------------------------------------------------------------

// PrivateNpc_Troop

// uint32 id = 1;
inline void PrivateNpc_Troop::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t PrivateNpc_Troop::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t PrivateNpc_Troop::id() const {
  // @@protoc_insertion_point(field_get:pb.map.PrivateNpc_Troop.id)
  return _internal_id();
}
inline void PrivateNpc_Troop::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void PrivateNpc_Troop::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:pb.map.PrivateNpc_Troop.id)
}

// uint32 id_template = 2;
inline void PrivateNpc_Troop::clear_id_template() {
  _impl_.id_template_ = 0u;
}
inline uint32_t PrivateNpc_Troop::_internal_id_template() const {
  return _impl_.id_template_;
}
inline uint32_t PrivateNpc_Troop::id_template() const {
  // @@protoc_insertion_point(field_get:pb.map.PrivateNpc_Troop.id_template)
  return _internal_id_template();
}
inline void PrivateNpc_Troop::_internal_set_id_template(uint32_t value) {
  
  _impl_.id_template_ = value;
}
inline void PrivateNpc_Troop::set_id_template(uint32_t value) {
  _internal_set_id_template(value);
  // @@protoc_insertion_point(field_set:pb.map.PrivateNpc_Troop.id_template)
}

// .pb.map.HEX pos = 3;
inline bool PrivateNpc_Troop::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool PrivateNpc_Troop::has_pos() const {
  return _internal_has_pos();
}
inline void PrivateNpc_Troop::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& PrivateNpc_Troop::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& PrivateNpc_Troop::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.PrivateNpc_Troop.pos)
  return _internal_pos();
}
inline void PrivateNpc_Troop::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.PrivateNpc_Troop.pos)
}
inline ::pb::map::HEX* PrivateNpc_Troop::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* PrivateNpc_Troop::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.PrivateNpc_Troop.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* PrivateNpc_Troop::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* PrivateNpc_Troop::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.PrivateNpc_Troop.pos)
  return _msg;
}
inline void PrivateNpc_Troop::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.PrivateNpc_Troop.pos)
}

// -------------------------------------------------------------------

// Private_Map_Objs

// repeated .pb.map.PrivateNpc_Troop vec_troop = 1;
inline int Private_Map_Objs::_internal_vec_troop_size() const {
  return _impl_.vec_troop_.size();
}
inline int Private_Map_Objs::vec_troop_size() const {
  return _internal_vec_troop_size();
}
inline void Private_Map_Objs::clear_vec_troop() {
  _impl_.vec_troop_.Clear();
}
inline ::pb::map::PrivateNpc_Troop* Private_Map_Objs::mutable_vec_troop(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Private_Map_Objs.vec_troop)
  return _impl_.vec_troop_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::PrivateNpc_Troop >*
Private_Map_Objs::mutable_vec_troop() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Private_Map_Objs.vec_troop)
  return &_impl_.vec_troop_;
}
inline const ::pb::map::PrivateNpc_Troop& Private_Map_Objs::_internal_vec_troop(int index) const {
  return _impl_.vec_troop_.Get(index);
}
inline const ::pb::map::PrivateNpc_Troop& Private_Map_Objs::vec_troop(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Private_Map_Objs.vec_troop)
  return _internal_vec_troop(index);
}
inline ::pb::map::PrivateNpc_Troop* Private_Map_Objs::_internal_add_vec_troop() {
  return _impl_.vec_troop_.Add();
}
inline ::pb::map::PrivateNpc_Troop* Private_Map_Objs::add_vec_troop() {
  ::pb::map::PrivateNpc_Troop* _add = _internal_add_vec_troop();
  // @@protoc_insertion_point(field_add:pb.map.Private_Map_Objs.vec_troop)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::PrivateNpc_Troop >&
Private_Map_Objs::vec_troop() const {
  // @@protoc_insertion_point(field_list:pb.map.Private_Map_Objs.vec_troop)
  return _impl_.vec_troop_;
}

// repeated .pb.map.Map_WildNpcTroop vec_wild_npc_troop = 2;
inline int Private_Map_Objs::_internal_vec_wild_npc_troop_size() const {
  return _impl_.vec_wild_npc_troop_.size();
}
inline int Private_Map_Objs::vec_wild_npc_troop_size() const {
  return _internal_vec_wild_npc_troop_size();
}
inline void Private_Map_Objs::clear_vec_wild_npc_troop() {
  _impl_.vec_wild_npc_troop_.Clear();
}
inline ::pb::map::Map_WildNpcTroop* Private_Map_Objs::mutable_vec_wild_npc_troop(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Private_Map_Objs.vec_wild_npc_troop)
  return _impl_.vec_wild_npc_troop_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildNpcTroop >*
Private_Map_Objs::mutable_vec_wild_npc_troop() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Private_Map_Objs.vec_wild_npc_troop)
  return &_impl_.vec_wild_npc_troop_;
}
inline const ::pb::map::Map_WildNpcTroop& Private_Map_Objs::_internal_vec_wild_npc_troop(int index) const {
  return _impl_.vec_wild_npc_troop_.Get(index);
}
inline const ::pb::map::Map_WildNpcTroop& Private_Map_Objs::vec_wild_npc_troop(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Private_Map_Objs.vec_wild_npc_troop)
  return _internal_vec_wild_npc_troop(index);
}
inline ::pb::map::Map_WildNpcTroop* Private_Map_Objs::_internal_add_vec_wild_npc_troop() {
  return _impl_.vec_wild_npc_troop_.Add();
}
inline ::pb::map::Map_WildNpcTroop* Private_Map_Objs::add_vec_wild_npc_troop() {
  ::pb::map::Map_WildNpcTroop* _add = _internal_add_vec_wild_npc_troop();
  // @@protoc_insertion_point(field_add:pb.map.Private_Map_Objs.vec_wild_npc_troop)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Map_WildNpcTroop >&
Private_Map_Objs::vec_wild_npc_troop() const {
  // @@protoc_insertion_point(field_list:pb.map.Private_Map_Objs.vec_wild_npc_troop)
  return _impl_.vec_wild_npc_troop_;
}

// -------------------------------------------------------------------

// Collect_Map_OP

// uint32 errCode = 1;
inline void Collect_Map_OP::clear_errcode() {
  _impl_.errcode_ = 0u;
}
inline uint32_t Collect_Map_OP::_internal_errcode() const {
  return _impl_.errcode_;
}
inline uint32_t Collect_Map_OP::errcode() const {
  // @@protoc_insertion_point(field_get:pb.map.Collect_Map_OP.errCode)
  return _internal_errcode();
}
inline void Collect_Map_OP::_internal_set_errcode(uint32_t value) {
  
  _impl_.errcode_ = value;
}
inline void Collect_Map_OP::set_errcode(uint32_t value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:pb.map.Collect_Map_OP.errCode)
}

// .pb.map.HEX end_pos = 2;
inline bool Collect_Map_OP::_internal_has_end_pos() const {
  return this != internal_default_instance() && _impl_.end_pos_ != nullptr;
}
inline bool Collect_Map_OP::has_end_pos() const {
  return _internal_has_end_pos();
}
inline void Collect_Map_OP::clear_end_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.end_pos_ != nullptr) {
    delete _impl_.end_pos_;
  }
  _impl_.end_pos_ = nullptr;
}
inline const ::pb::map::HEX& Collect_Map_OP::_internal_end_pos() const {
  const ::pb::map::HEX* p = _impl_.end_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Collect_Map_OP::end_pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Collect_Map_OP.end_pos)
  return _internal_end_pos();
}
inline void Collect_Map_OP::unsafe_arena_set_allocated_end_pos(
    ::pb::map::HEX* end_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_pos_);
  }
  _impl_.end_pos_ = end_pos;
  if (end_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Collect_Map_OP.end_pos)
}
inline ::pb::map::HEX* Collect_Map_OP::release_end_pos() {
  
  ::pb::map::HEX* temp = _impl_.end_pos_;
  _impl_.end_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Collect_Map_OP::unsafe_arena_release_end_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Collect_Map_OP.end_pos)
  
  ::pb::map::HEX* temp = _impl_.end_pos_;
  _impl_.end_pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Collect_Map_OP::_internal_mutable_end_pos() {
  
  if (_impl_.end_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.end_pos_ = p;
  }
  return _impl_.end_pos_;
}
inline ::pb::map::HEX* Collect_Map_OP::mutable_end_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_end_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Collect_Map_OP.end_pos)
  return _msg;
}
inline void Collect_Map_OP::set_allocated_end_pos(::pb::map::HEX* end_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.end_pos_;
  }
  if (end_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end_pos);
    if (message_arena != submessage_arena) {
      end_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_pos_ = end_pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Collect_Map_OP.end_pos)
}

// string name = 3;
inline void Collect_Map_OP::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Collect_Map_OP::name() const {
  // @@protoc_insertion_point(field_get:pb.map.Collect_Map_OP.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Collect_Map_OP::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.map.Collect_Map_OP.name)
}
inline std::string* Collect_Map_OP::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pb.map.Collect_Map_OP.name)
  return _s;
}
inline const std::string& Collect_Map_OP::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Collect_Map_OP::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Collect_Map_OP::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Collect_Map_OP::release_name() {
  // @@protoc_insertion_point(field_release:pb.map.Collect_Map_OP.name)
  return _impl_.name_.Release();
}
inline void Collect_Map_OP::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.map.Collect_Map_OP.name)
}

// int64 idx = 4;
inline void Collect_Map_OP::clear_idx() {
  _impl_.idx_ = int64_t{0};
}
inline int64_t Collect_Map_OP::_internal_idx() const {
  return _impl_.idx_;
}
inline int64_t Collect_Map_OP::idx() const {
  // @@protoc_insertion_point(field_get:pb.map.Collect_Map_OP.idx)
  return _internal_idx();
}
inline void Collect_Map_OP::_internal_set_idx(int64_t value) {
  
  _impl_.idx_ = value;
}
inline void Collect_Map_OP::set_idx(int64_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:pb.map.Collect_Map_OP.idx)
}

// -------------------------------------------------------------------

// Move_City

// uint32 error_code = 1;
inline void Move_City::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t Move_City::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t Move_City::error_code() const {
  // @@protoc_insertion_point(field_get:pb.map.Move_City.error_code)
  return _internal_error_code();
}
inline void Move_City::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Move_City::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pb.map.Move_City.error_code)
}

// uint32 idx = 2;
inline void Move_City::clear_idx() {
  _impl_.idx_ = 0u;
}
inline uint32_t Move_City::_internal_idx() const {
  return _impl_.idx_;
}
inline uint32_t Move_City::idx() const {
  // @@protoc_insertion_point(field_get:pb.map.Move_City.idx)
  return _internal_idx();
}
inline void Move_City::_internal_set_idx(uint32_t value) {
  
  _impl_.idx_ = value;
}
inline void Move_City::set_idx(uint32_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:pb.map.Move_City.idx)
}

// .pb.map.HEX move_pos = 3;
inline bool Move_City::_internal_has_move_pos() const {
  return this != internal_default_instance() && _impl_.move_pos_ != nullptr;
}
inline bool Move_City::has_move_pos() const {
  return _internal_has_move_pos();
}
inline void Move_City::clear_move_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.move_pos_ != nullptr) {
    delete _impl_.move_pos_;
  }
  _impl_.move_pos_ = nullptr;
}
inline const ::pb::map::HEX& Move_City::_internal_move_pos() const {
  const ::pb::map::HEX* p = _impl_.move_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Move_City::move_pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Move_City.move_pos)
  return _internal_move_pos();
}
inline void Move_City::unsafe_arena_set_allocated_move_pos(
    ::pb::map::HEX* move_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.move_pos_);
  }
  _impl_.move_pos_ = move_pos;
  if (move_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Move_City.move_pos)
}
inline ::pb::map::HEX* Move_City::release_move_pos() {
  
  ::pb::map::HEX* temp = _impl_.move_pos_;
  _impl_.move_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Move_City::unsafe_arena_release_move_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Move_City.move_pos)
  
  ::pb::map::HEX* temp = _impl_.move_pos_;
  _impl_.move_pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Move_City::_internal_mutable_move_pos() {
  
  if (_impl_.move_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.move_pos_ = p;
  }
  return _impl_.move_pos_;
}
inline ::pb::map::HEX* Move_City::mutable_move_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_move_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Move_City.move_pos)
  return _msg;
}
inline void Move_City::set_allocated_move_pos(::pb::map::HEX* move_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.move_pos_;
  }
  if (move_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(move_pos);
    if (message_arena != submessage_arena) {
      move_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.move_pos_ = move_pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Move_City.move_pos)
}

// -------------------------------------------------------------------

// Resurgence

// uint32 error_code = 1;
inline void Resurgence::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t Resurgence::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t Resurgence::error_code() const {
  // @@protoc_insertion_point(field_get:pb.map.Resurgence.error_code)
  return _internal_error_code();
}
inline void Resurgence::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Resurgence::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pb.map.Resurgence.error_code)
}

// .pb.map.HEX pos = 2;
inline bool Resurgence::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Resurgence::has_pos() const {
  return _internal_has_pos();
}
inline void Resurgence::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& Resurgence::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Resurgence::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Resurgence.pos)
  return _internal_pos();
}
inline void Resurgence::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Resurgence.pos)
}
inline ::pb::map::HEX* Resurgence::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Resurgence::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Resurgence.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Resurgence::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* Resurgence::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Resurgence.pos)
  return _msg;
}
inline void Resurgence::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Resurgence.pos)
}

// -------------------------------------------------------------------

// Migrate

// uint32 error_code = 1;
inline void Migrate::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t Migrate::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t Migrate::error_code() const {
  // @@protoc_insertion_point(field_get:pb.map.Migrate.error_code)
  return _internal_error_code();
}
inline void Migrate::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Migrate::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pb.map.Migrate.error_code)
}

// int32 country_id = 2;
inline void Migrate::clear_country_id() {
  _impl_.country_id_ = 0;
}
inline int32_t Migrate::_internal_country_id() const {
  return _impl_.country_id_;
}
inline int32_t Migrate::country_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Migrate.country_id)
  return _internal_country_id();
}
inline void Migrate::_internal_set_country_id(int32_t value) {
  
  _impl_.country_id_ = value;
}
inline void Migrate::set_country_id(int32_t value) {
  _internal_set_country_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Migrate.country_id)
}

// .pb.map.HEX pos = 3;
inline bool Migrate::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Migrate::has_pos() const {
  return _internal_has_pos();
}
inline void Migrate::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& Migrate::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Migrate::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Migrate.pos)
  return _internal_pos();
}
inline void Migrate::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Migrate.pos)
}
inline ::pb::map::HEX* Migrate::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Migrate::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Migrate.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Migrate::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* Migrate::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Migrate.pos)
  return _msg;
}
inline void Migrate::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Migrate.pos)
}

// -------------------------------------------------------------------

// Req_Scout

// uint32 error_code = 1;
inline void Req_Scout::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t Req_Scout::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t Req_Scout::error_code() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_Scout.error_code)
  return _internal_error_code();
}
inline void Req_Scout::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Req_Scout::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pb.map.Req_Scout.error_code)
}

// .pb.map.HEX pos = 2;
inline bool Req_Scout::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Req_Scout::has_pos() const {
  return _internal_has_pos();
}
inline void Req_Scout::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& Req_Scout::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& Req_Scout::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_Scout.pos)
  return _internal_pos();
}
inline void Req_Scout::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.Req_Scout.pos)
}
inline ::pb::map::HEX* Req_Scout::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* Req_Scout::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.Req_Scout.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* Req_Scout::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* Req_Scout::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.Req_Scout.pos)
  return _msg;
}
inline void Req_Scout::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.Req_Scout.pos)
}

// -------------------------------------------------------------------

// TroopScout

// int32 seq_no = 1;
inline void TroopScout::clear_seq_no() {
  _impl_.seq_no_ = 0;
}
inline int32_t TroopScout::_internal_seq_no() const {
  return _impl_.seq_no_;
}
inline int32_t TroopScout::seq_no() const {
  // @@protoc_insertion_point(field_get:pb.map.TroopScout.seq_no)
  return _internal_seq_no();
}
inline void TroopScout::_internal_set_seq_no(int32_t value) {
  
  _impl_.seq_no_ = value;
}
inline void TroopScout::set_seq_no(int32_t value) {
  _internal_set_seq_no(value);
  // @@protoc_insertion_point(field_set:pb.map.TroopScout.seq_no)
}

// int32 troop_id = 2;
inline void TroopScout::clear_troop_id() {
  _impl_.troop_id_ = 0;
}
inline int32_t TroopScout::_internal_troop_id() const {
  return _impl_.troop_id_;
}
inline int32_t TroopScout::troop_id() const {
  // @@protoc_insertion_point(field_get:pb.map.TroopScout.troop_id)
  return _internal_troop_id();
}
inline void TroopScout::_internal_set_troop_id(int32_t value) {
  
  _impl_.troop_id_ = value;
}
inline void TroopScout::set_troop_id(int32_t value) {
  _internal_set_troop_id(value);
  // @@protoc_insertion_point(field_set:pb.map.TroopScout.troop_id)
}

// int32 force1 = 3;
inline void TroopScout::clear_force1() {
  _impl_.force1_ = 0;
}
inline int32_t TroopScout::_internal_force1() const {
  return _impl_.force1_;
}
inline int32_t TroopScout::force1() const {
  // @@protoc_insertion_point(field_get:pb.map.TroopScout.force1)
  return _internal_force1();
}
inline void TroopScout::_internal_set_force1(int32_t value) {
  
  _impl_.force1_ = value;
}
inline void TroopScout::set_force1(int32_t value) {
  _internal_set_force1(value);
  // @@protoc_insertion_point(field_set:pb.map.TroopScout.force1)
}

// int32 force2 = 4;
inline void TroopScout::clear_force2() {
  _impl_.force2_ = 0;
}
inline int32_t TroopScout::_internal_force2() const {
  return _impl_.force2_;
}
inline int32_t TroopScout::force2() const {
  // @@protoc_insertion_point(field_get:pb.map.TroopScout.force2)
  return _internal_force2();
}
inline void TroopScout::_internal_set_force2(int32_t value) {
  
  _impl_.force2_ = value;
}
inline void TroopScout::set_force2(int32_t value) {
  _internal_set_force2(value);
  // @@protoc_insertion_point(field_set:pb.map.TroopScout.force2)
}

// int32 force3 = 5;
inline void TroopScout::clear_force3() {
  _impl_.force3_ = 0;
}
inline int32_t TroopScout::_internal_force3() const {
  return _impl_.force3_;
}
inline int32_t TroopScout::force3() const {
  // @@protoc_insertion_point(field_get:pb.map.TroopScout.force3)
  return _internal_force3();
}
inline void TroopScout::_internal_set_force3(int32_t value) {
  
  _impl_.force3_ = value;
}
inline void TroopScout::set_force3(int32_t value) {
  _internal_set_force3(value);
  // @@protoc_insertion_point(field_set:pb.map.TroopScout.force3)
}

// -------------------------------------------------------------------

// FieldScout

// .pb.map.HEX pos = 1;
inline bool FieldScout::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool FieldScout::has_pos() const {
  return _internal_has_pos();
}
inline void FieldScout::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& FieldScout::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& FieldScout::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.FieldScout.pos)
  return _internal_pos();
}
inline void FieldScout::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.FieldScout.pos)
}
inline ::pb::map::HEX* FieldScout::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* FieldScout::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.FieldScout.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* FieldScout::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* FieldScout::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.FieldScout.pos)
  return _msg;
}
inline void FieldScout::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.FieldScout.pos)
}

// repeated .pb.map.TroopScout scout_info = 2;
inline int FieldScout::_internal_scout_info_size() const {
  return _impl_.scout_info_.size();
}
inline int FieldScout::scout_info_size() const {
  return _internal_scout_info_size();
}
inline void FieldScout::clear_scout_info() {
  _impl_.scout_info_.Clear();
}
inline ::pb::map::TroopScout* FieldScout::mutable_scout_info(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.FieldScout.scout_info)
  return _impl_.scout_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::TroopScout >*
FieldScout::mutable_scout_info() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.FieldScout.scout_info)
  return &_impl_.scout_info_;
}
inline const ::pb::map::TroopScout& FieldScout::_internal_scout_info(int index) const {
  return _impl_.scout_info_.Get(index);
}
inline const ::pb::map::TroopScout& FieldScout::scout_info(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.FieldScout.scout_info)
  return _internal_scout_info(index);
}
inline ::pb::map::TroopScout* FieldScout::_internal_add_scout_info() {
  return _impl_.scout_info_.Add();
}
inline ::pb::map::TroopScout* FieldScout::add_scout_info() {
  ::pb::map::TroopScout* _add = _internal_add_scout_info();
  // @@protoc_insertion_point(field_add:pb.map.FieldScout.scout_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::TroopScout >&
FieldScout::scout_info() const {
  // @@protoc_insertion_point(field_list:pb.map.FieldScout.scout_info)
  return _impl_.scout_info_;
}

// int64 scout_time = 3;
inline void FieldScout::clear_scout_time() {
  _impl_.scout_time_ = int64_t{0};
}
inline int64_t FieldScout::_internal_scout_time() const {
  return _impl_.scout_time_;
}
inline int64_t FieldScout::scout_time() const {
  // @@protoc_insertion_point(field_get:pb.map.FieldScout.scout_time)
  return _internal_scout_time();
}
inline void FieldScout::_internal_set_scout_time(int64_t value) {
  
  _impl_.scout_time_ = value;
}
inline void FieldScout::set_scout_time(int64_t value) {
  _internal_set_scout_time(value);
  // @@protoc_insertion_point(field_set:pb.map.FieldScout.scout_time)
}

// int64 scout_end_time = 4;
inline void FieldScout::clear_scout_end_time() {
  _impl_.scout_end_time_ = int64_t{0};
}
inline int64_t FieldScout::_internal_scout_end_time() const {
  return _impl_.scout_end_time_;
}
inline int64_t FieldScout::scout_end_time() const {
  // @@protoc_insertion_point(field_get:pb.map.FieldScout.scout_end_time)
  return _internal_scout_end_time();
}
inline void FieldScout::_internal_set_scout_end_time(int64_t value) {
  
  _impl_.scout_end_time_ = value;
}
inline void FieldScout::set_scout_end_time(int64_t value) {
  _internal_set_scout_end_time(value);
  // @@protoc_insertion_point(field_set:pb.map.FieldScout.scout_end_time)
}

// -------------------------------------------------------------------

// Rep_Scout

// repeated .pb.map.FieldScout field_scout = 1;
inline int Rep_Scout::_internal_field_scout_size() const {
  return _impl_.field_scout_.size();
}
inline int Rep_Scout::field_scout_size() const {
  return _internal_field_scout_size();
}
inline void Rep_Scout::clear_field_scout() {
  _impl_.field_scout_.Clear();
}
inline ::pb::map::FieldScout* Rep_Scout::mutable_field_scout(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Rep_Scout.field_scout)
  return _impl_.field_scout_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::FieldScout >*
Rep_Scout::mutable_field_scout() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Rep_Scout.field_scout)
  return &_impl_.field_scout_;
}
inline const ::pb::map::FieldScout& Rep_Scout::_internal_field_scout(int index) const {
  return _impl_.field_scout_.Get(index);
}
inline const ::pb::map::FieldScout& Rep_Scout::field_scout(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Rep_Scout.field_scout)
  return _internal_field_scout(index);
}
inline ::pb::map::FieldScout* Rep_Scout::_internal_add_field_scout() {
  return _impl_.field_scout_.Add();
}
inline ::pb::map::FieldScout* Rep_Scout::add_field_scout() {
  ::pb::map::FieldScout* _add = _internal_add_field_scout();
  // @@protoc_insertion_point(field_add:pb.map.Rep_Scout.field_scout)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::FieldScout >&
Rep_Scout::field_scout() const {
  // @@protoc_insertion_point(field_list:pb.map.Rep_Scout.field_scout)
  return _impl_.field_scout_;
}

// uint64 next_scout_time = 2;
inline void Rep_Scout::clear_next_scout_time() {
  _impl_.next_scout_time_ = uint64_t{0u};
}
inline uint64_t Rep_Scout::_internal_next_scout_time() const {
  return _impl_.next_scout_time_;
}
inline uint64_t Rep_Scout::next_scout_time() const {
  // @@protoc_insertion_point(field_get:pb.map.Rep_Scout.next_scout_time)
  return _internal_next_scout_time();
}
inline void Rep_Scout::_internal_set_next_scout_time(uint64_t value) {
  
  _impl_.next_scout_time_ = value;
}
inline void Rep_Scout::set_next_scout_time(uint64_t value) {
  _internal_set_next_scout_time(value);
  // @@protoc_insertion_point(field_set:pb.map.Rep_Scout.next_scout_time)
}

// -------------------------------------------------------------------

// Rep_DeleteScout

// repeated uint32 vec_pos = 1;
inline int Rep_DeleteScout::_internal_vec_pos_size() const {
  return _impl_.vec_pos_.size();
}
inline int Rep_DeleteScout::vec_pos_size() const {
  return _internal_vec_pos_size();
}
inline void Rep_DeleteScout::clear_vec_pos() {
  _impl_.vec_pos_.Clear();
}
inline uint32_t Rep_DeleteScout::_internal_vec_pos(int index) const {
  return _impl_.vec_pos_.Get(index);
}
inline uint32_t Rep_DeleteScout::vec_pos(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Rep_DeleteScout.vec_pos)
  return _internal_vec_pos(index);
}
inline void Rep_DeleteScout::set_vec_pos(int index, uint32_t value) {
  _impl_.vec_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.map.Rep_DeleteScout.vec_pos)
}
inline void Rep_DeleteScout::_internal_add_vec_pos(uint32_t value) {
  _impl_.vec_pos_.Add(value);
}
inline void Rep_DeleteScout::add_vec_pos(uint32_t value) {
  _internal_add_vec_pos(value);
  // @@protoc_insertion_point(field_add:pb.map.Rep_DeleteScout.vec_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Rep_DeleteScout::_internal_vec_pos() const {
  return _impl_.vec_pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Rep_DeleteScout::vec_pos() const {
  // @@protoc_insertion_point(field_list:pb.map.Rep_DeleteScout.vec_pos)
  return _internal_vec_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Rep_DeleteScout::_internal_mutable_vec_pos() {
  return &_impl_.vec_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Rep_DeleteScout::mutable_vec_pos() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Rep_DeleteScout.vec_pos)
  return _internal_mutable_vec_pos();
}

// -------------------------------------------------------------------

// Rep_ClearScout

// .pb.map.E_Map_CMD cmd = 1;
inline void Rep_ClearScout::clear_cmd() {
  _impl_.cmd_ = 0;
}
inline ::pb::map::E_Map_CMD Rep_ClearScout::_internal_cmd() const {
  return static_cast< ::pb::map::E_Map_CMD >(_impl_.cmd_);
}
inline ::pb::map::E_Map_CMD Rep_ClearScout::cmd() const {
  // @@protoc_insertion_point(field_get:pb.map.Rep_ClearScout.cmd)
  return _internal_cmd();
}
inline void Rep_ClearScout::_internal_set_cmd(::pb::map::E_Map_CMD value) {
  
  _impl_.cmd_ = value;
}
inline void Rep_ClearScout::set_cmd(::pb::map::E_Map_CMD value) {
  _internal_set_cmd(value);
  // @@protoc_insertion_point(field_set:pb.map.Rep_ClearScout.cmd)
}

// -------------------------------------------------------------------

// CombatantUser

// int64 user_id = 1;
inline void CombatantUser::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t CombatantUser::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t CombatantUser::user_id() const {
  // @@protoc_insertion_point(field_get:pb.map.CombatantUser.user_id)
  return _internal_user_id();
}
inline void CombatantUser::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void CombatantUser::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:pb.map.CombatantUser.user_id)
}

// string user_name = 2;
inline void CombatantUser::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& CombatantUser::user_name() const {
  // @@protoc_insertion_point(field_get:pb.map.CombatantUser.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CombatantUser::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.map.CombatantUser.user_name)
}
inline std::string* CombatantUser::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:pb.map.CombatantUser.user_name)
  return _s;
}
inline const std::string& CombatantUser::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void CombatantUser::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CombatantUser::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CombatantUser::release_user_name() {
  // @@protoc_insertion_point(field_release:pb.map.CombatantUser.user_name)
  return _impl_.user_name_.Release();
}
inline void CombatantUser::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.map.CombatantUser.user_name)
}

// int32 honor = 3;
inline void CombatantUser::clear_honor() {
  _impl_.honor_ = 0;
}
inline int32_t CombatantUser::_internal_honor() const {
  return _impl_.honor_;
}
inline int32_t CombatantUser::honor() const {
  // @@protoc_insertion_point(field_get:pb.map.CombatantUser.honor)
  return _internal_honor();
}
inline void CombatantUser::_internal_set_honor(int32_t value) {
  
  _impl_.honor_ = value;
}
inline void CombatantUser::set_honor(int32_t value) {
  _internal_set_honor(value);
  // @@protoc_insertion_point(field_set:pb.map.CombatantUser.honor)
}

// int32 occupy = 4;
inline void CombatantUser::clear_occupy() {
  _impl_.occupy_ = 0;
}
inline int32_t CombatantUser::_internal_occupy() const {
  return _impl_.occupy_;
}
inline int32_t CombatantUser::occupy() const {
  // @@protoc_insertion_point(field_get:pb.map.CombatantUser.occupy)
  return _internal_occupy();
}
inline void CombatantUser::_internal_set_occupy(int32_t value) {
  
  _impl_.occupy_ = value;
}
inline void CombatantUser::set_occupy(int32_t value) {
  _internal_set_occupy(value);
  // @@protoc_insertion_point(field_set:pb.map.CombatantUser.occupy)
}

// -------------------------------------------------------------------

// MapCampaign

// .pb.map.HEX pos = 1;
inline bool MapCampaign::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool MapCampaign::has_pos() const {
  return _internal_has_pos();
}
inline void MapCampaign::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& MapCampaign::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& MapCampaign::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.MapCampaign.pos)
  return _internal_pos();
}
inline void MapCampaign::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.MapCampaign.pos)
}
inline ::pb::map::HEX* MapCampaign::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* MapCampaign::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.MapCampaign.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* MapCampaign::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* MapCampaign::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.MapCampaign.pos)
  return _msg;
}
inline void MapCampaign::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.MapCampaign.pos)
}

// int32 building_id = 2;
inline void MapCampaign::clear_building_id() {
  _impl_.building_id_ = 0;
}
inline int32_t MapCampaign::_internal_building_id() const {
  return _impl_.building_id_;
}
inline int32_t MapCampaign::building_id() const {
  // @@protoc_insertion_point(field_get:pb.map.MapCampaign.building_id)
  return _internal_building_id();
}
inline void MapCampaign::_internal_set_building_id(int32_t value) {
  
  _impl_.building_id_ = value;
}
inline void MapCampaign::set_building_id(int32_t value) {
  _internal_set_building_id(value);
  // @@protoc_insertion_point(field_set:pb.map.MapCampaign.building_id)
}

// int32 count = 3;
inline void MapCampaign::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t MapCampaign::_internal_count() const {
  return _impl_.count_;
}
inline int32_t MapCampaign::count() const {
  // @@protoc_insertion_point(field_get:pb.map.MapCampaign.count)
  return _internal_count();
}
inline void MapCampaign::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void MapCampaign::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:pb.map.MapCampaign.count)
}

// .pb.map.E_MapCampaignScale scale = 4;
inline void MapCampaign::clear_scale() {
  _impl_.scale_ = 0;
}
inline ::pb::map::E_MapCampaignScale MapCampaign::_internal_scale() const {
  return static_cast< ::pb::map::E_MapCampaignScale >(_impl_.scale_);
}
inline ::pb::map::E_MapCampaignScale MapCampaign::scale() const {
  // @@protoc_insertion_point(field_get:pb.map.MapCampaign.scale)
  return _internal_scale();
}
inline void MapCampaign::_internal_set_scale(::pb::map::E_MapCampaignScale value) {
  
  _impl_.scale_ = value;
}
inline void MapCampaign::set_scale(::pb::map::E_MapCampaignScale value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:pb.map.MapCampaign.scale)
}

// repeated int32 combatant_guilds = 5;
inline int MapCampaign::_internal_combatant_guilds_size() const {
  return _impl_.combatant_guilds_.size();
}
inline int MapCampaign::combatant_guilds_size() const {
  return _internal_combatant_guilds_size();
}
inline void MapCampaign::clear_combatant_guilds() {
  _impl_.combatant_guilds_.Clear();
}
inline int32_t MapCampaign::_internal_combatant_guilds(int index) const {
  return _impl_.combatant_guilds_.Get(index);
}
inline int32_t MapCampaign::combatant_guilds(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.MapCampaign.combatant_guilds)
  return _internal_combatant_guilds(index);
}
inline void MapCampaign::set_combatant_guilds(int index, int32_t value) {
  _impl_.combatant_guilds_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.map.MapCampaign.combatant_guilds)
}
inline void MapCampaign::_internal_add_combatant_guilds(int32_t value) {
  _impl_.combatant_guilds_.Add(value);
}
inline void MapCampaign::add_combatant_guilds(int32_t value) {
  _internal_add_combatant_guilds(value);
  // @@protoc_insertion_point(field_add:pb.map.MapCampaign.combatant_guilds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MapCampaign::_internal_combatant_guilds() const {
  return _impl_.combatant_guilds_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MapCampaign::combatant_guilds() const {
  // @@protoc_insertion_point(field_list:pb.map.MapCampaign.combatant_guilds)
  return _internal_combatant_guilds();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MapCampaign::_internal_mutable_combatant_guilds() {
  return &_impl_.combatant_guilds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MapCampaign::mutable_combatant_guilds() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.MapCampaign.combatant_guilds)
  return _internal_mutable_combatant_guilds();
}

// int64 start_time = 6;
inline void MapCampaign::clear_start_time() {
  _impl_.start_time_ = int64_t{0};
}
inline int64_t MapCampaign::_internal_start_time() const {
  return _impl_.start_time_;
}
inline int64_t MapCampaign::start_time() const {
  // @@protoc_insertion_point(field_get:pb.map.MapCampaign.start_time)
  return _internal_start_time();
}
inline void MapCampaign::_internal_set_start_time(int64_t value) {
  
  _impl_.start_time_ = value;
}
inline void MapCampaign::set_start_time(int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:pb.map.MapCampaign.start_time)
}

// int64 end_time = 7;
inline void MapCampaign::clear_end_time() {
  _impl_.end_time_ = int64_t{0};
}
inline int64_t MapCampaign::_internal_end_time() const {
  return _impl_.end_time_;
}
inline int64_t MapCampaign::end_time() const {
  // @@protoc_insertion_point(field_get:pb.map.MapCampaign.end_time)
  return _internal_end_time();
}
inline void MapCampaign::_internal_set_end_time(int64_t value) {
  
  _impl_.end_time_ = value;
}
inline void MapCampaign::set_end_time(int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:pb.map.MapCampaign.end_time)
}

// .pb.map.CombatantUser honor_top = 8;
inline bool MapCampaign::_internal_has_honor_top() const {
  return this != internal_default_instance() && _impl_.honor_top_ != nullptr;
}
inline bool MapCampaign::has_honor_top() const {
  return _internal_has_honor_top();
}
inline void MapCampaign::clear_honor_top() {
  if (GetArenaForAllocation() == nullptr && _impl_.honor_top_ != nullptr) {
    delete _impl_.honor_top_;
  }
  _impl_.honor_top_ = nullptr;
}
inline const ::pb::map::CombatantUser& MapCampaign::_internal_honor_top() const {
  const ::pb::map::CombatantUser* p = _impl_.honor_top_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::CombatantUser&>(
      ::pb::map::_CombatantUser_default_instance_);
}
inline const ::pb::map::CombatantUser& MapCampaign::honor_top() const {
  // @@protoc_insertion_point(field_get:pb.map.MapCampaign.honor_top)
  return _internal_honor_top();
}
inline void MapCampaign::unsafe_arena_set_allocated_honor_top(
    ::pb::map::CombatantUser* honor_top) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.honor_top_);
  }
  _impl_.honor_top_ = honor_top;
  if (honor_top) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.MapCampaign.honor_top)
}
inline ::pb::map::CombatantUser* MapCampaign::release_honor_top() {
  
  ::pb::map::CombatantUser* temp = _impl_.honor_top_;
  _impl_.honor_top_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::CombatantUser* MapCampaign::unsafe_arena_release_honor_top() {
  // @@protoc_insertion_point(field_release:pb.map.MapCampaign.honor_top)
  
  ::pb::map::CombatantUser* temp = _impl_.honor_top_;
  _impl_.honor_top_ = nullptr;
  return temp;
}
inline ::pb::map::CombatantUser* MapCampaign::_internal_mutable_honor_top() {
  
  if (_impl_.honor_top_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::CombatantUser>(GetArenaForAllocation());
    _impl_.honor_top_ = p;
  }
  return _impl_.honor_top_;
}
inline ::pb::map::CombatantUser* MapCampaign::mutable_honor_top() {
  ::pb::map::CombatantUser* _msg = _internal_mutable_honor_top();
  // @@protoc_insertion_point(field_mutable:pb.map.MapCampaign.honor_top)
  return _msg;
}
inline void MapCampaign::set_allocated_honor_top(::pb::map::CombatantUser* honor_top) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.honor_top_;
  }
  if (honor_top) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(honor_top);
    if (message_arena != submessage_arena) {
      honor_top = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, honor_top, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.honor_top_ = honor_top;
  // @@protoc_insertion_point(field_set_allocated:pb.map.MapCampaign.honor_top)
}

// .pb.map.CombatantUser occupy_top = 9;
inline bool MapCampaign::_internal_has_occupy_top() const {
  return this != internal_default_instance() && _impl_.occupy_top_ != nullptr;
}
inline bool MapCampaign::has_occupy_top() const {
  return _internal_has_occupy_top();
}
inline void MapCampaign::clear_occupy_top() {
  if (GetArenaForAllocation() == nullptr && _impl_.occupy_top_ != nullptr) {
    delete _impl_.occupy_top_;
  }
  _impl_.occupy_top_ = nullptr;
}
inline const ::pb::map::CombatantUser& MapCampaign::_internal_occupy_top() const {
  const ::pb::map::CombatantUser* p = _impl_.occupy_top_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::CombatantUser&>(
      ::pb::map::_CombatantUser_default_instance_);
}
inline const ::pb::map::CombatantUser& MapCampaign::occupy_top() const {
  // @@protoc_insertion_point(field_get:pb.map.MapCampaign.occupy_top)
  return _internal_occupy_top();
}
inline void MapCampaign::unsafe_arena_set_allocated_occupy_top(
    ::pb::map::CombatantUser* occupy_top) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.occupy_top_);
  }
  _impl_.occupy_top_ = occupy_top;
  if (occupy_top) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.MapCampaign.occupy_top)
}
inline ::pb::map::CombatantUser* MapCampaign::release_occupy_top() {
  
  ::pb::map::CombatantUser* temp = _impl_.occupy_top_;
  _impl_.occupy_top_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::CombatantUser* MapCampaign::unsafe_arena_release_occupy_top() {
  // @@protoc_insertion_point(field_release:pb.map.MapCampaign.occupy_top)
  
  ::pb::map::CombatantUser* temp = _impl_.occupy_top_;
  _impl_.occupy_top_ = nullptr;
  return temp;
}
inline ::pb::map::CombatantUser* MapCampaign::_internal_mutable_occupy_top() {
  
  if (_impl_.occupy_top_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::CombatantUser>(GetArenaForAllocation());
    _impl_.occupy_top_ = p;
  }
  return _impl_.occupy_top_;
}
inline ::pb::map::CombatantUser* MapCampaign::mutable_occupy_top() {
  ::pb::map::CombatantUser* _msg = _internal_mutable_occupy_top();
  // @@protoc_insertion_point(field_mutable:pb.map.MapCampaign.occupy_top)
  return _msg;
}
inline void MapCampaign::set_allocated_occupy_top(::pb::map::CombatantUser* occupy_top) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.occupy_top_;
  }
  if (occupy_top) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(occupy_top);
    if (message_arena != submessage_arena) {
      occupy_top = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, occupy_top, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.occupy_top_ = occupy_top;
  // @@protoc_insertion_point(field_set_allocated:pb.map.MapCampaign.occupy_top)
}

// .pb.map.CombatantUser self = 10;
inline bool MapCampaign::_internal_has_self() const {
  return this != internal_default_instance() && _impl_.self_ != nullptr;
}
inline bool MapCampaign::has_self() const {
  return _internal_has_self();
}
inline void MapCampaign::clear_self() {
  if (GetArenaForAllocation() == nullptr && _impl_.self_ != nullptr) {
    delete _impl_.self_;
  }
  _impl_.self_ = nullptr;
}
inline const ::pb::map::CombatantUser& MapCampaign::_internal_self() const {
  const ::pb::map::CombatantUser* p = _impl_.self_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::CombatantUser&>(
      ::pb::map::_CombatantUser_default_instance_);
}
inline const ::pb::map::CombatantUser& MapCampaign::self() const {
  // @@protoc_insertion_point(field_get:pb.map.MapCampaign.self)
  return _internal_self();
}
inline void MapCampaign::unsafe_arena_set_allocated_self(
    ::pb::map::CombatantUser* self) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.self_);
  }
  _impl_.self_ = self;
  if (self) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.MapCampaign.self)
}
inline ::pb::map::CombatantUser* MapCampaign::release_self() {
  
  ::pb::map::CombatantUser* temp = _impl_.self_;
  _impl_.self_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::CombatantUser* MapCampaign::unsafe_arena_release_self() {
  // @@protoc_insertion_point(field_release:pb.map.MapCampaign.self)
  
  ::pb::map::CombatantUser* temp = _impl_.self_;
  _impl_.self_ = nullptr;
  return temp;
}
inline ::pb::map::CombatantUser* MapCampaign::_internal_mutable_self() {
  
  if (_impl_.self_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::CombatantUser>(GetArenaForAllocation());
    _impl_.self_ = p;
  }
  return _impl_.self_;
}
inline ::pb::map::CombatantUser* MapCampaign::mutable_self() {
  ::pb::map::CombatantUser* _msg = _internal_mutable_self();
  // @@protoc_insertion_point(field_mutable:pb.map.MapCampaign.self)
  return _msg;
}
inline void MapCampaign::set_allocated_self(::pb::map::CombatantUser* self) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.self_;
  }
  if (self) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(self);
    if (message_arena != submessage_arena) {
      self = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.self_ = self;
  // @@protoc_insertion_point(field_set_allocated:pb.map.MapCampaign.self)
}

// -------------------------------------------------------------------

// MapCampaignResp

// repeated .pb.map.MapCampaign campaigns = 1;
inline int MapCampaignResp::_internal_campaigns_size() const {
  return _impl_.campaigns_.size();
}
inline int MapCampaignResp::campaigns_size() const {
  return _internal_campaigns_size();
}
inline void MapCampaignResp::clear_campaigns() {
  _impl_.campaigns_.Clear();
}
inline ::pb::map::MapCampaign* MapCampaignResp::mutable_campaigns(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.MapCampaignResp.campaigns)
  return _impl_.campaigns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::MapCampaign >*
MapCampaignResp::mutable_campaigns() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.MapCampaignResp.campaigns)
  return &_impl_.campaigns_;
}
inline const ::pb::map::MapCampaign& MapCampaignResp::_internal_campaigns(int index) const {
  return _impl_.campaigns_.Get(index);
}
inline const ::pb::map::MapCampaign& MapCampaignResp::campaigns(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.MapCampaignResp.campaigns)
  return _internal_campaigns(index);
}
inline ::pb::map::MapCampaign* MapCampaignResp::_internal_add_campaigns() {
  return _impl_.campaigns_.Add();
}
inline ::pb::map::MapCampaign* MapCampaignResp::add_campaigns() {
  ::pb::map::MapCampaign* _add = _internal_add_campaigns();
  // @@protoc_insertion_point(field_add:pb.map.MapCampaignResp.campaigns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::MapCampaign >&
MapCampaignResp::campaigns() const {
  // @@protoc_insertion_point(field_list:pb.map.MapCampaignResp.campaigns)
  return _impl_.campaigns_;
}

// -------------------------------------------------------------------

// Country

// int32 country_id = 1;
inline void Country::clear_country_id() {
  _impl_.country_id_ = 0;
}
inline int32_t Country::_internal_country_id() const {
  return _impl_.country_id_;
}
inline int32_t Country::country_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Country.country_id)
  return _internal_country_id();
}
inline void Country::_internal_set_country_id(int32_t value) {
  
  _impl_.country_id_ = value;
}
inline void Country::set_country_id(int32_t value) {
  _internal_set_country_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Country.country_id)
}

// int32 num = 2;
inline void Country::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t Country::_internal_num() const {
  return _impl_.num_;
}
inline int32_t Country::num() const {
  // @@protoc_insertion_point(field_get:pb.map.Country.num)
  return _internal_num();
}
inline void Country::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void Country::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:pb.map.Country.num)
}

// int32 open = 3;
inline void Country::clear_open() {
  _impl_.open_ = 0;
}
inline int32_t Country::_internal_open() const {
  return _impl_.open_;
}
inline int32_t Country::open() const {
  // @@protoc_insertion_point(field_get:pb.map.Country.open)
  return _internal_open();
}
inline void Country::_internal_set_open(int32_t value) {
  
  _impl_.open_ = value;
}
inline void Country::set_open(int32_t value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:pb.map.Country.open)
}

// -------------------------------------------------------------------

// Country_Info

// repeated .pb.map.Country countries = 1;
inline int Country_Info::_internal_countries_size() const {
  return _impl_.countries_.size();
}
inline int Country_Info::countries_size() const {
  return _internal_countries_size();
}
inline void Country_Info::clear_countries() {
  _impl_.countries_.Clear();
}
inline ::pb::map::Country* Country_Info::mutable_countries(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Country_Info.countries)
  return _impl_.countries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Country >*
Country_Info::mutable_countries() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Country_Info.countries)
  return &_impl_.countries_;
}
inline const ::pb::map::Country& Country_Info::_internal_countries(int index) const {
  return _impl_.countries_.Get(index);
}
inline const ::pb::map::Country& Country_Info::countries(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Country_Info.countries)
  return _internal_countries(index);
}
inline ::pb::map::Country* Country_Info::_internal_add_countries() {
  return _impl_.countries_.Add();
}
inline ::pb::map::Country* Country_Info::add_countries() {
  ::pb::map::Country* _add = _internal_add_countries();
  // @@protoc_insertion_point(field_add:pb.map.Country_Info.countries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::Country >&
Country_Info::countries() const {
  // @@protoc_insertion_point(field_list:pb.map.Country_Info.countries)
  return _impl_.countries_;
}

// -------------------------------------------------------------------

// Choose_Country

// uint32 error_code = 1;
inline void Choose_Country::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t Choose_Country::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t Choose_Country::error_code() const {
  // @@protoc_insertion_point(field_get:pb.map.Choose_Country.error_code)
  return _internal_error_code();
}
inline void Choose_Country::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Choose_Country::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pb.map.Choose_Country.error_code)
}

// int32 country_id = 2;
inline void Choose_Country::clear_country_id() {
  _impl_.country_id_ = 0;
}
inline int32_t Choose_Country::_internal_country_id() const {
  return _impl_.country_id_;
}
inline int32_t Choose_Country::country_id() const {
  // @@protoc_insertion_point(field_get:pb.map.Choose_Country.country_id)
  return _internal_country_id();
}
inline void Choose_Country::_internal_set_country_id(int32_t value) {
  
  _impl_.country_id_ = value;
}
inline void Choose_Country::set_country_id(int32_t value) {
  _internal_set_country_id(value);
  // @@protoc_insertion_point(field_set:pb.map.Choose_Country.country_id)
}

// -------------------------------------------------------------------

// CampaignScale

// .pb.map.HEX pos = 1;
inline bool CampaignScale::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool CampaignScale::has_pos() const {
  return _internal_has_pos();
}
inline void CampaignScale::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::pb::map::HEX& CampaignScale::_internal_pos() const {
  const ::pb::map::HEX* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::map::HEX&>(
      ::pb::map::_HEX_default_instance_);
}
inline const ::pb::map::HEX& CampaignScale::pos() const {
  // @@protoc_insertion_point(field_get:pb.map.CampaignScale.pos)
  return _internal_pos();
}
inline void CampaignScale::unsafe_arena_set_allocated_pos(
    ::pb::map::HEX* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.map.CampaignScale.pos)
}
inline ::pb::map::HEX* CampaignScale::release_pos() {
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::map::HEX* CampaignScale::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pb.map.CampaignScale.pos)
  
  ::pb::map::HEX* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::pb::map::HEX* CampaignScale::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::map::HEX>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::pb::map::HEX* CampaignScale::mutable_pos() {
  ::pb::map::HEX* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:pb.map.CampaignScale.pos)
  return _msg;
}
inline void CampaignScale::set_allocated_pos(::pb::map::HEX* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pb.map.CampaignScale.pos)
}

// int32 scale = 2;
inline void CampaignScale::clear_scale() {
  _impl_.scale_ = 0;
}
inline int32_t CampaignScale::_internal_scale() const {
  return _impl_.scale_;
}
inline int32_t CampaignScale::scale() const {
  // @@protoc_insertion_point(field_get:pb.map.CampaignScale.scale)
  return _internal_scale();
}
inline void CampaignScale::_internal_set_scale(int32_t value) {
  
  _impl_.scale_ = value;
}
inline void CampaignScale::set_scale(int32_t value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:pb.map.CampaignScale.scale)
}

// bool finish = 3;
inline void CampaignScale::clear_finish() {
  _impl_.finish_ = false;
}
inline bool CampaignScale::_internal_finish() const {
  return _impl_.finish_;
}
inline bool CampaignScale::finish() const {
  // @@protoc_insertion_point(field_get:pb.map.CampaignScale.finish)
  return _internal_finish();
}
inline void CampaignScale::_internal_set_finish(bool value) {
  
  _impl_.finish_ = value;
}
inline void CampaignScale::set_finish(bool value) {
  _internal_set_finish(value);
  // @@protoc_insertion_point(field_set:pb.map.CampaignScale.finish)
}

// -------------------------------------------------------------------

// Req_SearchMapObj

// int32 q = 1;
inline void Req_SearchMapObj::clear_q() {
  _impl_.q_ = 0;
}
inline int32_t Req_SearchMapObj::_internal_q() const {
  return _impl_.q_;
}
inline int32_t Req_SearchMapObj::q() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_SearchMapObj.q)
  return _internal_q();
}
inline void Req_SearchMapObj::_internal_set_q(int32_t value) {
  
  _impl_.q_ = value;
}
inline void Req_SearchMapObj::set_q(int32_t value) {
  _internal_set_q(value);
  // @@protoc_insertion_point(field_set:pb.map.Req_SearchMapObj.q)
}

// int32 r = 2;
inline void Req_SearchMapObj::clear_r() {
  _impl_.r_ = 0;
}
inline int32_t Req_SearchMapObj::_internal_r() const {
  return _impl_.r_;
}
inline int32_t Req_SearchMapObj::r() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_SearchMapObj.r)
  return _internal_r();
}
inline void Req_SearchMapObj::_internal_set_r(int32_t value) {
  
  _impl_.r_ = value;
}
inline void Req_SearchMapObj::set_r(int32_t value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:pb.map.Req_SearchMapObj.r)
}

// int32 exhale = 3;
inline void Req_SearchMapObj::clear_exhale() {
  _impl_.exhale_ = 0;
}
inline int32_t Req_SearchMapObj::_internal_exhale() const {
  return _impl_.exhale_;
}
inline int32_t Req_SearchMapObj::exhale() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_SearchMapObj.exhale)
  return _internal_exhale();
}
inline void Req_SearchMapObj::_internal_set_exhale(int32_t value) {
  
  _impl_.exhale_ = value;
}
inline void Req_SearchMapObj::set_exhale(int32_t value) {
  _internal_set_exhale(value);
  // @@protoc_insertion_point(field_set:pb.map.Req_SearchMapObj.exhale)
}

// int32 obj_kind = 4;
inline void Req_SearchMapObj::clear_obj_kind() {
  _impl_.obj_kind_ = 0;
}
inline int32_t Req_SearchMapObj::_internal_obj_kind() const {
  return _impl_.obj_kind_;
}
inline int32_t Req_SearchMapObj::obj_kind() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_SearchMapObj.obj_kind)
  return _internal_obj_kind();
}
inline void Req_SearchMapObj::_internal_set_obj_kind(int32_t value) {
  
  _impl_.obj_kind_ = value;
}
inline void Req_SearchMapObj::set_obj_kind(int32_t value) {
  _internal_set_obj_kind(value);
  // @@protoc_insertion_point(field_set:pb.map.Req_SearchMapObj.obj_kind)
}

// int32 obj_type = 5;
inline void Req_SearchMapObj::clear_obj_type() {
  _impl_.obj_type_ = 0;
}
inline int32_t Req_SearchMapObj::_internal_obj_type() const {
  return _impl_.obj_type_;
}
inline int32_t Req_SearchMapObj::obj_type() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_SearchMapObj.obj_type)
  return _internal_obj_type();
}
inline void Req_SearchMapObj::_internal_set_obj_type(int32_t value) {
  
  _impl_.obj_type_ = value;
}
inline void Req_SearchMapObj::set_obj_type(int32_t value) {
  _internal_set_obj_type(value);
  // @@protoc_insertion_point(field_set:pb.map.Req_SearchMapObj.obj_type)
}

// int32 obj_level_min = 6;
inline void Req_SearchMapObj::clear_obj_level_min() {
  _impl_.obj_level_min_ = 0;
}
inline int32_t Req_SearchMapObj::_internal_obj_level_min() const {
  return _impl_.obj_level_min_;
}
inline int32_t Req_SearchMapObj::obj_level_min() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_SearchMapObj.obj_level_min)
  return _internal_obj_level_min();
}
inline void Req_SearchMapObj::_internal_set_obj_level_min(int32_t value) {
  
  _impl_.obj_level_min_ = value;
}
inline void Req_SearchMapObj::set_obj_level_min(int32_t value) {
  _internal_set_obj_level_min(value);
  // @@protoc_insertion_point(field_set:pb.map.Req_SearchMapObj.obj_level_min)
}

// int32 obj_level_max = 7;
inline void Req_SearchMapObj::clear_obj_level_max() {
  _impl_.obj_level_max_ = 0;
}
inline int32_t Req_SearchMapObj::_internal_obj_level_max() const {
  return _impl_.obj_level_max_;
}
inline int32_t Req_SearchMapObj::obj_level_max() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_SearchMapObj.obj_level_max)
  return _internal_obj_level_max();
}
inline void Req_SearchMapObj::_internal_set_obj_level_max(int32_t value) {
  
  _impl_.obj_level_max_ = value;
}
inline void Req_SearchMapObj::set_obj_level_max(int32_t value) {
  _internal_set_obj_level_max(value);
  // @@protoc_insertion_point(field_set:pb.map.Req_SearchMapObj.obj_level_max)
}

// int32 obj_belong = 8;
inline void Req_SearchMapObj::clear_obj_belong() {
  _impl_.obj_belong_ = 0;
}
inline int32_t Req_SearchMapObj::_internal_obj_belong() const {
  return _impl_.obj_belong_;
}
inline int32_t Req_SearchMapObj::obj_belong() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_SearchMapObj.obj_belong)
  return _internal_obj_belong();
}
inline void Req_SearchMapObj::_internal_set_obj_belong(int32_t value) {
  
  _impl_.obj_belong_ = value;
}
inline void Req_SearchMapObj::set_obj_belong(int32_t value) {
  _internal_set_obj_belong(value);
  // @@protoc_insertion_point(field_set:pb.map.Req_SearchMapObj.obj_belong)
}

// -------------------------------------------------------------------

// Rep_SearchMapObj

// uint32 error_code = 1;
inline void Rep_SearchMapObj::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t Rep_SearchMapObj::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t Rep_SearchMapObj::error_code() const {
  // @@protoc_insertion_point(field_get:pb.map.Rep_SearchMapObj.error_code)
  return _internal_error_code();
}
inline void Rep_SearchMapObj::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Rep_SearchMapObj::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pb.map.Rep_SearchMapObj.error_code)
}

// int32 result = 2;
inline void Rep_SearchMapObj::clear_result() {
  _impl_.result_ = 0;
}
inline int32_t Rep_SearchMapObj::_internal_result() const {
  return _impl_.result_;
}
inline int32_t Rep_SearchMapObj::result() const {
  // @@protoc_insertion_point(field_get:pb.map.Rep_SearchMapObj.result)
  return _internal_result();
}
inline void Rep_SearchMapObj::_internal_set_result(int32_t value) {
  
  _impl_.result_ = value;
}
inline void Rep_SearchMapObj::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:pb.map.Rep_SearchMapObj.result)
}

// repeated .pb.map.HEX lst_hex = 3;
inline int Rep_SearchMapObj::_internal_lst_hex_size() const {
  return _impl_.lst_hex_.size();
}
inline int Rep_SearchMapObj::lst_hex_size() const {
  return _internal_lst_hex_size();
}
inline void Rep_SearchMapObj::clear_lst_hex() {
  _impl_.lst_hex_.Clear();
}
inline ::pb::map::HEX* Rep_SearchMapObj::mutable_lst_hex(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Rep_SearchMapObj.lst_hex)
  return _impl_.lst_hex_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >*
Rep_SearchMapObj::mutable_lst_hex() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Rep_SearchMapObj.lst_hex)
  return &_impl_.lst_hex_;
}
inline const ::pb::map::HEX& Rep_SearchMapObj::_internal_lst_hex(int index) const {
  return _impl_.lst_hex_.Get(index);
}
inline const ::pb::map::HEX& Rep_SearchMapObj::lst_hex(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Rep_SearchMapObj.lst_hex)
  return _internal_lst_hex(index);
}
inline ::pb::map::HEX* Rep_SearchMapObj::_internal_add_lst_hex() {
  return _impl_.lst_hex_.Add();
}
inline ::pb::map::HEX* Rep_SearchMapObj::add_lst_hex() {
  ::pb::map::HEX* _add = _internal_add_lst_hex();
  // @@protoc_insertion_point(field_add:pb.map.Rep_SearchMapObj.lst_hex)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::HEX >&
Rep_SearchMapObj::lst_hex() const {
  // @@protoc_insertion_point(field_list:pb.map.Rep_SearchMapObj.lst_hex)
  return _impl_.lst_hex_;
}

// -------------------------------------------------------------------

// TimerTask

// int64 id = 1;
inline void TimerTask::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t TimerTask::_internal_id() const {
  return _impl_.id_;
}
inline int64_t TimerTask::id() const {
  // @@protoc_insertion_point(field_get:pb.map.TimerTask.id)
  return _internal_id();
}
inline void TimerTask::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void TimerTask::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:pb.map.TimerTask.id)
}

// int64 user_id = 2;
inline void TimerTask::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t TimerTask::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t TimerTask::user_id() const {
  // @@protoc_insertion_point(field_get:pb.map.TimerTask.user_id)
  return _internal_user_id();
}
inline void TimerTask::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void TimerTask::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:pb.map.TimerTask.user_id)
}

// uint32 type = 3;
inline void TimerTask::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t TimerTask::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t TimerTask::type() const {
  // @@protoc_insertion_point(field_get:pb.map.TimerTask.type)
  return _internal_type();
}
inline void TimerTask::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void TimerTask::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.map.TimerTask.type)
}

// int64 end_time = 4;
inline void TimerTask::clear_end_time() {
  _impl_.end_time_ = int64_t{0};
}
inline int64_t TimerTask::_internal_end_time() const {
  return _impl_.end_time_;
}
inline int64_t TimerTask::end_time() const {
  // @@protoc_insertion_point(field_get:pb.map.TimerTask.end_time)
  return _internal_end_time();
}
inline void TimerTask::_internal_set_end_time(int64_t value) {
  
  _impl_.end_time_ = value;
}
inline void TimerTask::set_end_time(int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:pb.map.TimerTask.end_time)
}

// int64 id_link = 5;
inline void TimerTask::clear_id_link() {
  _impl_.id_link_ = int64_t{0};
}
inline int64_t TimerTask::_internal_id_link() const {
  return _impl_.id_link_;
}
inline int64_t TimerTask::id_link() const {
  // @@protoc_insertion_point(field_get:pb.map.TimerTask.id_link)
  return _internal_id_link();
}
inline void TimerTask::_internal_set_id_link(int64_t value) {
  
  _impl_.id_link_ = value;
}
inline void TimerTask::set_id_link(int64_t value) {
  _internal_set_id_link(value);
  // @@protoc_insertion_point(field_set:pb.map.TimerTask.id_link)
}

// int64 param = 6;
inline void TimerTask::clear_param() {
  _impl_.param_ = int64_t{0};
}
inline int64_t TimerTask::_internal_param() const {
  return _impl_.param_;
}
inline int64_t TimerTask::param() const {
  // @@protoc_insertion_point(field_get:pb.map.TimerTask.param)
  return _internal_param();
}
inline void TimerTask::_internal_set_param(int64_t value) {
  
  _impl_.param_ = value;
}
inline void TimerTask::set_param(int64_t value) {
  _internal_set_param(value);
  // @@protoc_insertion_point(field_set:pb.map.TimerTask.param)
}

// bytes pb_param = 7;
inline void TimerTask::clear_pb_param() {
  _impl_.pb_param_.ClearToEmpty();
}
inline const std::string& TimerTask::pb_param() const {
  // @@protoc_insertion_point(field_get:pb.map.TimerTask.pb_param)
  return _internal_pb_param();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TimerTask::set_pb_param(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pb_param_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.map.TimerTask.pb_param)
}
inline std::string* TimerTask::mutable_pb_param() {
  std::string* _s = _internal_mutable_pb_param();
  // @@protoc_insertion_point(field_mutable:pb.map.TimerTask.pb_param)
  return _s;
}
inline const std::string& TimerTask::_internal_pb_param() const {
  return _impl_.pb_param_.Get();
}
inline void TimerTask::_internal_set_pb_param(const std::string& value) {
  
  _impl_.pb_param_.Set(value, GetArenaForAllocation());
}
inline std::string* TimerTask::_internal_mutable_pb_param() {
  
  return _impl_.pb_param_.Mutable(GetArenaForAllocation());
}
inline std::string* TimerTask::release_pb_param() {
  // @@protoc_insertion_point(field_release:pb.map.TimerTask.pb_param)
  return _impl_.pb_param_.Release();
}
inline void TimerTask::set_allocated_pb_param(std::string* pb_param) {
  if (pb_param != nullptr) {
    
  } else {
    
  }
  _impl_.pb_param_.SetAllocated(pb_param, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pb_param_.IsDefault()) {
    _impl_.pb_param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.map.TimerTask.pb_param)
}

// -------------------------------------------------------------------

// Rep_Timer_list

// repeated .pb.map.TimerTask lst = 1;
inline int Rep_Timer_list::_internal_lst_size() const {
  return _impl_.lst_.size();
}
inline int Rep_Timer_list::lst_size() const {
  return _internal_lst_size();
}
inline void Rep_Timer_list::clear_lst() {
  _impl_.lst_.Clear();
}
inline ::pb::map::TimerTask* Rep_Timer_list::mutable_lst(int index) {
  // @@protoc_insertion_point(field_mutable:pb.map.Rep_Timer_list.lst)
  return _impl_.lst_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::TimerTask >*
Rep_Timer_list::mutable_lst() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Rep_Timer_list.lst)
  return &_impl_.lst_;
}
inline const ::pb::map::TimerTask& Rep_Timer_list::_internal_lst(int index) const {
  return _impl_.lst_.Get(index);
}
inline const ::pb::map::TimerTask& Rep_Timer_list::lst(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Rep_Timer_list.lst)
  return _internal_lst(index);
}
inline ::pb::map::TimerTask* Rep_Timer_list::_internal_add_lst() {
  return _impl_.lst_.Add();
}
inline ::pb::map::TimerTask* Rep_Timer_list::add_lst() {
  ::pb::map::TimerTask* _add = _internal_add_lst();
  // @@protoc_insertion_point(field_add:pb.map.Rep_Timer_list.lst)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::map::TimerTask >&
Rep_Timer_list::lst() const {
  // @@protoc_insertion_point(field_list:pb.map.Rep_Timer_list.lst)
  return _impl_.lst_;
}

// -------------------------------------------------------------------

// Req_ChgMap

// uint32 error_code = 1;
inline void Req_ChgMap::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t Req_ChgMap::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t Req_ChgMap::error_code() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_ChgMap.error_code)
  return _internal_error_code();
}
inline void Req_ChgMap::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Req_ChgMap::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pb.map.Req_ChgMap.error_code)
}

// uint32 mapType = 2;
inline void Req_ChgMap::clear_maptype() {
  _impl_.maptype_ = 0u;
}
inline uint32_t Req_ChgMap::_internal_maptype() const {
  return _impl_.maptype_;
}
inline uint32_t Req_ChgMap::maptype() const {
  // @@protoc_insertion_point(field_get:pb.map.Req_ChgMap.mapType)
  return _internal_maptype();
}
inline void Req_ChgMap::_internal_set_maptype(uint32_t value) {
  
  _impl_.maptype_ = value;
}
inline void Req_ChgMap::set_maptype(uint32_t value) {
  _internal_set_maptype(value);
  // @@protoc_insertion_point(field_set:pb.map.Req_ChgMap.mapType)
}

// -------------------------------------------------------------------

// Req_Map_Chk_View

// repeated int64 vec_chk_troop_lst = 1;
inline int Req_Map_Chk_View::_internal_vec_chk_troop_lst_size() const {
  return _impl_.vec_chk_troop_lst_.size();
}
inline int Req_Map_Chk_View::vec_chk_troop_lst_size() const {
  return _internal_vec_chk_troop_lst_size();
}
inline void Req_Map_Chk_View::clear_vec_chk_troop_lst() {
  _impl_.vec_chk_troop_lst_.Clear();
}
inline int64_t Req_Map_Chk_View::_internal_vec_chk_troop_lst(int index) const {
  return _impl_.vec_chk_troop_lst_.Get(index);
}
inline int64_t Req_Map_Chk_View::vec_chk_troop_lst(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Req_Map_Chk_View.vec_chk_troop_lst)
  return _internal_vec_chk_troop_lst(index);
}
inline void Req_Map_Chk_View::set_vec_chk_troop_lst(int index, int64_t value) {
  _impl_.vec_chk_troop_lst_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.map.Req_Map_Chk_View.vec_chk_troop_lst)
}
inline void Req_Map_Chk_View::_internal_add_vec_chk_troop_lst(int64_t value) {
  _impl_.vec_chk_troop_lst_.Add(value);
}
inline void Req_Map_Chk_View::add_vec_chk_troop_lst(int64_t value) {
  _internal_add_vec_chk_troop_lst(value);
  // @@protoc_insertion_point(field_add:pb.map.Req_Map_Chk_View.vec_chk_troop_lst)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Req_Map_Chk_View::_internal_vec_chk_troop_lst() const {
  return _impl_.vec_chk_troop_lst_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Req_Map_Chk_View::vec_chk_troop_lst() const {
  // @@protoc_insertion_point(field_list:pb.map.Req_Map_Chk_View.vec_chk_troop_lst)
  return _internal_vec_chk_troop_lst();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Req_Map_Chk_View::_internal_mutable_vec_chk_troop_lst() {
  return &_impl_.vec_chk_troop_lst_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Req_Map_Chk_View::mutable_vec_chk_troop_lst() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Req_Map_Chk_View.vec_chk_troop_lst)
  return _internal_mutable_vec_chk_troop_lst();
}

// repeated int64 vec_chk_buildings_lst = 2;
inline int Req_Map_Chk_View::_internal_vec_chk_buildings_lst_size() const {
  return _impl_.vec_chk_buildings_lst_.size();
}
inline int Req_Map_Chk_View::vec_chk_buildings_lst_size() const {
  return _internal_vec_chk_buildings_lst_size();
}
inline void Req_Map_Chk_View::clear_vec_chk_buildings_lst() {
  _impl_.vec_chk_buildings_lst_.Clear();
}
inline int64_t Req_Map_Chk_View::_internal_vec_chk_buildings_lst(int index) const {
  return _impl_.vec_chk_buildings_lst_.Get(index);
}
inline int64_t Req_Map_Chk_View::vec_chk_buildings_lst(int index) const {
  // @@protoc_insertion_point(field_get:pb.map.Req_Map_Chk_View.vec_chk_buildings_lst)
  return _internal_vec_chk_buildings_lst(index);
}
inline void Req_Map_Chk_View::set_vec_chk_buildings_lst(int index, int64_t value) {
  _impl_.vec_chk_buildings_lst_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.map.Req_Map_Chk_View.vec_chk_buildings_lst)
}
inline void Req_Map_Chk_View::_internal_add_vec_chk_buildings_lst(int64_t value) {
  _impl_.vec_chk_buildings_lst_.Add(value);
}
inline void Req_Map_Chk_View::add_vec_chk_buildings_lst(int64_t value) {
  _internal_add_vec_chk_buildings_lst(value);
  // @@protoc_insertion_point(field_add:pb.map.Req_Map_Chk_View.vec_chk_buildings_lst)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Req_Map_Chk_View::_internal_vec_chk_buildings_lst() const {
  return _impl_.vec_chk_buildings_lst_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Req_Map_Chk_View::vec_chk_buildings_lst() const {
  // @@protoc_insertion_point(field_list:pb.map.Req_Map_Chk_View.vec_chk_buildings_lst)
  return _internal_vec_chk_buildings_lst();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Req_Map_Chk_View::_internal_mutable_vec_chk_buildings_lst() {
  return &_impl_.vec_chk_buildings_lst_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Req_Map_Chk_View::mutable_vec_chk_buildings_lst() {
  // @@protoc_insertion_point(field_mutable_list:pb.map.Req_Map_Chk_View.vec_chk_buildings_lst)
  return _internal_mutable_vec_chk_buildings_lst();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace map
}  // namespace pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb::map::E_Map_CMD> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::map::E_Map_CMD>() {
  return ::pb::map::E_Map_CMD_descriptor();
}
template <> struct is_proto_enum< ::pb::map::E_AIBehavior_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::map::E_AIBehavior_Type>() {
  return ::pb::map::E_AIBehavior_Type_descriptor();
}
template <> struct is_proto_enum< ::pb::map::E_MapCampaignScale> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::map::E_MapCampaignScale>() {
  return ::pb::map::E_MapCampaignScale_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_map_2eproto
